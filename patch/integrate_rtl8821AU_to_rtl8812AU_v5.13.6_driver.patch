diff -Naur /hal/btc/btc_basic_types.h /hal/btc/btc_basic_types.h
--- /hal/btc/btc_basic_types.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/btc_basic_types.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef __BTC_BASIC_TYPES_H__
+#define __BTC_BASIC_TYPES_H__
+
+#define IN
+#define OUT
+#define VOID void
+typedef void *PVOID;
+
+#define u1Byte		u8
+#define pu1Byte		u8*
+
+#define u2Byte		u16
+#define pu2Byte		u16*
+
+#define u4Byte		u32
+#define pu4Byte		u32*
+
+#define u8Byte		u64
+#define pu8Byte		u64*
+
+#define s1Byte		s8
+#define ps1Byte		s8*
+
+#define s2Byte		s16
+#define ps2Byte		s16*
+
+#define s4Byte		s32
+#define ps4Byte		s32*
+
+#define s8Byte		s64
+#define ps8Byte		s64*
+
+#define UCHAR u8
+#define USHORT u16
+#define UINT u32
+#define ULONG u32
+#define PULONG u32*
+
+#endif /* __BTC_BASIC_TYPES_H__ */
diff -Naur /hal/btc/halbtc8821a1ant.c /hal/btc/halbtc8821a1ant.c
--- /hal/btc/halbtc8821a1ant.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/halbtc8821a1ant.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,2996 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+
+/* ************************************************************
+ * Description:
+ *
+ * This file is for 8821A_1ANT Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************
+ * SY modify 2015/04/27
+ * ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_1ant		glcoex_dm_8821a_1ant;
+static struct  coex_dm_8821a_1ant	*coex_dm = &glcoex_dm_8821a_1ant;
+static struct  coex_sta_8821a_1ant		glcoex_sta_8821a_1ant;
+static struct  coex_sta_8821a_1ant	*coex_sta = &glcoex_sta_8821a_1ant;
+
+const char *const glbt_info_src_8821a_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_1ant = 20190509;
+u32	glcoex_ver_8821a_1ant = 0x6d;
+u32	glcoex_ver_btdesired_8821a_1ant = 0x62;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a1ant_
+ * ************************************************************ */
+u8 halbtc8821a1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+
+void halbtc8821a1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8821a1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	u8	h2c_parameter[1] = {0};
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* Only enable for windows becaus 8821cu H2C 0x69 unknown fail @ linux */
+	if (btcoexist->chip_interface != BTC_INTF_USB) {
+		/*send h2c to query WL FW dbg info	*/
+		if (((coex_dm->cur_ps_tdma_on) && (coex_sta->force_lps_ctrl)) ||
+			 ((coex_sta->acl_busy) && (bt_link_info->a2dp_exist))) {
+			h2c_parameter[0] = 0x8;
+			btcoexist->btc_fill_h2c(btcoexist, 0x69, 1, h2c_parameter);
+		}
+	}
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+						btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_VHT);
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+						btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_VHT);
+
+}
+
+
+
+void halbtc8821a1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = TRUE;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	/* low pelnaty ra in pcr ra */
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+
+boolean halbtc8821a1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = FALSE, pre_under_4way = FALSE,
+			pre_bt_hs_on = FALSE;
+	boolean wifi_busy = FALSE, under_4way = FALSE, bt_hs_on = FALSE;
+	boolean wifi_connected = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return TRUE;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return TRUE;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+void halbtc8821a1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean		bt_active = TRUE, bt_disabled = FALSE, wifi_under_5g = FALSE;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = FALSE;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = FALSE;
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = FALSE;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = TRUE;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+
+		if (bt_disabled) {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS, NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+		}
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8821a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, FALSE);
+	else
+		halbtc8821a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, TRUE);
+}
+
+
+void halbtc8821a1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = FALSE, bt_busy = FALSE;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = FALSE;
+		coex_sta->pan_exist = FALSE;
+		coex_sta->a2dp_exist = FALSE;
+		coex_sta->hid_exist = FALSE;
+		coex_sta->sco_exist = FALSE;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = TRUE;
+		if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_FTP)
+			coex_sta->pan_exist = TRUE;
+		else
+			coex_sta->pan_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = TRUE;
+		else
+			coex_sta->a2dp_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_HID)
+			coex_sta->hid_exist = TRUE;
+		else
+			coex_sta->hid_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = TRUE;
+		else
+			coex_sta->sco_exist = FALSE;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = TRUE;
+		bt_link_info->bt_link_exist = TRUE;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = TRUE;
+	else
+		bt_link_info->sco_only = FALSE;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = TRUE;
+	else
+		bt_link_info->a2dp_only = FALSE;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = TRUE;
+	else
+		bt_link_info->pan_only = FALSE;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = TRUE;
+	else
+		bt_link_info->hid_only = FALSE;
+
+	/* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+	coex_sta->bt_info = coex_sta->bt_info & 0x1f;
+
+	if (!(coex_sta->bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (coex_sta->bt_info == BT_INFO_8821A_1ANT_B_CONNECTION) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((coex_sta->bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_ACL_BUSY) {
+		if (coex_dm->bt_status != BT_8821A_1ANT_BT_STATUS_ACL_BUSY)
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_ACL_BUSY) ||
+	    (coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_SCO_BUSY) ||
+	    (coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY))
+		bt_busy = TRUE;
+	else
+		bt_busy = FALSE;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8821a1ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+	IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl = 0;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+
+	if ((wifi_central_chnl <= 14) && (type == BTC_MEDIA_CONNECT)) {
+
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (wifi_bw == BTC_WIFI_BW_HT40)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+u8 halbtc8821a1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = FALSE;
+	u8				algorithm = BT_8821A_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+
+void halbtc8821a1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 19:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+					0xa5555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821a1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821a1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+		  IN u8 ant_pos_type, IN boolean force_exec,
+		  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			u32tmp = 0;
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(Before Ant Setup) pre_ant_pos_type = 0x%x, cur_ant_pos_type = 0x%x\n",
+		    coex_dm->pre_ant_pos_type,
+		    coex_dm->cur_ant_pos_type);
+	BTC_TRACE(trace_buf);
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+	switch (phase) {
+	case BT_8821A_1ANT_PHASE_COEX_INIT:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+	case BT_8821A_1ANT_PHASE_WLANONLY_INIT:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+		break;
+	case BT_8821A_1ANT_PHASE_2G_RUNTIME:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		/* 0x765 = 0x0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+		break;
+	case BT_8821A_1ANT_PHASE_5G_RUNTIME:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+	case BT_8821A_1ANT_PHASE_WLAN_OFF:
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL: BT Vendor 0xac*/
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	case BTC_ANT_PATH_BT:
+	case BTC_ANT_PATH_WIFI5G:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x66);
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	}
+}
+
+
+void halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE,8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE,8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821a1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = FALSE;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_ctrl = FALSE;
+		low_pwr_disable = FALSE;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_ctrl = TRUE;
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, TRUE);
+		halbtc8821a1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = TRUE;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_ctrl = TRUE;
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, FALSE);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821a1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else  {
+		halbtc8821a1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1a, 0x1a, 0x0, 0x50);
+			break;
+		case 1:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x3a, 0x03, 0x10, 0x50);
+			break;
+		case 2:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x2b, 0x03, 0x10, 0x50);
+			break;
+		case 3:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1d, 0x1d, 0x0, 0x52);
+			break;
+		case 4:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x10);
+			break;
+		case 6:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x13);
+			break;
+		case 7:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x21, 0x3, 0x10, 0x50);
+			break;
+		case 10:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x50);
+			break;
+		case 11:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x03, 0x10, 0x50);
+			break;
+		case 12:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x10, 0x7, 0x10, 0x54);
+			break;
+		case 14:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1e, 0x3, 0x10, 0x14);
+			break;
+		case 15:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x3, 0x11, 0x15);
+			break;
+		case 18:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x3, 0x11, 0x10);
+			break;
+		case 24:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 37:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x10, 0x3, 0x10, 0x54);
+			break;
+		case 38:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x3, 0x11, 0x54);
+			break;
+		case 40:
+			/* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		case 41:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 42:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 43:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x11);
+			break;
+		case 44:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x20, 0x3, 0x10, 0x14);
+			break;
+		case 45:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x25, 0x3, 0x10, 0x10);
+			break;
+		case 46:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x35, 0x3, 0x10, 0x10);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		case 9:   /* Software control, Antenna at WiFi side */
+		default:  /* Software control, Antenna at BT side */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 10:	/* under 5G */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821a1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+
+	/* hw all off */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+boolean halbtc8821a1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = FALSE, wifi_connected = FALSE, wifi_busy = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = TRUE;
+	} else if (wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = TRUE;
+	} else if (!wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = TRUE;
+	} else if (wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = TRUE;
+	} else if (!wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		common = TRUE;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = FALSE;
+	}
+
+	return common;
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+void halbtc8821a1ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     BT_8821A_1ANT_PHASE_2G_RUNTIME);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 8);
+}
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8821a1ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 45);
+}
+
+void halbtc8821a1ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 8);
+}
+
+void halbtc8821a1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = FALSE, wifi_busy = FALSE,
+				bt_busy = FALSE;
+	boolean	wifi_scan = FALSE, wifi_link = FALSE, wifi_roam = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+	if ((!wifi_connected) && (!wifi_scan)) {
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 8);
+	} else if (bt_link_info->pan_exist) {
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 22);
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 16);
+	} else {
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if ((wifi_link) || (wifi_roam) || (wifi_scan) || (wifi_busy)
+			|| (coex_sta->wifi_is_high_pri_task))
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 21);
+		else
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 23);
+	}
+}
+
+void halbtc8821a1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+#if 0
+	if (bt_link_info->sco_exist) {
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 32);
+	} else { /* HID */
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 32);
+	}
+#else
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 32);
+#endif
+}
+
+void halbtc8821a1ant_action_wifi_linkscan_process(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* for 8821a BT inq/page always hi-pri */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	/* tdma and coex table */
+	if (bt_link_info->a2dp_exist) {
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19); */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 38);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4); */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 32);
+	} else if (bt_link_info->pan_exist) {
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4); */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 20);
+	} else {
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2); */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 8);
+	}
+}
+
+
+void halbtc8821a1ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI5G, FORCE_EXEC,
+				     BT_8821A_1ANT_PHASE_5G_RUNTIME);
+
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 10);
+}
+
+void halbtc8821a1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 10);
+}
+
+void halbtc8821a1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (!bt_link_info->pan_exist)
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 8);
+}
+
+
+void halbtc8821a1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_busy = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist);
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 37);
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19);
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 37);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP) */
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19);
+
+		if (!wifi_busy)
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 9);
+		else
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 10);
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 13);
+	} else {
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 19);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 9);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, FALSE, 8);
+}
+
+
+void halbtc8821a1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_busy = FALSE;
+	boolean	wifi_under_5g = FALSE;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	/* tdma and coex table */
+	if ((coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_ACL_BUSY) ||
+		(coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY)) {
+
+		if (bt_link_info->hid_only)  /* HID only */
+			halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected_bt_acl_busy(btcoexist);
+
+	} else if (coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_SCO_BUSY)
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist);
+	else
+		halbtc8821a1ant_action_bt_idle(btcoexist);
+
+}
+
+void halbtc8821a1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8	algorithm = 0;
+
+	algorithm = halbtc8821a1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8821a1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821A_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8821a1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = FALSE, bt_hs_on = FALSE;
+	boolean	increase_scan_dev_num = FALSE;
+	boolean	bt_ctrl_agg_buf_size = FALSE;
+	u8	agg_buf_size = 5, wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32	wifi_link_status = 0, num_of_wifi_link = 0, wifi_bw;
+	boolean	miracast_plus_bt = FALSE, wifi_under_5g = FALSE;
+	boolean	scan = FALSE, link = FALSE, roam = FALSE, under_4way = FALSE;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS, &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if ((wifi_under_5g) &&
+		(coex_sta->switch_band_notify_to != BTC_SWITCH_TO_24G) &&
+		(coex_sta->switch_band_notify_to != BTC_SWITCH_TO_24G_NOFORSCAN)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+		return;
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 2G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC,
+					     BT_8821A_1ANT_PHASE_2G_RUNTIME);
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is disabled !!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_wifi_only(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	if ((BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = TRUE;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			if (bt_link_info->bt_link_exist)
+				miracast_plus_bt = TRUE;
+			else
+			miracast_plus_bt = FALSE;
+
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821a1ant_action_wifi_linkscan_process(btcoexist);
+		} else
+			halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (iot_peer == BTC_IOT_PEER_CISCO) {
+
+			if (wifi_bw == BTC_WIFI_BW_HT40)
+				halbtc8821a1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, FALSE, TRUE, 0x10);
+			else
+				halbtc8821a1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, FALSE, TRUE, 0x8);
+		}
+	}
+
+	halbtc8821a1ant_run_sw_coexist_mechanism(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt is inquiry!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+	} else if (bt_hs_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt is hs on!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_bt_hs(btcoexist);
+	} else if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+			    scan, link, roam, under_4way);
+		BTC_TRACE(trace_buf);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under linkscan process!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_connected(btcoexist);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under not-connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+	}
+}
+
+void halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, FALSE);
+
+	coex_sta->switch_band_notify_to = BTC_NOT_SWITCH;
+
+}
+
+void halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+	boolean			wifi_under_5g = FALSE;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+		/* Enable counter statistics */
+	/* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* PTA parameter */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, FALSE, 8);
+
+	if (coex_sta->is_rf_state_off) {
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC,
+					     BT_8821A_1ANT_PHASE_WLAN_OFF);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  halbtc8821a1ant_init_hw_config (RF Off)**********\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = TRUE;
+	} else if (wifi_only) {
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8821A_1ANT_PHASE_WLANONLY_INIT);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  halbtc8821a1ant_init_hw_config (wifi_only)**********\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = TRUE;
+	} else {
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC,
+					     BT_8821A_1ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = FALSE;
+	}
+
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a1ant_
+ * ************************************************************ */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_board_info	*board_info = &btcoexist->board_info;
+	u8			h2c_parameter[2] = {0};
+
+	coex_sta->is_rf_state_off = FALSE;
+
+	if (board_info->single_ant_path == 0)
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+	else if (board_info->single_ant_path == 1)
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+
+	if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], BTC_ANTENNA_AT_MAIN_PORT\n");
+		BTC_TRACE(trace_buf);
+		/* tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix */
+		h2c_parameter[0] = 1;
+		h2c_parameter[1] = 1;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], BTC_ANTENNA_AT_AUX_PORT\n");
+		BTC_TRACE(trace_buf);
+		/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+		h2c_parameter[0] = 0;
+		h2c_parameter[1] = 1;
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x65, 2, h2c_parameter);
+}
+
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a1ant_init_hw_config(btcoexist, wifi_only);
+}
+
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = FALSE;
+
+	halbtc8821a1ant_init_coex_dm(btcoexist);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "Ant PG Num/ Ant Mech/ Ant Pos:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num,
+		   board_info->btdm_ant_pos);
+	CL_PRINTF(cli_buf);
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) &&
+	     (!coex_sta->bt_disabled)) {
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+					&coex_sta->bt_coex_supported_version);
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+					&bt_patch_ver);
+
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+	}
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821a_1ant, glcoex_ver_8821a_1ant,
+		   glcoex_ver_btdesired_8821a_1ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8821a_1ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanisms]============");
+
+	CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		"\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s)",
+		   "PS TDMA",
+			coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			coex_dm->ps_tdma_para[4], ps_tdma_case,
+			(coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+	   "Coex Table Type",
+	   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+		   "IgnWlanAct",
+		   coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+		   "LowPenaltyRA/BtCtrlLPS",
+		   coex_dm->cur_low_penalty_ra,
+		   ((coex_sta->force_lps_ctrl) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+	   "Null All/Retry/Ack/BT_Empty/BT_Late",
+	   coex_sta->wl_fw_dbg_info[1],
+	   coex_sta->wl_fw_dbg_info[2],
+	   coex_sta->wl_fw_dbg_info[3],
+	   coex_sta->wl_fw_dbg_info[4],
+	   coex_sta->wl_fw_dbg_info[5]);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc58);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/ 0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8db[6:5]",
+		   ((u8tmp[0] & 0x60) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x975);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb4[29:28]/0xcb4[7:0]/0x974[9:8]",
+		   (u32tmp[0] & 0x30000000) >> 28, u32tmp[0] & 0xff,
+		   u8tmp[0] & 0x3);
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/0x4c[24:23]/0x64[0]",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u8tmp[1] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0] & 0xff);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d (Rx_rate Data/RTS= %d/%d)",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht,
+		   coex_sta->wl_rx_rate, coex_sta->wl_rts_rx_rate);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	boolean	wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = TRUE;
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC,
+					     BT_8821A_1ANT_PHASE_WLAN_OFF);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = FALSE;
+
+		halbtc8821a1ant_init_hw_config(btcoexist, FALSE);
+		halbtc8821a1ant_init_coex_dm(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	static boolean		pre_force_lps_on = FALSE;
+
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (type == BTC_LPS_ENABLE) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = TRUE;
+
+		if (coex_sta->force_lps_ctrl == TRUE) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			pre_force_lps_on = TRUE;
+		} else {
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			pre_force_lps_on = FALSE;
+		}
+	} else if (type == BTC_LPS_DISABLE) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = FALSE;
+
+		if ((!pre_force_lps_on) && (!coex_sta->force_lps_ctrl))
+			halbtc8821a1ant_query_bt_info(btcoexist);
+	}
+}
+
+
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = FALSE;
+	boolean wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	coex_sta->freeze_coexrun_by_btinfo = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	if (wifi_connected)
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** WL connected before SCAN\n");
+	else
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  WL is not connected before SCAN\n");
+
+	BTC_TRACE(trace_buf);
+
+	if ((type == BTC_SCAN_START) || (type == BTC_SCAN_START_2G))
+		halbtc8821a1ant_query_bt_info(btcoexist);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((type == BTC_SCAN_START) && (wifi_under_5g)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], SCAN START notify (5G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+	} else if ((type == BTC_SCAN_START_2G) || (type == BTC_SCAN_START)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], SCAN START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = TRUE;
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+						 FORCE_EXEC,
+						 BT_8821A_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+	} else {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+				coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = FALSE;
+
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+
+/* copy scan notify content to switch band notify */
+void ex_halbtc8821a1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	coex_sta->switch_band_notify_to = type;
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], switchband_notify ---  switch to 5G\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], switchband_notify --- BTC_SWITCH_TO_2G (no for scan)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], switchband_notify ---  switch to 2G\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8821a1ant_scan_notify(btcoexist,
+						   BTC_SCAN_START_2G);
+	}
+
+	coex_sta->switch_band_notify_to = BTC_NOT_SWITCH;
+}
+
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if ((wifi_under_5g) ||
+		(type == BTC_ASSOCIATE_5G_START) ||
+		(type == BTC_ASSOCIATE_5G_FINISH)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+	} else if (type == BTC_ASSOCIATE_START) {
+		coex_sta->wifi_is_high_pri_task = TRUE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+		coex_sta->freeze_coexrun_by_btinfo = TRUE;
+	} else {
+		coex_sta->wifi_is_high_pri_task = FALSE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+		coex_sta->freeze_coexrun_by_btinfo = FALSE;
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean		wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	if (type == BTC_MEDIA_CONNECT) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	}
+
+	halbtc8821a1ant_update_wifi_channel_info(btcoexist, type);
+}
+
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	under_4way = FALSE, wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS, &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = TRUE;
+		coex_sta->specific_pkt_period_cnt = 2;
+	} else if (type == BTC_PACKET_ARP) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = TRUE;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task)
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = FALSE;
+	boolean				bt_busy = FALSE;
+	boolean				wifi_under_5g = FALSE;
+
+
+	coex_sta->c2h_bt_info_req_sent = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			coex_sta->bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+	/* if 0xff, it means BT is under WHCK test */
+	if (coex_sta->bt_info == 0xff)
+		coex_sta->bt_whck_test = TRUE;
+	else
+		coex_sta->bt_whck_test = FALSE;
+
+	if (BT_INFO_SRC_8821A_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = TRUE;
+		else
+			coex_sta->c2h_bt_page = FALSE;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x8) ? TRUE : FALSE);
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			/*
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15); */
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821a1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, FALSE);
+			}
+		}
+	}
+
+		/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (coex_sta->bt_info & BT_INFO_8821A_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = TRUE;
+	else
+		coex_sta->c2h_bt_inquiry_page = FALSE;
+
+	halbtc8821a1ant_update_bt_link_info(btcoexist);
+
+	halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a1ant_wl_fwdbginfo_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8 i = 0;
+	static u8 tmp_buf_pre[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], WiFi Fw Dbg info = %d %d %d %d %d %d (len = %d)\n",
+			    tmp_buf[0], tmp_buf[1],
+				tmp_buf[2], tmp_buf[3],
+				tmp_buf[4], tmp_buf[5], length);
+	BTC_TRACE(trace_buf);
+
+	if (tmp_buf[0] == 0x8) {
+		for (i = 1; i <= 5; i++) {
+			coex_sta->wl_fw_dbg_info[i] =
+				(tmp_buf[i] >= tmp_buf_pre[i]) ?
+				(tmp_buf[i] - tmp_buf_pre[i]) :
+				(255 - tmp_buf_pre[i] + tmp_buf[i]);
+
+			tmp_buf_pre[i] = tmp_buf[i];
+		}
+	}
+}
+
+void ex_halbtc8821a1ant_rx_rate_change_notify(IN struct btc_coexist *btcoexist,
+		IN BOOLEAN is_data_frame, IN u8 btc_rate_id)
+{
+	BOOLEAN wifi_connected = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (is_data_frame) {
+		coex_sta->wl_rx_rate = btc_rate_id;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], rx_rate_change_notify data rate id = %d, RTS_Rate = %d\n",
+			coex_sta->wl_rx_rate, coex_sta->wl_rts_rx_rate);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wl_rts_rx_rate = btc_rate_id;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], rts_rate_change_notify RTS rate id = %d, RTS_Rate = %d\n",
+			coex_sta->wl_rts_rx_rate, coex_sta->wl_rts_rx_rate);
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((wifi_connected) &&
+		((coex_dm->bt_status ==  BT_8821A_1ANT_BT_STATUS_ACL_BUSY) ||
+		(coex_dm->bt_status ==  BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		(coex_dm->bt_status == BT_8821A_1ANT_BT_STATUS_SCO_BUSY))) {
+
+		if ((coex_sta->wl_rx_rate == BTC_CCK_5_5) ||
+			(coex_sta->wl_rx_rate == BTC_OFDM_6) ||
+			(coex_sta->wl_rx_rate == BTC_MCS_0)) {
+
+			coex_sta->cck_lock_warn = TRUE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck lock warning...\n");
+			BTC_TRACE(trace_buf);
+		} else if ((coex_sta->wl_rx_rate == BTC_CCK_1) ||
+			(coex_sta->wl_rx_rate == BTC_CCK_2) ||
+			(coex_sta->wl_rts_rx_rate == BTC_CCK_1) ||
+			(coex_sta->wl_rts_rx_rate == BTC_CCK_2)) {
+
+			coex_sta->cck_lock = TRUE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck locking...\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			coex_sta->cck_lock_warn = FALSE;
+			coex_sta->cck_lock = FALSE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck unlock...\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		if ((coex_dm->bt_status ==
+			BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE) ||
+			(coex_dm->bt_status ==
+			BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE)) {
+			coex_sta->cck_lock_warn = FALSE;
+			coex_sta->cck_lock = FALSE;
+		}
+	}
+
+}
+
+
+void ex_halbtc8821a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (type == BTC_RF_ON) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->is_rf_state_off = FALSE;
+
+	} else if (type == BTC_RF_OFF) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+						 FORCE_EXEC,
+						 BT_8821A_1ANT_PHASE_WLAN_OFF);
+		halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, FALSE, 8);
+
+		coex_sta->is_rf_state_off = TRUE;
+	}
+}
+
+
+
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     BT_8821A_1ANT_PHASE_WLAN_OFF);
+
+	halbtc8821a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, TRUE);
+
+	ex_halbtc8821a1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, FALSE, 0);
+
+	btcoexist->stop_coex_dm = TRUE;
+}
+
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = FALSE;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((pnp_state == BTC_WIFI_PNP_SLEEP) ||
+		(pnp_state == BTC_WIFI_PNP_SLEEP_KEEP_ANT)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		if (pnp_state == BTC_WIFI_PNP_SLEEP_KEEP_ANT) {
+
+			if (wifi_under_5g)
+				halbtc8821a1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_WIFI5G, FORCE_EXEC,
+						BT_8821A_1ANT_PHASE_5G_RUNTIME);
+			else
+				halbtc8821a1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_PTA, FORCE_EXEC,
+						BT_8821A_1ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8821a1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_BT, FORCE_EXEC,
+						BT_8821A_1ANT_PHASE_WLAN_OFF);
+		}
+
+		btcoexist->stop_coex_dm = TRUE;
+	} else if (pnp_state == BTC_WIFI_PNP_WAKE_UP) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = FALSE;
+	}
+}
+
+
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 0)
+	halbtc8821a1ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8821a1ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a1ant_monitor_wifi_ctr(btcoexist);
+	halbtc8821a1ant_monitor_bt_enable_disable(btcoexist);
+
+	if (halbtc8821a1ant_is_wifi_status_changed(btcoexist))
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
diff -Naur /hal/btc/halbtc8821a1ant.h /hal/btc/halbtc8821a1ant.h
--- /hal/btc/halbtc8821a1ant.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/halbtc8821a1ant.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,271 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_1ANT				1
+
+#define	BT_INFO_8821A_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8821A_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT		2
+
+enum bt_info_src_8821a_1ant {
+	BT_INFO_SRC_8821A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_1ANT_BT_RSP			= 0x1,
+	BT_INFO_SRC_8821A_1ANT_BT_ACTIVE_SEND	= 0x2,
+	BT_INFO_SRC_8821A_1ANT_MAX
+};
+
+enum bt_8821a_1ant_bt_status {
+	BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_1ANT_BT_STATUS_INQ_PAGE			= 0x2,
+	BT_8821A_1ANT_BT_STATUS_ACL_BUSY			= 0x3,
+	BT_8821A_1ANT_BT_STATUS_SCO_BUSY			= 0x4,
+	BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY		= 0x5,
+	BT_8821A_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_1ant_wifi_status {
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT			= 0x3,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8821A_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8821a_1ant_coex_algo {
+	BT_8821A_1ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8821A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_1ANT_COEX_ALGO_A2DP			= 0x3,
+	BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP		= 0xa,
+	BT_8821A_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8821a_1ant_phase {
+	BT_8821A_1ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8821A_1ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8821A_1ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8821A_1ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8821A_1ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8821A_1ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8821A_1ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8821A_1ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8821A_1ANT_PHASE_MAX
+};
+
+
+struct coex_dm_8821a_1ant {
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8821a_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	u32					bt_coex_supported_version;
+	u8					cut_version;
+	u8					bt_rssi;
+	u8					scan_ap_num;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_1ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	boolean				bt_whck_test;	/* Add for ASUS WHQL TEST that enable wifi test bt */
+
+	u8					hid_busy_num;
+	u8					bt_info_ext2;
+
+	boolean				is_rf_state_off;
+	u8					switch_band_notify_to;
+	boolean				freeze_coexrun_by_btinfo;
+	boolean				force_lps_ctrl;
+	u8                  bt_info;
+	u8					wl_fw_dbg_info[10];
+	u8					coex_table_type;
+	boolean				acl_busy;
+
+	boolean				cck_lock;
+	boolean				cck_lock_ever;
+	boolean				cck_lock_warn;
+
+	u8					wl_rx_rate;
+	u8					wl_rts_rx_rate;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a1ant_wl_fwdbginfo_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a1ant_rx_rate_change_notify(IN struct btc_coexist *btcoexist,
+		IN BOOLEAN is_data_frame, IN u8 btc_rate_id);
+void ex_halbtc8821a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a1ant_wl_fwdbginfo_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a1ant_rx_rate_change_notify(btcoexist, is_data_frame, btc_rate_id)
+#define   ex_halbtc8821a1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a1ant_periodical(btcoexist)
+#define	ex_halbtc8821a1ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
+
diff -Naur /hal/btc/halbtc8821a2ant.c /hal/btc/halbtc8821a2ant.c
--- /hal/btc/halbtc8821a2ant.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/halbtc8821a2ant.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,3064 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+ /* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821A Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_2ant		glcoex_dm_8821a_2ant;
+static struct  coex_dm_8821a_2ant	*coex_dm = &glcoex_dm_8821a_2ant;
+static struct  coex_sta_8821a_2ant		glcoex_sta_8821a_2ant;
+static struct  coex_sta_8821a_2ant	*coex_sta = &glcoex_sta_8821a_2ant;
+
+const char *const glbt_info_src_8821a_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_2ant = 20190509;
+u32	glcoex_ver_8821a_2ant = 0x6f;
+u32	glcoex_ver_btdesired_8821a_2ant = 0x5c;
+
+/* modify 20140903v43 a2dpandhid tdmaonoff a2dp glitch _ tdma off 778=3(case1)->778=1(case0)
+ * and to improve tp while a2dphid case23->case25 , case123->case125 for asus spec
+ * and modify for asus bt WHQL test _ tdma off_ 778=3->1_
+ * ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a2ant_
+ * ************************************************************ */
+u8 halbtc8821a2ant_bt_rssi_state(IN struct btc_coexist *btcoexist,
+	u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+
+void halbtc8821a2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8821a2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_rx >= 950)  &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx) &&
+	    (!coex_sta->under_ips))
+		bt_link_info->slave_role = TRUE;
+	else
+		bt_link_info->slave_role = FALSE;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	u8	h2c_parameter[1] = {0};
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* Only enable for windows becaus 8821cu H2C 0x69 unknown fail @ linux */
+	if (btcoexist->chip_interface != BTC_INTF_USB) {
+		/*send h2c to query WL FW dbg info  */
+		if (((coex_dm->cur_ps_tdma_on) && (coex_sta->force_lps_ctrl)) ||
+			 ((coex_sta->acl_busy) && (bt_link_info->a2dp_exist))) {
+			h2c_parameter[0] = 0x8;
+			btcoexist->btc_fill_h2c(btcoexist, 0x69, 1, h2c_parameter);
+		}
+	}
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+						btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_OK_VHT);
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+						btcoexist->btc_phydm_query_PHY_counter(
+						btcoexist,
+						PHYDM_INFO_CRC32_ERROR_VHT);
+
+}
+
+void halbtc8821a2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = TRUE;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	/* low pelnaty ra in pcr ra */
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+
+boolean halbtc8821a2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = FALSE, pre_under_4way = FALSE,
+			pre_bt_hs_on = FALSE;
+	boolean			wifi_busy = FALSE, under_4way = FALSE, bt_hs_on = FALSE;
+	boolean			wifi_connected = FALSE;
+	u8			wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return TRUE;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return TRUE;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return TRUE;
+		}
+
+
+		wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 3,
+			  2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return TRUE;
+
+	}
+
+	return FALSE;
+}
+
+void halbtc8821a2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32			bt_disable_cnt = 0;
+	boolean			bt_active = TRUE, bt_disabled = FALSE, wifi_under_5g = FALSE;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = FALSE;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = FALSE;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = FALSE;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = TRUE;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		/* if (!bt_disabled) {} else {} */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8821a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, FALSE);
+	else
+		halbtc8821a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, TRUE);
+
+}
+
+void halbtc8821a2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean		bt_hs_on = FALSE;
+	boolean		bt_busy = FALSE;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = FALSE;
+		coex_sta->pan_exist = FALSE;
+		coex_sta->a2dp_exist = FALSE;
+		coex_sta->hid_exist = FALSE;
+		coex_sta->sco_exist = FALSE;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = TRUE;
+		if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_FTP)
+			coex_sta->pan_exist = TRUE;
+		else
+			coex_sta->pan_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = TRUE;
+		else
+			coex_sta->a2dp_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_HID)
+			coex_sta->hid_exist = TRUE;
+		else
+			coex_sta->hid_exist = FALSE;
+		if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = TRUE;
+		else
+			coex_sta->sco_exist = FALSE;
+/*
+// 20170810 disbale HID workaround SJ
+		if ((coex_sta->hid_exist == FALSE) &&
+			(coex_sta->c2h_bt_inquiry_page == FALSE) &&
+			(coex_sta->sco_exist == FALSE)) {
+			if (coex_sta->high_priority_tx	+
+				coex_sta->high_priority_rx >= 160)
+				coex_sta->hid_exist = TRUE;
+		}
+*/
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = TRUE;
+		bt_link_info->bt_link_exist = TRUE;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = TRUE;
+	else
+		bt_link_info->sco_only = FALSE;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = TRUE;
+	else
+		bt_link_info->a2dp_only = FALSE;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = TRUE;
+	else
+		bt_link_info->pan_only = FALSE;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = TRUE;
+	else
+		bt_link_info->hid_only = FALSE;
+
+	if (!(coex_sta->bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (coex_sta->bt_info == BT_INFO_8821A_2ANT_B_CONNECTION) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((coex_sta->bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((coex_dm->bt_status == BT_8821A_2ANT_BT_STATUS_ACL_BUSY) ||
+	    (coex_dm->bt_status == BT_8821A_2ANT_BT_STATUS_SCO_BUSY) ||
+	    (coex_dm->bt_status == BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY))
+		bt_busy = TRUE;
+	else
+		bt_busy = FALSE;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8821a2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8821a2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+
+void halbtc8821a2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+#if 0
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+#endif
+}
+
+void halbtc8821a2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8821a2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8821a2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 16:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 17:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xfafafafa, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	case 18:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5555555f, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 19:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 20:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 21:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xaaffffaa, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 22:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xffff55ff, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	case 23:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+
+	halbtc8821a2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+
+void halbtc8821a2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x0, 0, 0, 48, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+		}
+	}
+}
+
+void halbtc8821a2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = FALSE;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		coex_sta->force_lps_ctrl = FALSE;
+		/* recover to original 32k low power setting */
+		low_pwr_disable = FALSE;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = FALSE;
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_ctrl = TRUE;
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, TRUE);
+		halbtc8821a2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = TRUE;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/*power save must executed before psTdma*/
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = TRUE;
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_ctrl = TRUE;
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, FALSE);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = FALSE;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8821a2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = FALSE;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821a2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+		halbtc8821a2ant_power_save_state(btcoexist,
+				BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else {
+			halbtc8821a2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 2:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 3:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 4:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1, 0x90);
+			break;
+		case 5:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 6:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 7:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 8:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 9:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 10:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 11:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 12:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1, 0x90);
+			break;
+		case 13:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 14:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 15:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 16:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 17:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 22:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0x71, 0x10);
+			break;
+		case 23:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0xf1, 0x94);
+			break;
+		case 24:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x03, 0x71, 0x11);
+			break;
+		case 25:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x14, 0x03, 0xf1, 0x90);
+			break;
+		case 26:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x30, 0x03, 0x70, 0x50);
+			break;
+		case 27:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x23, 0x03, 0x70, 0x50);
+			break;
+		case 28:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0xf1, 0x94);
+			break;
+		case 29:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x08, 0x03, 0x70, 0x54);
+			break;
+		case 30:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x08, 0x07, 0x70, 0x54);
+			break;
+		case 36:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x21, 0x03, 0x70, 0x50);
+			break;
+		case 40:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x71, 0x54);
+			break;
+		case 71:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+		default:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821a2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+		  IN u8 ant_pos_type, IN boolean force_exec,
+		  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			u32tmp = 0;
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(Before Ant Setup) pre_ant_pos_type = 0x%x, cur_ant_pos_type = 0x%x\n",
+		    coex_dm->pre_ant_pos_type,
+		    coex_dm->cur_ant_pos_type);
+	BTC_TRACE(trace_buf);
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+	switch (phase) {
+	case BT_8821A_2ANT_PHASE_COEX_INIT:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+	case BT_8821A_2ANT_PHASE_WLANONLY_INIT:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+		break;
+	case BT_8821A_2ANT_PHASE_2G_RUNTIME:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		/* 0x765 = 0x0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+		break;
+	case BT_8821A_2ANT_PHASE_5G_RUNTIME:
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+	case BT_8821A_2ANT_PHASE_WLAN_OFF:
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL: BT Vendor 0xac*/
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+		break;
+
+	}
+
+	/* ext switch setting */
+	btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_MAIN:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x1);
+		break;
+	case BTC_ANT_WIFI_AT_AUX:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x2);
+		break;
+	}
+}
+
+u8 halbtc8821a2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = FALSE;
+	u8				algorithm = BT_8821A_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+
+void halbtc8821a2ant_action_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+void halbtc8821a2ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+
+void halbtc8821a2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean	wifi_connected = FALSE;
+	boolean	low_pwr_disable = TRUE;
+	boolean		scan = FALSE, link = FALSE, roam = FALSE;
+
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+					0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+					1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+					2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 22);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 22);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+	}
+
+
+}
+
+void halbtc8821a2ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821a2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for SCO quality at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else { /* for SCO quality & wifi performance balance at 11n mode */
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		else {
+			if (bt_link_info->sco_only)
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 17);
+			else
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 12);
+		}
+	}
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 0); /* for voice quality */
+
+
+}
+
+
+void halbtc8821a2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+					0, 2, 15, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+					2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+#if 0
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 22);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 22);
+#else
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 22);
+#endif
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 24);
+
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821a2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 20);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 29);
+
+}
+
+void halbtc8821a2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 20);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 29);
+}
+
+void halbtc8821a2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	boolean wifi_busy = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 21);
+
+	if (wifi_busy)
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 26);
+	else
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 36);
+
+}
+
+
+/* PAN(HS) only */
+void halbtc8821a2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821a2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 20);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 30);
+}
+
+void halbtc8821a2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean wifi_busy = FALSE;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 21);
+
+	if (wifi_busy)
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 26);
+	else
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 36);
+
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821a2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1,  bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				2, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	
+	//20171103SJ modified for WiFi_TX_THR drop
+	//halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 20);
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 23);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 30);
+
+}
+
+void halbtc8821a2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				0, 2, 15, 0);
+
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist,
+				1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(btcoexist,
+				3, BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 37);
+
+	//20171103SJ modified for WiFi_TX_THR drop
+	//halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 20);
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 23);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 29);
+
+}
+
+void halbtc8821a2ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, NORMAL_EXEC,
+				     BT_8821A_2ANT_PHASE_5G_RUNTIME);
+	/* fw all off */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 0);
+}
+
+
+void halbtc8821a2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (!bt_link_info->pan_exist)
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	else
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 17);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+void halbtc8821a2ant_action_wifi_linkscan_process(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (bt_link_info->a2dp_exist) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 22);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 40);
+	} else {
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 22);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, TRUE, 22);
+	}
+}
+
+void halbtc8821a2ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, FALSE, 0);
+}
+
+void halbtc8821a2ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	switch (coex_dm->cur_algorithm) {
+	case BT_8821A_2ANT_COEX_ALGO_SCO:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_sco(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_hid(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_a2dp(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_a2dp_pan_hs(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_pan_edr(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_PANHS:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_pan_hs(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_pan_edr_a2dp(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_PANEDR_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_pan_edr_hid(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_hid_a2dp_pan_edr(btcoexist);
+		break;
+	case BT_8821A_2ANT_COEX_ALGO_HID_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_hid_a2dp(btcoexist);
+		break;
+	default:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_coex_all_off(btcoexist);
+		break;
+	}
+
+	coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+}
+
+
+void halbtc8821a2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean			wifi_under_5g = FALSE;
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			miracast_plus_bt = FALSE;
+	boolean			scan = FALSE, link = FALSE, roam = FALSE,
+					under_4way = FALSE, wifi_connected = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if ((wifi_under_5g) &&
+		(coex_sta->switch_band_notify_to != BTC_SWITCH_TO_24G) &&
+		(coex_sta->switch_band_notify_to != BTC_SWITCH_TO_24G_NOFORSCAN)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_under5g(btcoexist);
+		return;
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 2G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     NORMAL_EXEC,
+					     BT_8821A_2ANT_PHASE_2G_RUNTIME);
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = TRUE;
+		else
+			miracast_plus_bt = FALSE;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821a2ant_action_wifi_linkscan_process(btcoexist);
+		} else
+			halbtc8821a2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	if ((BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	     coex_dm->bt_status) ||
+	    (BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+	     coex_dm->bt_status)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, bt idle!!.\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8821a2ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, wifi connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_connected(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, wifi not-connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_not_connected(btcoexist);
+	}
+}
+
+void halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, FALSE);
+
+	coex_sta->switch_band_notify_to = BTC_NOT_SWITCH;
+}
+
+void halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Enable counter statistics */
+	/* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+
+	/* PTA parameter */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8821a2ant_ps_tdma(btcoexist, FORCE_EXEC, FALSE, 0);
+
+	if (coex_sta->is_rf_state_off) {
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     FORCE_EXEC,
+					     BT_8821A_2ANT_PHASE_WLAN_OFF);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  halbtc8821a2ant_init_hw_config (RF Off)**********\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = TRUE;
+	} else if (wifi_only) {
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     FORCE_EXEC,
+					     BT_8821A_2ANT_PHASE_WLANONLY_INIT);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  halbtc8821a2ant_init_hw_config (wifi_only)**********\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = TRUE;
+	} else {
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     FORCE_EXEC,
+					     BT_8821A_2ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = FALSE;
+	}
+
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a2ant_
+ * ************************************************************ */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_board_info	*board_info = &btcoexist->board_info;
+	u8			h2c_parameter[2] = {0};
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	coex_sta->is_rf_state_off = FALSE;
+
+	if (board_info->single_ant_path == 0)
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+	else if (board_info->single_ant_path == 1)
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+
+	if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], BTC_ANTENNA_AT_MAIN_PORT\n");
+		BTC_TRACE(trace_buf);
+		/* tell firmware "antenna inverse"	==> WRONG firmware antenna control code.==>need fw to fix */
+		h2c_parameter[0] = 1;
+		h2c_parameter[1] = 1;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], BTC_ANTENNA_AT_AUX_PORT\n");
+		BTC_TRACE(trace_buf);
+		/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+		h2c_parameter[0] = 0;
+		h2c_parameter[1] = 1;
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x65, 2, h2c_parameter);
+}
+
+
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a2ant_init_hw_config(btcoexist, wifi_only);
+}
+
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	u32				phyver = 0;
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) &&
+	     (!coex_sta->bt_disabled)) {
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+					&coex_sta->bt_coex_supported_version);
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+					&bt_patch_ver);
+
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+	}
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	bt_coex_ver = (coex_sta->bt_coex_supported_version & 0xff);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821a_2ant, glcoex_ver_8821a_2ant,
+		   glcoex_ver_btdesired_8821a_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8821a_2ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %ddBm/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanisms]============");
+
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		"\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s)",
+		   "PS TDMA",
+			coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			coex_dm->ps_tdma_para[4], ps_tdma_case,
+			(coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+			   "LowPenaltyRA/BtCtrlLPS",
+			   coex_dm->cur_low_penalty_ra,
+			   ((coex_sta->force_lps_ctrl) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "Null All/Retry/Ack/BT_Empty/BT_Late",
+		   coex_sta->wl_fw_dbg_info[1],
+		   coex_sta->wl_fw_dbg_info[2],
+		   coex_sta->wl_fw_dbg_info[3],
+		   coex_sta->wl_fw_dbg_info[4],
+		   coex_sta->wl_fw_dbg_info[5]);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x880[29:25]/0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25,
+		   ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x764);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x764/ 0x765/ 0x76e",
+		   (u32tmp[0] & 0xff), (u32tmp[0] & 0xff00) >> 8, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb4[7:0](ctrl)/ 0xcb4[29:28](val)",
+		   u32tmp[0] & 0xff, ((u32tmp[0] & 0x30000000) >> 28));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d (Rx_rate Data/RTS= %d/%d)",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht,
+		   coex_sta->wl_rx_rate, coex_sta->wl_rts_rx_rate);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (type == BTC_IPS_ENTER) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = TRUE;
+		coex_sta->under_lps = FALSE;
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+						 FORCE_EXEC,
+						 BT_8821A_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8821a2ant_action_coex_all_off(btcoexist);
+	} else if (type == BTC_IPS_LEAVE) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = FALSE;
+
+		halbtc8821a2ant_init_hw_config(btcoexist, FALSE);
+		halbtc8821a2ant_init_coex_dm(btcoexist);
+		halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	static boolean		pre_force_lps_on = FALSE;
+
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (type == BTC_LPS_ENABLE) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = TRUE;
+
+		if (coex_sta->force_lps_ctrl == TRUE) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			pre_force_lps_on = TRUE;
+		} else {
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			pre_force_lps_on = FALSE;
+		}
+	} else if (type == BTC_LPS_DISABLE) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = FALSE;
+
+		if ((!pre_force_lps_on) && (!coex_sta->force_lps_ctrl))
+			halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = FALSE;
+	boolean wifi_under_5g = FALSE;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], SCAN notify()\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	/*	this can't be removed for RF off_on event, or BT would dis-connect */
+	if ((type == BTC_SCAN_START) || (type == BTC_SCAN_START_2G))
+		halbtc8821a2ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((type == BTC_SCAN_START) && (wifi_under_5g)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], SCAN START notify (5G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_action_wifi_under5g(btcoexist);
+	} else if ((type == BTC_SCAN_START_2G) || (type == BTC_SCAN_START)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], SCAN START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = TRUE;
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+						 FORCE_EXEC,
+						 BT_8821A_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+
+	} else if (type == BTC_SCAN_FINISH) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+				coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = FALSE;
+
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+
+/* copy scan notify content to switch band notify */
+void ex_halbtc8821a2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_connected = FALSE, bt_hs_on = FALSE;
+	u32 wifi_link_status = 0;
+	u32 num_of_wifi_link = 0;
+	boolean bt_ctrl_agg_buf_size = FALSE;
+	u8	agg_buf_size = 5;
+
+
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	coex_sta->switch_band_notify_to = type;
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], switchband_notify ---  switch to 5G\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_action_wifi_under5g(btcoexist);
+
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], switchband_notify --- BTC_SWITCH_TO_2G (no for scan)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], switchband_notify ---  switch to 2G\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8821a2ant_scan_notify(btcoexist, BTC_SCAN_START_2G);
+	}
+
+	coex_sta->switch_band_notify_to = BTC_NOT_SWITCH;
+}
+
+
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	if ((type == BTC_ASSOCIATE_5G_START) ||
+		(type == BTC_ASSOCIATE_5G_FINISH)) {
+
+		if (type == BTC_ASSOCIATE_5G_START)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], connect_notify ---  5G start\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], connect_notify ---  5G finish\n");
+
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_action_wifi_under5g(btcoexist);
+	} else if (type == BTC_ASSOCIATE_START) {
+
+		coex_sta->wifi_is_high_pri_task = TRUE;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], CONNECT START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+						 FORCE_EXEC,
+						 BT_8821A_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = TRUE;
+
+		coex_dm->arp_cnt = 0;
+
+	} else if (type == BTC_ASSOCIATE_FINISH) {
+
+		coex_sta->wifi_is_high_pri_task = FALSE;
+		coex_sta->freeze_coexrun_by_btinfo = FALSE;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], CONNECT FINISH notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((type == BTC_MEDIA_CONNECT) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (wifi_bw == BTC_WIFI_BW_HT40)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean under_4way = FALSE, wifi_under_5g = FALSE;
+
+	if (btcoexist->manual_control ||
+		btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = TRUE;
+		coex_sta->specific_pkt_period_cnt = 2;
+
+	} else if (type == BTC_PACKET_ARP) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet ARP notify -cnt = %d\n",
+				coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+				type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = TRUE;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task)
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+
+}
+
+
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = FALSE;
+	boolean			wifi_connected = FALSE, wifi_under_5g = FALSE;
+
+	coex_sta->c2h_bt_info_req_sent = FALSE;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			coex_sta->bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (coex_sta->bt_info == 0xff)
+		coex_sta->bt_whck_test = TRUE;
+	else
+		coex_sta->bt_whck_test = FALSE;
+
+	if (BT_INFO_SRC_8821A_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x8) ? TRUE : FALSE);
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n");
+			BTC_TRACE(trace_buf);
+			/*
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x01); */
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			if (wifi_connected)
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (!btcoexist->manual_control && !wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT ext info = 0x%x!!\n",
+				    coex_sta->bt_info_ext);
+			BTC_TRACE(trace_buf);
+			if ((coex_sta->bt_info_ext & BIT(3))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=1, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+				if (wifi_connected) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8821a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, FALSE);
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=0, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+			}
+		}
+
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (coex_sta->bt_info & BT_INFO_8821A_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = TRUE;
+	else
+		coex_sta->c2h_bt_inquiry_page = FALSE;
+
+	halbtc8821a2ant_update_bt_link_info(btcoexist);
+
+	halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a2ant_wl_fwdbginfo_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8 i = 0;
+	static u8 tmp_buf_pre[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], WiFi Fw Dbg info = %d %d %d %d %d %d (len = %d)\n",
+			    tmp_buf[0], tmp_buf[1],
+				tmp_buf[2], tmp_buf[3],
+				tmp_buf[4], tmp_buf[5], length);
+	BTC_TRACE(trace_buf);
+
+	if (tmp_buf[0] == 0x8) {
+		for (i = 1; i <= 5; i++) {
+			coex_sta->wl_fw_dbg_info[i] =
+				(tmp_buf[i] >= tmp_buf_pre[i]) ?
+				(tmp_buf[i] - tmp_buf_pre[i]) :
+				(255 - tmp_buf_pre[i] + tmp_buf[i]);
+
+			tmp_buf_pre[i] = tmp_buf[i];
+		}
+	}
+}
+
+void ex_halbtc8821a2ant_rx_rate_change_notify(IN struct btc_coexist *btcoexist,
+		IN BOOLEAN is_data_frame, IN u8 btc_rate_id)
+{
+	BOOLEAN wifi_connected = FALSE;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (is_data_frame) {
+		coex_sta->wl_rx_rate = btc_rate_id;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], rx_rate_change_notify data rate id = %d, RTS_Rate = %d\n",
+			coex_sta->wl_rx_rate, coex_sta->wl_rts_rx_rate);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wl_rts_rx_rate = btc_rate_id;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], rts_rate_change_notify RTS rate id = %d, RTS_Rate = %d\n",
+			coex_sta->wl_rts_rx_rate, coex_sta->wl_rts_rx_rate);
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((wifi_connected) &&
+		((coex_dm->bt_status ==  BT_8821A_2ANT_BT_STATUS_ACL_BUSY) ||
+		(coex_dm->bt_status ==  BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		(coex_dm->bt_status == BT_8821A_2ANT_BT_STATUS_SCO_BUSY))) {
+
+		if ((coex_sta->wl_rx_rate == BTC_CCK_5_5) ||
+			(coex_sta->wl_rx_rate == BTC_OFDM_6) ||
+			(coex_sta->wl_rx_rate == BTC_MCS_0)) {
+
+			coex_sta->cck_lock_warn = TRUE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck lock warning...\n");
+			BTC_TRACE(trace_buf);
+		} else if ((coex_sta->wl_rx_rate == BTC_CCK_1) ||
+			(coex_sta->wl_rx_rate == BTC_CCK_2) ||
+			(coex_sta->wl_rts_rx_rate == BTC_CCK_1) ||
+			(coex_sta->wl_rts_rx_rate == BTC_CCK_2)) {
+
+			coex_sta->cck_lock = TRUE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck locking...\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			coex_sta->cck_lock_warn = FALSE;
+			coex_sta->cck_lock = FALSE;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], cck unlock...\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		if ((coex_dm->bt_status ==
+			BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE) ||
+			(coex_dm->bt_status ==
+			BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE)) {
+			coex_sta->cck_lock_warn = FALSE;
+			coex_sta->cck_lock = FALSE;
+		}
+	}
+
+}
+
+void ex_halbtc8821a2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (type == BTC_RF_ON) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = FALSE;
+		coex_sta->is_rf_state_off = FALSE;
+
+	} else if (type == BTC_RF_OFF) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						 FORCE_EXEC,
+						 BT_8821A_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8821a2ant_action_coex_all_off(btcoexist);
+
+		btcoexist->stop_coex_dm = TRUE;
+		coex_sta->is_rf_state_off = TRUE;
+	}
+}
+
+
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					 BT_8821A_2ANT_PHASE_WLAN_OFF);
+
+	halbtc8821a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, TRUE);
+
+	ex_halbtc8821a2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+}
+
+
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = FALSE;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((pnp_state == BTC_WIFI_PNP_SLEEP) ||
+		(pnp_state == BTC_WIFI_PNP_SLEEP_KEEP_ANT)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->under_ips = FALSE;
+		coex_sta->under_lps = FALSE;
+
+		if (pnp_state == BTC_WIFI_PNP_SLEEP_KEEP_ANT) {
+
+			if (wifi_under_5g)
+				halbtc8821a2ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, FORCE_EXEC,
+						BT_8821A_2ANT_PHASE_5G_RUNTIME);
+			else
+				halbtc8821a2ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, FORCE_EXEC,
+						BT_8821A_2ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8821a2ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, FORCE_EXEC,
+						BT_8821A_2ANT_PHASE_WLAN_OFF);
+		}
+	} else if (pnp_state == BTC_WIFI_PNP_WAKE_UP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ========== Periodical ==========\n");
+	BTC_TRACE(trace_buf);
+
+
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 0)
+	halbtc8821a2ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8821a2ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8821a2ant_monitor_bt_enable_disable(btcoexist);
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = FALSE;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ***************** Hi-Pri Task = %s\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+	}
+
+	if (halbtc8821a2ant_is_wifi_status_changed(btcoexist))
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
diff -Naur /hal/btc/halbtc8821a2ant.h /hal/btc/halbtc8821a2ant.h
--- /hal/btc/halbtc8821a2ant.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/halbtc8821a2ant.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,264 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_2ANT				1
+
+
+#define	BT_INFO_8821A_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT		2
+
+
+#define	BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  /* WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+#define	BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES				46 /* BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+
+enum bt_info_src_8821a_2ant {
+	BT_INFO_SRC_8821A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_2ANT_BT_RSP			= 0x1,
+	BT_INFO_SRC_8821A_2ANT_BT_ACTIVE_SEND	= 0x2,
+	BT_INFO_SRC_8821A_2ANT_MAX
+};
+
+enum bt_8821a_2ant_bt_status {
+	BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_2ANT_BT_STATUS_INQ_PAGE			= 0x2,
+	BT_8821A_2ANT_BT_STATUS_ACL_BUSY			= 0x3,
+	BT_8821A_2ANT_BT_STATUS_SCO_BUSY			= 0x4,
+	BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY		= 0x5,
+	BT_8821A_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_2ant_coex_algo {
+	BT_8821A_2ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8821A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_2ANT_COEX_ALGO_A2DP			= 0x3,
+	BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP		= 0xa,
+	BT_8821A_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8821a_2ant_phase {
+	BT_8821A_2ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8821A_2ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8821A_2ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8821A_2ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8821A_2ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8821A_2ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8821A_2ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8821A_2ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8821A_2ANT_PHASE_MAX
+};
+
+
+struct coex_dm_8821a_2ant {
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+	u32		arp_cnt;
+};
+
+struct coex_sta_8821a_2ant {
+	boolean				bt_disabled;
+	boolean				bt_link_exist;
+	boolean				sco_exist;
+	boolean				a2dp_exist;
+	boolean				hid_exist;
+	boolean				pan_exist;
+
+	boolean				under_lps;
+	boolean				under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean				bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean				c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean				c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					scan_ap_num;
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	u32					bt_coex_supported_version;
+	u8					cut_version;
+	u8					coex_table_type;
+	boolean				force_lps_on;
+
+	boolean				is_rf_state_off;
+	u8					switch_band_notify_to;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				wifi_is_high_pri_task;
+	u32					specific_pkt_period_cnt;
+	boolean				force_lps_ctrl;
+	u8                  bt_info;
+	u8					wl_fw_dbg_info[10];
+	boolean				acl_busy;
+
+	boolean				cck_lock;
+	boolean				cck_lock_ever;
+	boolean				cck_lock_warn;
+
+	u8					wl_rx_rate;
+	u8					wl_rts_rx_rate;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a2ant_wl_fwdbginfo_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a2ant_rx_rate_change_notify(IN struct btc_coexist *btcoexist,
+		IN BOOLEAN is_data_frame, IN u8 btc_rate_id);
+void ex_halbtc8821a2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a2ant_wl_fwdbginfo_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a2ant_rx_rate_change_notify(btcoexist, is_data_frame, btc_rate_id)
+#define   ex_halbtc8821a2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a2ant_periodical(btcoexist)
+#define	ex_halbtc8821a2ant_display_coex_info(btcoexist)
+#endif
+
+#endif
+
diff -Naur /hal/btc/halbtcoutsrc.h /hal/btc/halbtcoutsrc.h
--- /hal/btc/halbtcoutsrc.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/halbtcoutsrc.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,2164 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef	__HALBTC_OUT_SRC_H__
+#define __HALBTC_OUT_SRC_H__
+
+enum {
+	BTC_CCK_1,
+	BTC_CCK_2,
+	BTC_CCK_5_5,
+	BTC_CCK_11,
+	BTC_OFDM_6,
+	BTC_OFDM_9,
+	BTC_OFDM_12,
+	BTC_OFDM_18,
+	BTC_OFDM_24,
+	BTC_OFDM_36,
+	BTC_OFDM_48,
+	BTC_OFDM_54,
+	BTC_MCS_0,
+	BTC_MCS_1,
+	BTC_MCS_2,
+	BTC_MCS_3,
+	BTC_MCS_4,
+	BTC_MCS_5,
+	BTC_MCS_6,
+	BTC_MCS_7,
+	BTC_MCS_8,
+	BTC_MCS_9,
+	BTC_MCS_10,
+	BTC_MCS_11,
+	BTC_MCS_12,
+	BTC_MCS_13,
+	BTC_MCS_14,
+	BTC_MCS_15,
+	BTC_MCS_16,
+	BTC_MCS_17,
+	BTC_MCS_18,
+	BTC_MCS_19,
+	BTC_MCS_20,
+	BTC_MCS_21,
+	BTC_MCS_22,
+	BTC_MCS_23,
+	BTC_MCS_24,
+	BTC_MCS_25,
+	BTC_MCS_26,
+	BTC_MCS_27,
+	BTC_MCS_28,
+	BTC_MCS_29,
+	BTC_MCS_30,
+	BTC_MCS_31,
+	BTC_VHT_1SS_MCS_0,
+	BTC_VHT_1SS_MCS_1,
+	BTC_VHT_1SS_MCS_2,
+	BTC_VHT_1SS_MCS_3,
+	BTC_VHT_1SS_MCS_4,
+	BTC_VHT_1SS_MCS_5,
+	BTC_VHT_1SS_MCS_6,
+	BTC_VHT_1SS_MCS_7,
+	BTC_VHT_1SS_MCS_8,
+	BTC_VHT_1SS_MCS_9,
+	BTC_VHT_2SS_MCS_0,
+	BTC_VHT_2SS_MCS_1,
+	BTC_VHT_2SS_MCS_2,
+	BTC_VHT_2SS_MCS_3,
+	BTC_VHT_2SS_MCS_4,
+	BTC_VHT_2SS_MCS_5,
+	BTC_VHT_2SS_MCS_6,
+	BTC_VHT_2SS_MCS_7,
+	BTC_VHT_2SS_MCS_8,
+	BTC_VHT_2SS_MCS_9,
+	BTC_VHT_3SS_MCS_0,
+	BTC_VHT_3SS_MCS_1,
+	BTC_VHT_3SS_MCS_2,
+	BTC_VHT_3SS_MCS_3,
+	BTC_VHT_3SS_MCS_4,
+	BTC_VHT_3SS_MCS_5,
+	BTC_VHT_3SS_MCS_6,
+	BTC_VHT_3SS_MCS_7,
+	BTC_VHT_3SS_MCS_8,
+	BTC_VHT_3SS_MCS_9,
+	BTC_VHT_4SS_MCS_0,
+	BTC_VHT_4SS_MCS_1,
+	BTC_VHT_4SS_MCS_2,
+	BTC_VHT_4SS_MCS_3,
+	BTC_VHT_4SS_MCS_4,
+	BTC_VHT_4SS_MCS_5,
+	BTC_VHT_4SS_MCS_6,
+	BTC_VHT_4SS_MCS_7,
+	BTC_VHT_4SS_MCS_8,
+	BTC_VHT_4SS_MCS_9,
+	BTC_MCS_32,
+	BTC_UNKNOWN,
+	BTC_PKT_MGNT,
+	BTC_PKT_CTRL,
+	BTC_PKT_UNKNOWN,
+	BTC_PKT_NOT_FOR_ME,
+	BTC_RATE_MAX
+};
+
+enum {
+	BTC_MULTIPORT_SCC,
+	BTC_MULTIPORT_MCC_DUAL_CHANNEL,
+	BTC_MULTIPORT_MCC_DUAL_BAND,
+	BTC_MULTIPORT_MAX
+};
+
+#define		BTC_COEX_8822B_COMMON_CODE	0
+#define		BTC_COEX_OFFLOAD			0
+#define		BTC_TMP_BUF_SHORT		20
+
+extern u1Byte	gl_btc_trace_buf[];
+#define		BTC_SPRINTF			rsprintf
+#define		BTC_TRACE(_MSG_)\
+do {\
+	if (GLBtcDbgType[COMP_COEX] & BIT(DBG_LOUD)) {\
+		RTW_INFO("%s", _MSG_);\
+	} \
+} while (0)
+#define		BT_PrintData(adapter, _MSG_, len, data)	RTW_DBG_DUMP((_MSG_), data, len)
+
+
+#define		NORMAL_EXEC					FALSE
+#define		FORCE_EXEC						TRUE
+
+#define		NM_EXCU						FALSE
+#define		FC_EXCU						TRUE
+
+#define		BTC_RF_OFF					0x0
+#define		BTC_RF_ON					0x1
+
+#define		BTC_RF_A					0x0
+#define		BTC_RF_B					0x1
+#define		BTC_RF_C					0x2
+#define		BTC_RF_D					0x3
+
+#define		BTC_SMSP				SINGLEMAC_SINGLEPHY
+#define		BTC_DMDP				DUALMAC_DUALPHY
+#define		BTC_DMSP				DUALMAC_SINGLEPHY
+#define		BTC_MP_UNKNOWN		0xff
+
+#define		BT_COEX_ANT_TYPE_PG			0
+#define		BT_COEX_ANT_TYPE_ANTDIV		1
+#define		BT_COEX_ANT_TYPE_DETECTED	2
+
+#define		BTC_MIMO_PS_STATIC			0	/* 1ss */
+#define		BTC_MIMO_PS_DYNAMIC			1	/* 2ss */
+
+#define		BTC_RATE_DISABLE			0
+#define		BTC_RATE_ENABLE				1
+
+/* single Antenna definition */
+#define		BTC_ANT_PATH_WIFI			0
+#define		BTC_ANT_PATH_BT				1
+#define		BTC_ANT_PATH_PTA			2
+#define		BTC_ANT_PATH_WIFI5G			3
+#define		BTC_ANT_PATH_AUTO			4
+/* dual Antenna definition */
+#define		BTC_ANT_WIFI_AT_MAIN		0
+#define		BTC_ANT_WIFI_AT_AUX			1
+#define		BTC_ANT_WIFI_AT_DIVERSITY	2
+/* coupler Antenna definition */
+#define		BTC_ANT_WIFI_AT_CPL_MAIN	0
+#define		BTC_ANT_WIFI_AT_CPL_AUX		1
+
+/* for common code request */
+#define REG_LTE_IDR_COEX_CTRL	0x0038
+#define REG_SYS_SDIO_CTRL		0x0070
+#define REG_SYS_SDIO_CTRL3		0x0073
+/* #define REG_RETRY_LIMIT		0x042a */
+/* #define REG_DARFRC			0x0430 */
+#define REG_DARFRCH				0x0434
+#define REG_CCK_CHECK			0x0454
+#define REG_AMPDU_MAX_TIME_V1	0x0455
+#define REG_TX_HANG_CTRL		0x045E
+#define REG_LIFETIME_EN			0x0426
+#define REG_BT_COEX_TABLE0		0x06C0
+#define REG_BT_COEX_TABLE1		0x06C4
+#define REG_BT_COEX_BRK_TABLE	0x06C8
+#define REG_BT_COEX_TABLE_H		0x06CC
+#define REG_BT_ACT_STATISTICS	0x0770
+#define REG_BT_ACT_STATISTICS_1	0x0774
+#define REG_BT_STAT_CTRL		0x0778
+
+#define BIT_EN_GNT_BT_AWAKE	BIT(3)
+#define BIT_EN_BCN_FUNCTION	BIT(3)
+#define BIT_EN_BCN_PKT_REL	BIT(6)
+#define BIT_FEN_BB_GLB_RST	BIT(1)
+#define BIT_FEN_BB_RSTB		BIT(0)
+
+#define TDMA_4SLOT			BIT(8)
+
+/* for 2T2R -> 2T1R coex MIMO-PS mechanism tranlation */
+#define BTC_2GTDD_MAX_TRY		3	/* the max retry count for 1R->2R */
+#define BTC_2GFDD_MAX_STAY	300	/* the max stay time at 1R if 2R try-able (unit: 2s) */
+
+typedef enum _BTC_POWERSAVE_TYPE {
+	BTC_PS_WIFI_NATIVE			= 0,	/* wifi original power save behavior */
+	BTC_PS_LPS_ON				= 1,
+	BTC_PS_LPS_OFF				= 2,
+	BTC_PS_MAX
+} BTC_POWERSAVE_TYPE, *PBTC_POWERSAVE_TYPE;
+
+typedef enum _BTC_BT_REG_TYPE {
+	BTC_BT_REG_RF						= 0,
+	BTC_BT_REG_MODEM					= 1,
+	BTC_BT_REG_BLUEWIZE					= 2,
+	BTC_BT_REG_VENDOR					= 3,
+	BTC_BT_REG_LE						= 4,
+	BTC_BT_REG_MAX
+} BTC_BT_REG_TYPE, *PBTC_BT_REG_TYPE;
+
+typedef enum _BTC_CHIP_INTERFACE {
+	BTC_INTF_UNKNOWN	= 0,
+	BTC_INTF_PCI			= 1,
+	BTC_INTF_USB			= 2,
+	BTC_INTF_SDIO		= 3,
+	BTC_INTF_MAX
+} BTC_CHIP_INTERFACE, *PBTC_CHIP_INTERFACE;
+
+typedef enum _BTC_CHIP_TYPE {
+	BTC_CHIP_UNDEF		= 0,
+	BTC_CHIP_CSR_BC4		= 1,
+	BTC_CHIP_CSR_BC8		= 2,
+	BTC_CHIP_RTL8723A		= 3,
+	BTC_CHIP_RTL8821		= 4,
+	BTC_CHIP_RTL8723B		= 5,
+	BTC_CHIP_RTL8822B 		= 6,
+	BTC_CHIP_RTL8822C 		= 7,
+	BTC_CHIP_RTL8821C 		= 8,
+	BTC_CHIP_RTL8821A 		= 9,
+	BTC_CHIP_RTL8723D 		= 10,
+	BTC_CHIP_RTL8703B 		= 11,
+	BTC_CHIP_RTL8725A 		= 12,
+	BTC_CHIP_RTL8723F 		= 13,
+	BTC_CHIP_MAX
+} BTC_CHIP_TYPE, *PBTC_CHIP_TYPE;
+
+/* following is for wifi link status */
+#define		WIFI_STA_CONNECTED				BIT0
+#define		WIFI_AP_CONNECTED				BIT1
+#define		WIFI_HS_CONNECTED				BIT2
+#define		WIFI_P2P_GO_CONNECTED			BIT3
+#define		WIFI_P2P_GC_CONNECTED			BIT4
+
+/* following is for command line utility */
+#define	CL_SPRINTF	rsprintf
+#define	CL_PRINTF	DCMD_Printf
+#define CL_STRNCAT(dst, dst_size, src, src_size) rstrncat(dst, src, src_size)
+
+static const char *const glbt_info_src[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+#define BTC_INFO_FTP		BIT(7)
+#define BTC_INFO_A2DP		BIT(6)
+#define BTC_INFO_HID		BIT(5)
+#define BTC_INFO_SCO_BUSY		BIT(4)
+#define BTC_INFO_ACL_BUSY		BIT(3)
+#define BTC_INFO_INQ_PAGE		BIT(2)
+#define BTC_INFO_SCO_ESCO		BIT(1)
+#define BTC_INFO_CONNECTION	BIT(0)
+
+#define BTC_BTINFO_LENGTH_MAX 10
+
+enum btc_gnt_setup_state {
+	BTC_GNT_SET_SW_LOW	= 0x0,
+	BTC_GNT_SET_SW_HIGH	= 0x1,
+	BTC_GNT_SET_HW_PTA	= 0x2,
+	BTC_GNT_SET_MAX
+};
+
+enum btc_gnt_setup_state_2 {
+	BTC_GNT_HW_PTA		= 0x0,
+	BTC_GNT_SW_LOW		= 0x1,
+	BTC_GNT_SW_HIGH		= 0x3,
+	BTC_GNT_MAX
+};
+
+enum btc_path_ctrl_owner {
+	BTC_OWNER_BT		= 0x0,
+	BTC_OWNER_WL		= 0x1,
+	BTC_OWNER_MAX
+};
+
+enum btc_gnt_ctrl_type {
+	BTC_GNT_CTRL_BY_PTA	= 0x0,
+	BTC_GNT_CTRL_BY_SW	= 0x1,
+	BTC_GNT_CTRL_MAX
+};
+
+enum btc_gnt_ctrl_block {
+	BTC_GNT_BLOCK_RFC_BB	= 0x0,
+	BTC_GNT_BLOCK_RFC	= 0x1,
+	BTC_GNT_BLOCK_BB	= 0x2,
+	BTC_GNT_BLOCK_MAX
+};
+
+enum btc_lte_coex_table_type {
+	BTC_CTT_WL_VS_LTE	= 0x0,
+	BTC_CTT_BT_VS_LTE	= 0x1,
+	BTC_CTT_MAX
+};
+
+enum btc_lte_break_table_type {
+	BTC_LBTT_WL_BREAK_LTE	= 0x0,
+	BTC_LBTT_BT_BREAK_LTE	= 0x1,
+	BTC_LBTT_LTE_BREAK_WL	= 0x2,
+	BTC_LBTT_LTE_BREAK_BT	= 0x3,
+	BTC_LBTT_MAX
+};
+
+enum btc_btinfo_src {
+	BTC_BTINFO_SRC_WL_FW	= 0x0,
+	BTC_BTINFO_SRC_BT_RSP	= 0x1,
+	BTC_BTINFO_SRC_BT_ACT	= 0x2,
+	BTC_BTINFO_SRC_BT_IQK	= 0x3,
+	BTC_BTINFO_SRC_BT_SCBD	= 0x4,
+	BTC_BTINFO_SRC_H2C60	= 0x5,
+	BTC_BTINFO_SRC_MAX
+};
+
+enum btc_bt_profile {
+	BTC_BTPROFILE_NONE		= 0,
+	BTC_BTPROFILE_HFP		= BIT(0),
+	BTC_BTPROFILE_HID		= BIT(1),
+	BTC_BTPROFILE_A2DP		= BIT(2),
+	BTC_BTPROFILE_PAN		= BIT(3),
+	BTC_BTPROFILE_MAX		= 0xf
+};
+
+static const char *const bt_profile_string[] = {
+	"None",
+	"HFP",
+	"HID",
+	"HID + HFP",
+	"A2DP",
+	"A2DP + HFP",
+	"A2DP + HID",
+	"PAN + HID + HFP",
+	"PAN",
+	"PAN + HFP",
+	"PAN + HID",
+	"PAN + HID + HFP",
+	"PAN + A2DP",
+	"PAN + A2DP + HFP",
+	"PAN + A2DP + HID",
+	"PAN + A2DP + HID + HFP"
+};
+
+enum btc_bt_status {
+	BTC_BTSTATUS_NCON_IDLE		= 0x0,
+	BTC_BTSTATUS_CON_IDLE		= 0x1,
+	BTC_BTSTATUS_INQ_PAGE		= 0x2,
+	BTC_BTSTATUS_ACL_BUSY		= 0x3,
+	BTC_BTSTATUS_SCO_BUSY		= 0x4,
+	BTC_BTSTATUS_ACL_SCO_BUSY	= 0x5,
+	BTC_BTSTATUS_MAX
+};
+
+static const char *const bt_status_string[] = {
+	"BT Non-Connected-idle",
+	"BT Connected-idle",
+	"BT Inq-page",
+	"BT ACL-busy",
+	"BT SCO-busy",
+	"BT ACL-SCO-busy",
+	"BT Non-Defined-state"
+};
+
+enum btc_coex_algo {
+	BTC_COEX_NOPROFILE		= 0x0,
+	BTC_COEX_HFP			= 0x1,
+	BTC_COEX_HID			= 0x2,
+	BTC_COEX_A2DP			= 0x3,
+	BTC_COEX_PAN			= 0x4,
+	BTC_COEX_A2DP_HID		= 0x5,
+	BTC_COEX_A2DP_PAN		= 0x6,
+	BTC_COEX_PAN_HID		= 0x7,
+	BTC_COEX_A2DP_PAN_HID		= 0x8,
+	BTC_COEX_MAX
+};
+
+static const char *const coex_algo_string[] = {
+	"No Profile",
+	"HFP",
+	"HID",
+	"A2DP",
+	"PAN",
+	"A2DP + HID",
+	"A2DP + PAN",
+	"PAN + HID",
+	"A2DP + PAN + HID"
+};
+
+enum btc_ext_ant_switch_type {
+	BTC_SWITCH_NONE	= 0x0,
+	BTC_SWITCH_SPDT	= 0x1,
+	BTC_SWITCH_SP3T	= 0x2,
+	BTC_SWITCH_DPDT = 0x3,
+	BTC_SWITCH_ANTMAX
+};
+
+enum btc_ext_ant_switch_ctrl_type {
+	BTC_SWITCH_CTRL_BY_BBSW		= 0x0,
+	BTC_SWITCH_CTRL_BY_PTA		= 0x1,
+	BTC_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BTC_SWITCH_CTRL_BY_MAC		= 0x3,
+	BTC_SWITCH_CTRL_BY_BT		= 0x4,
+	BTC_SWITCH_CTRL_BY_FW		= 0x5,
+	BTC_SWITCH_CTRL_MAX
+};
+
+enum btc_ext_ant_switch_pos_type {
+	BTC_SWITCH_TO_BT		= 0x0,
+	BTC_SWITCH_TO_WLG		= 0x1,
+	BTC_SWITCH_TO_WLA		= 0x2,
+	BTC_SWITCH_TO_NOCARE		= 0x3,
+	BTC_SWITCH_TO_WLG_BT		= 0x4,
+	BTC_SWITCH_TO_MAX
+};
+
+enum btx_set_ant_phase {
+	BTC_ANT_INIT			= 0x0,
+	BTC_ANT_WONLY			= 0x1,
+	BTC_ANT_WOFF			= 0x2,
+	BTC_ANT_2G			= 0x3,
+	BTC_ANT_5G			= 0x4,
+	BTC_ANT_BTMP			= 0x5,
+	BTC_ANT_POWERON			= 0x6,
+	BTC_ANT_2G_WL			= 0x7,
+	BTC_ANT_2G_BT			= 0x8,
+	BTC_ANT_MCC			= 0x9,
+	BTC_ANT_2G_WLBT			= 0xa,
+	BTC_ANT_2G_FREERUN		= 0xb,
+	BTC_ANT_MAX
+};
+
+/*ADD SCOREBOARD TO FIX BT LPS 32K ISSUE WHILE WL BUSY*/
+enum btc_wl2bt_scoreboard {
+	BTC_SCBD_ACTIVE		= BIT(0),
+	BTC_SCBD_ON			= BIT(1),
+	BTC_SCBD_SCAN		= BIT(2),
+	BTC_SCBD_UNDERTEST	= BIT(3),
+	BTC_SCBD_RXGAIN		= BIT(4),
+	BTC_SCBD_WLBUSY		= BIT(7),
+	BTC_SCBD_EXTFEM		= BIT(8),
+	BTC_SCBD_TDMA		= BIT(9),
+	BTC_SCBD_FIX2M		= BIT(10),
+	BTC_SCBD_MAILBOX_DBG	= BIT(14),
+	BTC_SCBD_ALL		= 0xffff,
+	BTC_SCBD_ALL_32BIT	= 0xffffffff
+};
+
+enum btc_bt2wl_scoreboard {
+	BTC_SCBD_BT_ONOFF	= BIT(1),
+	BTC_SCBD_BT_LPS		= BIT(7)
+};
+enum btc_scoreboard_bit_num {
+	BTC_SCBD_16_BIT		= BIT(0),
+	BTC_SCBD_32_BIT		= BIT(1)
+};
+
+enum btc_runreason {
+	BTC_RSN_2GSCANSTART	= 0x0,
+	BTC_RSN_5GSCANSTART	= 0x1,
+	BTC_RSN_SCANFINISH	= 0x2,
+	BTC_RSN_2GSWITCHBAND	= 0x3,
+	BTC_RSN_5GSWITCHBAND	= 0x4,
+	BTC_RSN_2GCONSTART	= 0x5,
+	BTC_RSN_5GCONSTART	= 0x6,
+	BTC_RSN_2GCONFINISH	= 0x7,
+	BTC_RSN_5GCONFINISH	= 0x8,
+	BTC_RSN_2GMEDIA		= 0x9,
+	BTC_RSN_5GMEDIA		= 0xa,
+	BTC_RSN_MEDIADISCON	= 0xb,
+	BTC_RSN_2GSPECIALPKT	= 0xc,
+	BTC_RSN_5GSPECIALPKT	= 0xd,
+	BTC_RSN_BTINFO		= 0xe,
+	BTC_RSN_PERIODICAL	= 0xf,
+	BTC_RSN_PNP		= 0x10,
+	BTC_RSN_LPS		= 0x11,
+	BTC_RSN_TIMERUP		= 0x12,
+	BTC_RSN_WLSTATUS	= 0x13,
+	BTC_RSN_BTCNT		= 0x14,
+	BTC_RSN_RFK		= 0x15,
+	BTC_RSN_MAX
+};
+
+static const char *const run_reason_string[] = {
+	"2G_SCAN_START",
+	"5G_SCAN_START",
+	"SCAN_FINISH",
+	"2G_SWITCH_BAND",
+	"5G_SWITCH_BAND",
+	"2G_CONNECT_START",
+	"5G_CONNECT_START",
+	"2G_CONNECT_FINISH",
+	"5G_CONNECT_FINISH",
+	"2G_MEDIA_STATUS",
+	"5G_MEDIA_STATUS",
+	"MEDIA_DISCONNECT",
+	"2G_SPECIALPKT",
+	"5G_SPECIALPKT",
+	"BTINFO",
+	"PERIODICAL",
+	"PNPNotify",
+	"LPSNotify",
+	"TimerUp",
+	"WL_STATUS_CHANGE",
+	"BT_CNT_CHANGE",
+	"WL_RFK",
+	"Reason Max"
+};
+
+enum btc_wl_link_mode {
+	BTC_WLINK_2G1PORT	= 0x0,
+	BTC_WLINK_2GMPORT	= 0x1,
+	BTC_WLINK_25GMPORT	= 0x2,
+	BTC_WLINK_5G		= 0x3,
+	BTC_WLINK_2GGO		= 0x4,
+	BTC_WLINK_2GGC		= 0x5,
+	BTC_WLINK_BTMR		= 0x6,
+	BTC_WLINK_2GFREE	= 0x7,
+	BTC_WLINK_MAX
+};
+
+static const char *const coex_mode_string[] = {
+	"2G-SP",
+	"2G-MP",
+	"25G-MP",
+	"5G",
+	"2G-P2P-GO",
+	"2G-P2P-GC",
+	"BT-MR",
+	"2G1RFREE",
+	"unknow"
+};
+
+enum btc_bt_state_cnt {
+	BTC_CNT_BT_RETRY	= 0x0,
+	BTC_CNT_BT_REINIT	= 0x1,
+	BTC_CNT_BT_POPEVENT	= 0x2,
+	BTC_CNT_BT_SETUPLINK	= 0x3,
+	BTC_CNT_BT_IGNWLANACT	= 0x4,
+	BTC_CNT_BT_INQ		= 0x5,
+	BTC_CNT_BT_PAGE		= 0x6,
+	BTC_CNT_BT_ROLESWITCH	= 0x7,
+	BTC_CNT_BT_AFHUPDATE	= 0x8,
+	BTC_CNT_BT_DISABLE	= 0x9,
+	BTC_CNT_BT_INFOUPDATE	= 0xa,
+	BTC_CNT_BT_IQK		= 0xb,
+	BTC_CNT_BT_IQKFAIL	= 0xc,
+	BTC_CNT_BT_TRX		= 0xd,
+	BTC_CNT_BT_MAX
+};
+
+enum btc_wl_state_cnt {
+	BTC_CNT_WL_SCANAP		= 0x0,
+	BTC_CNT_WL_ARP			= 0x1,
+	BTC_CNT_WL_GNTERR		= 0x2,
+	BTC_CNT_WL_PSFAIL		= 0x3,
+	BTC_CNT_WL_COEXRUN		= 0x4,
+	BTC_CNT_WL_COEXINFO1		= 0x5,
+	BTC_CNT_WL_COEXINFO2		= 0x6,
+	BTC_CNT_WL_AUTOSLOT_HANG	= 0x7,
+	BTC_CNT_WL_NOISY0		= 0x8,
+	BTC_CNT_WL_NOISY1		= 0x9,
+	BTC_CNT_WL_NOISY2		= 0xa,
+	BTC_CNT_WL_ACTIVEPORT		= 0xb,
+	BTC_CNT_WL_LEAKAP_NORX		= 0xc,
+	BTC_CNT_WL_FW_NOTIFY		= 0xd,
+	BTC_CNT_WL_2G_TDDTRY		= 0xe,
+	BTC_CNT_WL_2G_FDDSTAY		= 0xf,
+	BTC_CNT_WL_MAX
+};
+
+enum btc_wl_crc_cnt {
+	BTC_WLCRC_11BOK		= 0x0,
+	BTC_WLCRC_11GOK		= 0x1,
+	BTC_WLCRC_11NOK		= 0x2,
+	BTC_WLCRC_11VHTOK	= 0x3,
+	BTC_WLCRC_11BERR	= 0x4,
+	BTC_WLCRC_11GERR	= 0x5,
+	BTC_WLCRC_11NERR	= 0x6,
+	BTC_WLCRC_11VHTERR	= 0x7,
+	BTC_WLCRC_MAX
+};
+
+enum btc_timer_cnt {
+	BTC_TIMER_WL_STAYBUSY	= 0x0,
+	BTC_TIMER_WL_COEXFREEZE	= 0x1,
+	BTC_TIMER_WL_SPECPKT	= 0x2,
+	BTC_TIMER_WL_CONNPKT	= 0x3,
+	BTC_TIMER_WL_PNPWAKEUP	= 0x4,
+	BTC_TIMER_WL_CCKLOCK	= 0x5,
+	BTC_TIMER_WL_FWDBG	= 0x6,
+	BTC_TIMER_BT_RELINK	= 0x7,
+	BTC_TIMER_BT_REENABLE	= 0x8,
+	BTC_TIMER_BT_MULTILINK	= 0x9,
+	BTC_TIMER_BT_INQPAGE	= 0xa,
+	BTC_TIMER_BT_A2DP_ACT	= 0xb,
+	BTC_TIMER_MAX
+};
+
+enum btc_wl_status_change {
+	BTC_WLSTATUS_CHANGE_TOIDLE	= 0x0,
+	BTC_WLSTATUS_CHANGE_TOBUSY	= 0x1,
+	BTC_WLSTATUS_CHANGE_RSSI	= 0x2,
+	BTC_WLSTATUS_CHANGE_LINKINFO	= 0x3,
+	BTC_WLSTATUS_CHANGE_DIR	= 0x4,
+	BTC_WLSTATUS_CHANGE_NOISY	= 0x5,
+	BTC_WLSTATUS_CHANGE_BTCNT	= 0x6,
+	BTC_WLSTATUS_CHANGE_LOCKTRY	= 0x7,
+	BTC_WLSTATUS_CHANGE_MAX
+};
+
+enum btc_commom_chip_setup {
+	BTC_CSETUP_INIT_HW		= 0x0,
+	BTC_CSETUP_ANT_SWITCH	= 0x1,
+	BTC_CSETUP_GNT_FIX		= 0x2,
+	BTC_CSETUP_GNT_DEBUG	= 0x3,
+	BTC_CSETUP_RFE_TYPE		= 0x4,
+	BTC_CSETUP_COEXINFO_HW	= 0x5,
+	BTC_CSETUP_WL_TX_POWER	= 0x6,
+	BTC_CSETUP_WL_RX_GAIN	= 0x7,
+	BTC_CSETUP_WLAN_ACT_IPS = 0x8,
+	BTC_CSETUP_BT_CTRL_ACT	= 0x9,
+	BTC_CSETUP_MAX
+};
+
+enum btc_indirect_reg_type {
+	BTC_INDIRECT_1700	= 0x0,
+	BTC_INDIRECT_7C0	= 0x1,
+	BTC_INDIRECT_MAX
+};
+
+enum btc_pstdma_type {
+	BTC_PSTDMA_FORCE_LPSOFF	= 0x0,
+	BTC_PSTDMA_FORCE_LPSON	= 0x1,
+	BTC_PSTDMA_MAX
+};
+
+enum btc_btrssi_type {
+	BTC_BTRSSI_RATIO	= 0x0,
+	BTC_BTRSSI_DBM		= 0x1,
+	BTC_BTRSSI_MAX
+};
+
+enum btc_wl_priority_mask {
+	BTC_WLPRI_RX_RSP	= 2,
+	BTC_WLPRI_TX_RSP	= 3,
+	BTC_WLPRI_TX_BEACON	= 4,
+	BTC_WLPRI_TX_OFDM	= 11,
+	BTC_WLPRI_TX_CCK	= 12,
+	BTC_WLPRI_TX_BEACONQ	= 27,
+	BTC_WLPRI_RX_CCK	= 28,
+	BTC_WLPRI_RX_OFDM	= 29,
+	BTC_WLPRI_MAX
+};
+
+enum btc_ext_chip_id{
+        BTC_EXT_CHIP_NONE,
+        BTC_EXT_CHIP_RF4CE,
+        BTC_EXT_CHIP_MAX
+};
+
+enum btc_ext_chip_mode{
+        BTC_EXTMODE_NORMAL,
+        BTC_EXTMODE_VOICE,
+        BTC_EXTMODE_MAX
+};
+
+enum btc_wl_rfk_type {
+	BTC_PWR_TRK = 0,
+	BTC_IQK = 1,
+	BTC_LCK = 2,
+	BTC_DPK = 3,
+	BTC_TXGAPK = 4,
+	BTC_RFK_TYPE_MAX
+};
+
+enum btc_wl_rfk_state {
+	BTC_RFK_START = 0,
+	BTC_RFK_END = 1,
+	BTC_RFK_STATE_MAX
+};
+
+struct btc_board_info {
+	/* The following is some board information */
+	u8				bt_chip_type;
+	u8				pg_ant_num;	/* pg ant number */
+	u8				btdm_ant_num;	/* ant number for btdm */
+	u8				btdm_ant_num_by_ant_det;	/* ant number for btdm after antenna detection */
+	u8				btdm_ant_pos;		/* Bryant Add to indicate Antenna Position for (pg_ant_num = 2) && (btdm_ant_num =1)  (DPDT+1Ant case) */
+	u8				single_ant_path;	/* current used for 8723b only, 1=>s0,  0=>s1 */
+	boolean			tfbga_package;    /* for Antenna detect threshold */
+	boolean			btdm_ant_det_finish;
+	boolean			btdm_ant_det_already_init_phydm;
+	u8				ant_type;
+	u8				rfe_type;
+	u8				ant_div_cfg;
+	boolean			btdm_ant_det_complete_fail;
+	u8				ant_det_result;
+	boolean			ant_det_result_five_complete;
+	u32				antdetval;
+	u8				customerID;
+	u8				customer_id;
+	u8				ant_distance;	/* WL-BT antenna space for non-shared antenna  */
+	u8				ext_chip_id;
+};
+
+struct btc_coex_dm {
+	boolean cur_ignore_wlan_act;
+	boolean cur_ps_tdma_on;
+	boolean cur_low_penalty_ra;
+	boolean cur_wl_rx_low_gain_en;
+
+	u8	bt_rssi_state[4];
+	u8	wl_rssi_state[4];
+	u8	cur_ps_tdma;
+	u8	ps_tdma_para[5];
+	u8	fw_tdma_para[5];
+	u8	cur_lps;
+	u8	cur_rpwm;
+	u8	cur_bt_pwr_lvl;
+	u8	cur_bt_lna_lvl;
+	u8	cur_wl_pwr_lvl;
+	u8	cur_algorithm;
+	u8	bt_status;
+	u8	wl_chnl_info[3];
+	u8	cur_toggle_para[6];
+	u32	cur_ant_pos_type;
+	u32	cur_switch_status;
+	u32	setting_tdma;
+};
+
+struct btc_coex_sta {
+	boolean coex_freeze;
+	boolean coex_freerun;
+	boolean rf4ce_en;
+	boolean force_freerun;
+	boolean force_tdd;
+
+	boolean bt_disabled;
+	boolean bt_disabled_pre;
+	boolean bt_link_exist;
+	boolean bt_whck_test;
+	boolean bt_inq_page;
+	boolean bt_inq_page_pre;
+	boolean bt_inq_page_remain;
+	boolean bt_inq;
+	boolean bt_page;
+	boolean bt_ble_voice;
+	boolean bt_ble_exist;
+	boolean bt_hfp_exist;
+	boolean bt_a2dp_exist;
+	boolean bt_hid_exist;
+	boolean bt_pan_exist; // PAN or OPP
+	boolean bt_opp_exist; //OPP only
+	boolean bt_msft_mr_exist;
+	boolean bt_acl_busy;
+	boolean bt_fix_2M;
+	boolean bt_setup_link;
+	boolean bt_multi_link;
+	boolean bt_multi_link_pre;
+	boolean bt_multi_link_remain;
+	boolean bt_a2dp_sink;
+	boolean bt_reenable;
+	boolean bt_ble_scan_en;
+	boolean bt_slave;
+	boolean bt_a2dp_active;
+	boolean bt_a2dp_active_pre;
+	boolean bt_a2dp_active_remain;
+	boolean bt_slave_latency;
+	boolean bt_init_scan;
+	boolean bt_418_hid_exist;
+	boolean bt_ble_hid_exist;
+	boolean bt_mesh;
+	boolean bt_ctr_ok;
+
+	boolean wl_under_lps;
+	boolean wl_under_ips;
+	boolean wl_under_4way;
+	boolean	wl_hi_pri_task1;
+	boolean	wl_hi_pri_task2;
+	boolean wl_cck_lock;
+	boolean wl_cck_lock_pre;
+	boolean wl_cck_lock_ever;
+	boolean wl_force_lps_ctrl;
+	boolean wl_busy_pre;
+	boolean wl_gl_busy;
+	boolean wl_gl_busy_pre;
+	boolean wl_linkscan_proc;
+	boolean wl_mimo_ps;
+	boolean wl_cck_dead_lock_ap;
+	boolean wl_tx_limit_en;
+	boolean wl_ampdu_limit_en;
+	boolean wl_rxagg_limit_en;
+	boolean wl_connecting;
+	boolean wl_pnp_wakeup;
+	boolean wl_slot_toggle;
+	boolean wl_slot_toggle_change; /* if toggle to no-toggle */
+	boolean wl_leak_ap; /* !is_no_wl_5ms_extend  */
+	boolean wl_blacklist_ap;
+	boolean wl_rfk;
+
+	u8	coex_table_type;
+	u8 	coex_run_reason;
+	u8	tdma_byte4_modify_pre;
+	u8	kt_ver;
+	u8	gnt_workaround_state;
+	u8	tdma_timer_base;
+	u8	bt_rssi;
+	u8	bt_profile_num;
+	u8	bt_profile_num_pre;
+	u8	bt_info_c2h[BTC_BTINFO_SRC_MAX][BTC_BTINFO_LENGTH_MAX];
+	u8	bt_info_lb2;
+	u8	bt_info_lb3;
+	u8	bt_info_hb0;
+	u8	bt_info_hb1;
+	u8	bt_info_hb2;
+	u8	bt_info_hb3;
+	u8	bt_ble_scan_type;
+	u8	bt_afh_map[10];
+	u8	bt_a2dp_vendor_id;
+	u8	bt_hid_pair_num;
+	u8	bt_hid_slot;
+	u8	bt_a2dp_bitpool;
+	u8	bt_iqk_state;
+	u8	bt_sut_pwr_lvl[4];
+	u8	bt_golden_rx_shift[4];
+	u8	bt_ext_autoslot_thres;
+	u8	ext_chip_mode;
+
+	u8	wl_pnp_state_pre;
+	u8	wl_noisy_level;
+	u8	wl_fw_dbg_info[10];
+	u8	wl_fw_dbg_info_pre[10];
+	u8	wl_rx_rate;
+	u8	wl_tx_rate;
+	u8	wl_rts_rx_rate;
+	u8	wl_center_ch;
+	u8	wl_tx_macid;
+	u8	wl_tx_retry_ratio;
+	u8	wl_coex_mode;
+	u8	wl_iot_peer;
+	u8	wl_ra_thres;
+	u8	wl_ampdulen;
+	u8	wl_rxagg_size;
+	u8	wl_toggle_para[6];
+	u8	wl_toggle_interval;
+
+	u16	score_board_BW;
+	u32	score_board_WB;
+	u16	bt_reg_vendor_ac;
+	u16	bt_reg_vendor_ae;
+	u32	bt_reg_vendor_dac;
+	u16	bt_reg_modem_a;
+	u16	bt_reg_rf_2;
+	u16	bt_reg_rf_9;
+	u16	wl_txlimit;
+
+	u32	score_board_BW_32bit;
+	u32	score_board_WB_32bit;
+	u32	hi_pri_tx;
+	u32	hi_pri_rx;
+	u32	lo_pri_tx;
+	u32	lo_pri_rx;
+	u32	bt_supported_feature;
+	u32	bt_supported_version;
+	u32	bt_ble_scan_para[3];
+	u32	bt_a2dp_device_name;
+	u32	bt_a2dp_flush_time;
+	u32	wl_arfb1;
+	u32	wl_arfb2;
+	u32	wl_traffic_dir;
+	u32	wl_bw;
+	u32	cnt_bt_info_c2h[BTC_BTINFO_SRC_MAX];
+	u32	cnt_bt[BTC_CNT_BT_MAX];
+	u32	cnt_wl[BTC_CNT_WL_MAX];
+	u32	cnt_timer[BTC_TIMER_MAX];
+};
+
+struct btc_rfe_type {
+	boolean ant_switch_exist;
+	boolean ant_switch_diversity; /* If diversity on */
+	boolean ant_switch_with_bt; /* If WL_2G/BT use ext-switch at shared-ant */
+	u8	rfe_module_type;
+	u8	ant_switch_type;
+	u8	ant_switch_polarity;
+	
+	boolean band_switch_exist;
+	u8	band_switch_type; /* 0:DPDT, 1:SPDT */
+	u8	band_switch_polarity;
+
+	/*  If TRUE:  WLG at BTG, If FALSE: WLG at WLAG */
+	boolean wlg_at_btg;
+};
+
+
+struct btc_wifi_link_info_ext {
+	boolean is_all_under_5g;
+	boolean is_mcc_25g;
+	boolean is_p2p_connected;
+	boolean is_ap_mode;
+	boolean is_scan;
+	boolean is_link;
+	boolean is_roam;
+	boolean is_4way;
+	boolean is_32k;
+	boolean is_connected;
+	u8	num_of_active_port;
+	u32	port_connect_status;
+	u32	traffic_dir;
+	u32	wifi_bw;
+};
+
+struct btc_coex_table_para {
+	u32 bt;	//0x6c0
+	u32 wl;	//0x6c4
+};
+
+struct btc_tdma_para {
+	u8 para[5];
+};
+
+struct btc_reg_byte_modify {
+	u32 addr;
+	u8 bitmask;
+	u8 val;
+};
+
+struct btc_5g_afh_map {
+	u32 wl_5g_ch;
+	u8 bt_skip_ch;
+	u8 bt_skip_span;
+};
+
+struct btc_rf_para {
+	u8 wl_pwr_dec_lvl;
+	u8 bt_pwr_dec_lvl;
+	boolean wl_low_gain_en;
+	u8 bt_lna_lvl;
+};
+
+typedef enum _BTC_DBG_OPCODE {
+	BTC_DBG_SET_COEX_NORMAL				= 0x0,
+	BTC_DBG_SET_COEX_WIFI_ONLY				= 0x1,
+	BTC_DBG_SET_COEX_BT_ONLY				= 0x2,
+	BTC_DBG_SET_COEX_DEC_BT_PWR				= 0x3,
+	BTC_DBG_SET_COEX_BT_AFH_MAP				= 0x4,
+	BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT		= 0x5,
+	BTC_DBG_SET_COEX_MANUAL_CTRL				= 0x6,
+	BTC_DBG_MAX
+} BTC_DBG_OPCODE, *PBTC_DBG_OPCODE;
+
+typedef enum _BTC_RSSI_STATE {
+	BTC_RSSI_STATE_HIGH						= 0x0,
+	BTC_RSSI_STATE_MEDIUM					= 0x1,
+	BTC_RSSI_STATE_LOW						= 0x2,
+	BTC_RSSI_STATE_STAY_HIGH					= 0x3,
+	BTC_RSSI_STATE_STAY_MEDIUM				= 0x4,
+	BTC_RSSI_STATE_STAY_LOW					= 0x5,
+	BTC_RSSI_MAX
+} BTC_RSSI_STATE, *PBTC_RSSI_STATE;
+#define	BTC_RSSI_HIGH(_rssi_)	((_rssi_ == BTC_RSSI_STATE_HIGH || _rssi_ == BTC_RSSI_STATE_STAY_HIGH) ? TRUE:FALSE)
+#define	BTC_RSSI_MEDIUM(_rssi_)	((_rssi_ == BTC_RSSI_STATE_MEDIUM || _rssi_ == BTC_RSSI_STATE_STAY_MEDIUM) ? TRUE:FALSE)
+#define	BTC_RSSI_LOW(_rssi_)	((_rssi_ == BTC_RSSI_STATE_LOW || _rssi_ == BTC_RSSI_STATE_STAY_LOW) ? TRUE:FALSE)
+
+typedef enum _BTC_WIFI_ROLE {
+	BTC_ROLE_STATION						= 0x0,
+	BTC_ROLE_AP								= 0x1,
+	BTC_ROLE_IBSS							= 0x2,
+	BTC_ROLE_HS_MODE						= 0x3,
+	BTC_ROLE_MAX
+} BTC_WIFI_ROLE, *PBTC_WIFI_ROLE;
+
+typedef enum _BTC_WIRELESS_FREQ {
+	BTC_FREQ_2_4G					= 0x0,
+	BTC_FREQ_5G						= 0x1,
+	BTC_FREQ_25G					= 0x2,
+	BTC_FREQ_MAX
+} BTC_WIRELESS_FREQ, *PBTC_WIRELESS_FREQ;
+
+typedef enum _BTC_WIFI_BW_MODE {
+	BTC_WIFI_BW_LEGACY					= 0x0,
+	BTC_WIFI_BW_HT20					= 0x1,
+	BTC_WIFI_BW_HT40					= 0x2,
+	BTC_WIFI_BW_HT80					= 0x3,
+	BTC_WIFI_BW_HT160					= 0x4,
+	BTC_WIFI_BW_MAX
+} BTC_WIFI_BW_MODE, *PBTC_WIFI_BW_MODE;
+
+typedef enum _BTC_WIFI_TRAFFIC_DIR {
+	BTC_WIFI_TRAFFIC_TX					= 0x0,
+	BTC_WIFI_TRAFFIC_RX					= 0x1,
+	BTC_WIFI_TRAFFIC_MAX
+} BTC_WIFI_TRAFFIC_DIR, *PBTC_WIFI_TRAFFIC_DIR;
+
+typedef enum _BTC_WIFI_PNP {
+	BTC_WIFI_PNP_WAKE_UP					= 0x0,
+	BTC_WIFI_PNP_SLEEP						= 0x1,
+	BTC_WIFI_PNP_SLEEP_KEEP_ANT				= 0x2,
+	BTC_WIFI_PNP_WOWLAN					= 0x3,
+	BTC_WIFI_PNP_MAX
+} BTC_WIFI_PNP, *PBTC_WIFI_PNP;
+
+typedef enum _BTC_IOT_PEER {
+	BTC_IOT_PEER_UNKNOWN = 0,
+	BTC_IOT_PEER_REALTEK = 1,
+	BTC_IOT_PEER_REALTEK_92SE = 2,
+	BTC_IOT_PEER_BROADCOM = 3,
+	BTC_IOT_PEER_RALINK = 4,
+	BTC_IOT_PEER_ATHEROS = 5,
+	BTC_IOT_PEER_CISCO = 6,
+	BTC_IOT_PEER_MERU = 7,
+	BTC_IOT_PEER_MARVELL = 8,
+	BTC_IOT_PEER_REALTEK_SOFTAP = 9, /* peer is RealTek SOFT_AP, by Bohn, 2009.12.17 */
+	BTC_IOT_PEER_SELF_SOFTAP = 10, /* Self is SoftAP */
+	BTC_IOT_PEER_AIRGO = 11,
+	BTC_IOT_PEER_INTEL				= 12,
+	BTC_IOT_PEER_RTK_APCLIENT		= 13,
+	BTC_IOT_PEER_REALTEK_81XX		= 14,
+	BTC_IOT_PEER_REALTEK_WOW		= 15,
+	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	BTC_IOT_PEER_MAX,
+} BTC_IOT_PEER, *PBTC_IOT_PEER;
+
+/* for 8723b-d cut large current issue */
+typedef enum _BTC_WIFI_COEX_STATE {
+	BTC_WIFI_STAT_INIT,
+	BTC_WIFI_STAT_IQK,
+	BTC_WIFI_STAT_NORMAL_OFF,
+	BTC_WIFI_STAT_MP_OFF,
+	BTC_WIFI_STAT_NORMAL,
+	BTC_WIFI_STAT_ANT_DIV,
+	BTC_WIFI_STAT_MAX
+} BTC_WIFI_COEX_STATE, *PBTC_WIFI_COEX_STATE;
+
+typedef enum _BTC_ANT_TYPE {
+	BTC_ANT_TYPE_0,
+	BTC_ANT_TYPE_1,
+	BTC_ANT_TYPE_2,
+	BTC_ANT_TYPE_3,
+	BTC_ANT_TYPE_4,
+	BTC_ANT_TYPE_MAX
+} BTC_ANT_TYPE, *PBTC_ANT_TYPE;
+
+typedef enum _BTC_VENDOR {
+	BTC_VENDOR_LENOVO,
+	BTC_VENDOR_ASUS,
+	BTC_VENDOR_OTHER
+} BTC_VENDOR, *PBTC_VENDOR;
+
+
+/* defined for BFP_BTC_GET */
+typedef enum _BTC_GET_TYPE {
+	/* type BOOLEAN */
+	BTC_GET_BL_HS_OPERATION,
+	BTC_GET_BL_HS_CONNECTING,
+	BTC_GET_BL_WIFI_FW_READY,
+	BTC_GET_BL_WIFI_CONNECTED,
+	BTC_GET_BL_WIFI_DUAL_BAND_CONNECTED,
+	BTC_GET_BL_WIFI_LINK_INFO,
+	BTC_GET_BL_WIFI_BUSY,
+	BTC_GET_BL_WIFI_SCAN,
+	BTC_GET_BL_WIFI_LINK,
+	BTC_GET_BL_WIFI_ROAM,
+	BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+	BTC_GET_BL_WIFI_UNDER_5G,
+	BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+	BTC_GET_BL_WIFI_ENABLE_ENCRYPTION,
+	BTC_GET_BL_WIFI_UNDER_B_MODE,
+	BTC_GET_BL_EXT_SWITCH,
+	BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+	BTC_GET_BL_IS_ASUS_8723B,
+	BTC_GET_BL_RF4CE_CONNECTED,
+	BTC_GET_BL_WIFI_LW_PWR_STATE,
+
+	/* type s4Byte */
+	BTC_GET_S4_WIFI_RSSI,
+	BTC_GET_S4_HS_RSSI,
+
+	/* type u4Byte */
+	BTC_GET_U4_WIFI_BW,
+	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
+	BTC_GET_U4_WIFI_TRAFFIC_DIR,
+	BTC_GET_U4_WIFI_FW_VER,
+	BTC_GET_U4_WIFI_PHY_VER,
+	BTC_GET_U4_WIFI_LINK_STATUS,
+	BTC_GET_U4_BT_PATCH_VER,
+	BTC_GET_U4_VENDOR,
+	BTC_GET_U4_SUPPORTED_VERSION,
+	BTC_GET_U4_SUPPORTED_FEATURE,
+	BTC_GET_U4_BT_DEVICE_INFO,
+	BTC_GET_U4_BT_FORBIDDEN_SLOT_VAL,
+	BTC_GET_U4_BT_A2DP_FLUSH_VAL,
+	BTC_GET_U4_WIFI_IQK_TOTAL,
+	BTC_GET_U4_WIFI_IQK_OK,
+	BTC_GET_U4_WIFI_IQK_FAIL,
+
+	/* type u1Byte */
+	BTC_GET_U1_WIFI_DOT11_CHNL,
+	BTC_GET_U1_WIFI_CENTRAL_CHNL,
+	BTC_GET_U1_WIFI_HS_CHNL,
+	BTC_GET_U1_WIFI_P2P_CHNL,
+	BTC_GET_U1_MAC_PHY_MODE,
+	BTC_GET_U1_AP_NUM,
+	BTC_GET_U1_ANT_TYPE,
+	BTC_GET_U1_IOT_PEER,
+	BTC_GET_BL_WIFI_BSSID,
+
+	/* type u2Byte */
+	BTC_GET_U2_BEACON_PERIOD,
+
+	/*===== for 1Ant ======*/
+	BTC_GET_U1_LPS_MODE,
+
+	BTC_GET_MAX
+} BTC_GET_TYPE, *PBTC_GET_TYPE;
+
+/* defined for BFP_BTC_SET */
+typedef enum _BTC_SET_TYPE {
+	/* type BOOLEAN */
+	BTC_SET_BL_BT_DISABLE,
+	BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE,
+	BTC_SET_BL_BT_TRAFFIC_BUSY,
+	BTC_SET_BL_BT_LIMITED_DIG,
+	BTC_SET_BL_FORCE_TO_ROAM,
+	BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+	BTC_SET_BL_BT_CTRL_AGG_SIZE,
+	BTC_SET_BL_INC_SCAN_DEV_NUM,
+	BTC_SET_BL_BT_TX_RX_MASK,
+	BTC_SET_BL_MIRACAST_PLUS_BT,
+	BTC_SET_BL_BT_LNA_CONSTRAIN_LEVEL,
+	BTC_SET_BL_BT_GOLDEN_RX_RANGE,
+
+	/* type u1Byte */
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+	BTC_SET_U1_AGG_BUF_SIZE,
+
+	/* type trigger some action */
+	BTC_SET_ACT_GET_BT_RSSI,
+	BTC_SET_ACT_AGGREGATE_CTRL,
+	BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+
+	// for mimo ps mode setting
+	BTC_SET_MIMO_PS_MODE,
+	/*===== for 1Ant ======*/
+	/* type BOOLEAN */
+
+	/* type u1Byte */
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE,
+	BTC_SET_U1_LPS_VAL,
+	BTC_SET_U1_RPWM_VAL,
+	/* type trigger some action */
+	BTC_SET_ACT_LEAVE_LPS,
+	BTC_SET_ACT_ENTER_LPS,
+	BTC_SET_ACT_NORMAL_LPS,
+	BTC_SET_ACT_PRE_NORMAL_LPS,
+	BTC_SET_ACT_POST_NORMAL_LPS,
+	BTC_SET_ACT_DISABLE_LOW_POWER,
+	BTC_SET_ACT_UPDATE_RAMASK,
+	BTC_SET_ACT_SEND_MIMO_PS,
+	/* BT Coex related */
+	BTC_SET_ACT_CTRL_BT_INFO,
+	BTC_SET_ACT_CTRL_BT_COEX,
+	BTC_SET_ACT_CTRL_8723B_ANT,
+	BTC_SET_RESET_COEX_VAR,
+	/*=================*/
+	BTC_SET_MAX
+} BTC_SET_TYPE, *PBTC_SET_TYPE;
+
+typedef enum _BTC_DBG_DISP_TYPE {
+	BTC_DBG_DISP_COEX_STATISTICS				= 0x0,
+	BTC_DBG_DISP_BT_LINK_INFO				= 0x1,
+	BTC_DBG_DISP_WIFI_STATUS				= 0x2,
+	BTC_DBG_DISP_MAX
+} BTC_DBG_DISP_TYPE, *PBTC_DBG_DISP_TYPE;
+
+typedef enum _BTC_NOTIFY_TYPE_IPS {
+	BTC_IPS_LEAVE							= 0x0,
+	BTC_IPS_ENTER							= 0x1,
+	BTC_IPS_MAX
+} BTC_NOTIFY_TYPE_IPS, *PBTC_NOTIFY_TYPE_IPS;
+typedef enum _BTC_NOTIFY_TYPE_LPS {
+	BTC_LPS_DISABLE							= 0x0,
+	BTC_LPS_ENABLE							= 0x1,
+	BTC_LPS_MAX
+} BTC_NOTIFY_TYPE_LPS, *PBTC_NOTIFY_TYPE_LPS;
+typedef enum _BTC_NOTIFY_TYPE_SCAN {
+	BTC_SCAN_FINISH							= 0x0,
+	BTC_SCAN_START							= 0x1,
+	BTC_SCAN_START_2G						= 0x2,
+	BTC_SCAN_START_5G						= 0x3,
+	BTC_SCAN_MAX
+} BTC_NOTIFY_TYPE_SCAN, *PBTC_NOTIFY_TYPE_SCAN;
+typedef enum _BTC_NOTIFY_TYPE_SWITCHBAND {
+	BTC_NOT_SWITCH							= 0x0,
+	BTC_SWITCH_TO_24G						= 0x1,
+	BTC_SWITCH_TO_5G						= 0x2,
+	BTC_SWITCH_TO_24G_NOFORSCAN				= 0x3,
+	BTC_SWITCH_MAX
+} BTC_NOTIFY_TYPE_SWITCHBAND, *PBTC_NOTIFY_TYPE_SWITCHBAND;
+typedef enum _BTC_NOTIFY_TYPE_ASSOCIATE {
+	BTC_ASSOCIATE_FINISH						= 0x0,
+	BTC_ASSOCIATE_START						= 0x1,
+	BTC_ASSOCIATE_5G_FINISH						= 0x2,
+	BTC_ASSOCIATE_5G_START						= 0x3,
+	BTC_ASSOCIATE_MAX
+} BTC_NOTIFY_TYPE_ASSOCIATE, *PBTC_NOTIFY_TYPE_ASSOCIATE;
+typedef enum _BTC_NOTIFY_TYPE_MEDIA_STATUS {
+	BTC_MEDIA_DISCONNECT					= 0x0,
+	BTC_MEDIA_CONNECT						= 0x1,
+	BTC_MEDIA_CONNECT_5G					= 0x02,
+	BTC_MEDIA_MAX
+} BTC_NOTIFY_TYPE_MEDIA_STATUS, *PBTC_NOTIFY_TYPE_MEDIA_STATUS;
+typedef enum _BTC_NOTIFY_TYPE_SPECIFIC_PACKET {
+	BTC_PACKET_UNKNOWN					= 0x0,
+	BTC_PACKET_DHCP							= 0x1,
+	BTC_PACKET_ARP							= 0x2,
+	BTC_PACKET_EAPOL						= 0x3,
+	BTC_PACKET_MAX
+} BTC_NOTIFY_TYPE_SPECIFIC_PACKET, *PBTC_NOTIFY_TYPE_SPECIFIC_PACKET;
+typedef enum _BTC_NOTIFY_TYPE_STACK_OPERATION {
+	BTC_STACK_OP_NONE					= 0x0,
+	BTC_STACK_OP_INQ_PAGE_PAIR_START		= 0x1,
+	BTC_STACK_OP_INQ_PAGE_PAIR_FINISH	= 0x2,
+	BTC_STACK_OP_MAX
+} BTC_NOTIFY_TYPE_STACK_OPERATION, *PBTC_NOTIFY_TYPE_STACK_OPERATION;
+
+typedef enum _BTC_LINK_CHANGE_TYPE{
+	BTC_LINK_CHANGE_TYPE_NONE			= 0x0,
+	BTC_LINK_CHANGE_TYPE_ECSA_START		= 0x1,
+	BTC_LINK_CHANGE_TYPE_ECSA_DONE		= 0x2,
+	BTC_LINK_CHANGE_TYPE_MAX
+}BTC_LINK_CHANGE_TYPE,*PBTC_LINK_CHANGE_TYPE;
+
+/* Bryant Add */
+typedef enum _BTC_ANTENNA_POS {
+	BTC_ANTENNA_AT_MAIN_PORT				= 0x1,
+	BTC_ANTENNA_AT_AUX_PORT				= 0x2,
+} BTC_ANTENNA_POS, *PBTC_ANTENNA_POS;
+
+/* Bryant Add */
+typedef enum _BTC_BT_OFFON {
+	BTC_BT_OFF				= 0x0,
+	BTC_BT_ON				= 0x1,
+} BTC_BTOFFON, *PBTC_BT_OFFON;
+
+#define BTC_5G_BAND 0x80
+
+/*==================================================
+For following block is for coex offload
+==================================================*/
+typedef struct _COL_H2C {
+	u1Byte	opcode;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	buf[1];
+} COL_H2C, *PCOL_H2C;
+
+#define	COL_C2H_ACK_HDR_LEN	3
+typedef struct _COL_C2H_ACK {
+	u1Byte	status;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	ret_len;
+	u1Byte	buf[1];
+} COL_C2H_ACK, *PCOL_C2H_ACK;
+
+#define	COL_C2H_IND_HDR_LEN	3
+typedef struct _COL_C2H_IND {
+	u1Byte	type;
+	u1Byte	version;
+	u1Byte	length;
+	u1Byte	data[1];
+} COL_C2H_IND, *PCOL_C2H_IND;
+
+/*============================================
+NOTE: for debug message, the following define should match
+the strings in coexH2cResultString.
+============================================*/
+typedef enum _COL_H2C_STATUS {
+	/* c2h status */
+	COL_STATUS_C2H_OK								= 0x00, /* Wifi received H2C request and check content ok. */
+	COL_STATUS_C2H_UNKNOWN							= 0x01,	/* Not handled routine */
+	COL_STATUS_C2H_UNKNOWN_OPCODE					= 0x02,	/* Invalid OP code, It means that wifi firmware received an undefiend OP code. */
+	COL_STATUS_C2H_OPCODE_VER_MISMATCH			= 0x03, /* Wifi firmware and wifi driver mismatch, need to update wifi driver or wifi or. */
+	COL_STATUS_C2H_PARAMETER_ERROR				= 0x04, /* Error paraneter.(ex: parameters = NULL but it should have values) */
+	COL_STATUS_C2H_PARAMETER_OUT_OF_RANGE		= 0x05, /* Wifi firmware needs to check the parameters from H2C request and return the status.(ex: ch = 500, it's wrong) */
+	/* other COL status start from here */
+	COL_STATUS_C2H_REQ_NUM_MISMATCH			, /* c2h req_num mismatch, means this c2h is not we expected. */
+	COL_STATUS_H2C_HALMAC_FAIL					, /* HALMAC return fail. */
+	COL_STATUS_H2C_TIMTOUT						, /* not received the c2h response from fw */
+	COL_STATUS_INVALID_C2H_LEN					, /* invalid coex offload c2h ack length, must >= 3 */
+	COL_STATUS_COEX_DATA_OVERFLOW				, /* coex returned length over the c2h ack length. */
+	COL_STATUS_MAX
+} COL_H2C_STATUS, *PCOL_H2C_STATUS;
+
+#define	COL_MAX_H2C_REQ_NUM		16
+
+#define	COL_H2C_BUF_LEN			20
+typedef enum _COL_OPCODE {
+	COL_OP_WIFI_STATUS_NOTIFY					= 0x0,
+	COL_OP_WIFI_PROGRESS_NOTIFY					= 0x1,
+	COL_OP_WIFI_INFO_NOTIFY						= 0x2,
+	COL_OP_WIFI_POWER_STATE_NOTIFY				= 0x3,
+	COL_OP_SET_CONTROL							= 0x4,
+	COL_OP_GET_CONTROL							= 0x5,
+	COL_OP_WIFI_OPCODE_MAX
+} COL_OPCODE, *PCOL_OPCODE;
+
+typedef enum _COL_IND_TYPE {
+	COL_IND_BT_INFO								= 0x0,
+	COL_IND_PSTDMA								= 0x1,
+	COL_IND_LIMITED_TX_RX						= 0x2,
+	COL_IND_COEX_TABLE							= 0x3,
+	COL_IND_REQ									= 0x4,
+	COL_IND_MAX
+} COL_IND_TYPE, *PCOL_IND_TYPE;
+
+typedef struct _COL_SINGLE_H2C_RECORD {
+	u1Byte					h2c_buf[COL_H2C_BUF_LEN];	/* the latest sent h2c buffer */
+	u4Byte					h2c_len;
+	u1Byte					c2h_ack_buf[COL_H2C_BUF_LEN];	/* the latest received c2h buffer */
+	u4Byte					c2h_ack_len;
+	u4Byte					count;									/* the total number of the sent h2c command */
+	u4Byte					status[COL_STATUS_MAX];					/* the c2h status for the sent h2c command */
+} COL_SINGLE_H2C_RECORD, *PCOL_SINGLE_H2C_RECORD;
+
+typedef struct _COL_SINGLE_C2H_IND_RECORD {
+	u1Byte					ind_buf[COL_H2C_BUF_LEN];	/* the latest received c2h indication buffer */
+	u4Byte					ind_len;
+	u4Byte					count;									/* the total number of the rcvd c2h indication */
+	u4Byte					status[COL_STATUS_MAX];					/* the c2h indication verified status */
+} COL_SINGLE_C2H_IND_RECORD, *PCOL_SINGLE_C2H_IND_RECORD;
+
+typedef struct _BTC_OFFLOAD {
+	/* H2C command related */
+	u1Byte					h2c_req_num;
+	u4Byte					cnt_h2c_sent;
+	COL_SINGLE_H2C_RECORD	h2c_record[COL_OP_WIFI_OPCODE_MAX];
+
+	/* C2H Ack related */
+	u4Byte					cnt_c2h_ack;
+	u4Byte					status[COL_STATUS_MAX];
+	struct completion		c2h_event[COL_MAX_H2C_REQ_NUM];	/* for req_num = 1~COL_MAX_H2C_REQ_NUM */
+	u1Byte					c2h_ack_buf[COL_MAX_H2C_REQ_NUM][COL_H2C_BUF_LEN];
+	u1Byte					c2h_ack_len[COL_MAX_H2C_REQ_NUM];
+
+	/* C2H Indication related */
+	u4Byte						cnt_c2h_ind;
+	COL_SINGLE_C2H_IND_RECORD	c2h_ind_record[COL_IND_MAX];
+	u4Byte						c2h_ind_status[COL_STATUS_MAX];
+	u1Byte						c2h_ind_buf[COL_H2C_BUF_LEN];
+	u1Byte						c2h_ind_len;
+} BTC_OFFLOAD, *PBTC_OFFLOAD;
+extern BTC_OFFLOAD				gl_coex_offload;
+/*==================================================*/
+
+/* BTC_LINK_MODE same as WIFI_LINK_MODE */
+typedef enum _BTC_LINK_MODE{
+	BTC_LINK_NONE=0,
+	BTC_LINK_ONLY_GO,
+	BTC_LINK_ONLY_GC,
+	BTC_LINK_ONLY_STA,
+	BTC_LINK_ONLY_AP,
+	BTC_LINK_2G_MCC_GO_STA,
+	BTC_LINK_5G_MCC_GO_STA,
+	BTC_LINK_25G_MCC_GO_STA,
+	BTC_LINK_2G_MCC_GC_STA,
+	BTC_LINK_5G_MCC_GC_STA,
+	BTC_LINK_25G_MCC_GC_STA,
+	BTC_LINK_2G_SCC_GO_STA,
+	BTC_LINK_5G_SCC_GO_STA,
+	BTC_LINK_2G_SCC_GC_STA,
+	BTC_LINK_5G_SCC_GC_STA,
+	BTC_LINK_MAX=30
+}BTC_LINK_MODE, *PBTC_LINK_MODE;
+
+
+struct btc_wifi_link_info {
+	BTC_LINK_MODE link_mode; /* LinkMode */
+	u1Byte sta_center_channel; /* StaCenterChannel */
+	u1Byte p2p_center_channel; /* P2PCenterChannel	*/
+	BOOLEAN bany_client_join_go;
+	BOOLEAN benable_noa;
+	BOOLEAN bhotspot;
+};
+
+#if 0
+typedef enum _BTC_MULTI_PORT_TDMA_MODE {
+	BTC_MULTI_PORT_TDMA_MODE_NONE=0,
+	BTC_MULTI_PORT_TDMA_MODE_2G_SCC_GO,
+	BTC_MULTI_PORT_TDMA_MODE_2G_P2P_GO,
+	BTC_MULTI_PORT_TDMA_MODE_2G_HOTSPOT_GO
+} BTC_MULTI_PORT_TDMA_MODE, *PBTC_MULTI_PORT_TDMA_MODE;
+
+typedef struct btc_multi_port_tdma_info {
+	BTC_MULTI_PORT_TDMA_MODE btc_multi_port_tdma_mode;
+	u1Byte start_time_from_bcn;
+	u1Byte bt_time;
+} BTC_MULTI_PORT_TDMA_INFO, *PBTC_MULTI_PORT_TDMA_INFO;
+#endif
+
+typedef enum _btc_concurrent_mode {
+	btc_concurrent_mode_none = 0,
+	btc_concurrent_mode_2g_go_miracast,
+	btc_concurrent_mode_2g_go_hotspot,
+	btc_concurrent_mode_2g_scc_go_miracast_sta,
+	btc_concurrent_mode_2g_scc_go_hotspot_sta,
+	btc_concurrent_mode_2g_gc,
+} btc_concurrent_mode, *pbtc_concurrent_mode;
+
+struct btc_concurrent_setting {
+	btc_concurrent_mode btc_concurrent_mode;
+	u1Byte start_time_from_bcn;
+	u1Byte bt_time;
+};
+
+typedef u1Byte
+(*BFP_BTC_R1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u2Byte
+(*BFP_BTC_R2)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u4Byte
+(*BFP_BTC_R4)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef VOID
+(*BFP_BTC_W1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W1_BIT_MASK)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			regAddr,
+	IN	u1Byte			bitMask,
+	IN	u1Byte			data1b
+	);
+typedef VOID
+(*BFP_BTC_W2)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W4)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_LOCAL_REG_W1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef u4Byte
+(*BFP_BTC_R_LINDIRECT)(
+	IN 	PVOID			pBtcContext,
+	IN	u2Byte			reg_addr
+	);
+typedef u2Byte
+(*BFP_BTC_R_SCBD)(
+	IN 	PVOID			pBtcContext,
+	IN	pu2Byte			score_board_val
+	);
+typedef u4Byte
+(*BFP_BTC_R_SCBD_32BIT)(
+	IN 	PVOID			pBtcContext,
+	IN	pu4Byte			score_board_val
+	);
+typedef VOID
+(*BFP_BTC_W_SCBD)(
+	IN 	PVOID			pBtcContext,
+	IN	u2Byte			bitpos,
+	IN	BOOLEAN			state
+	);
+typedef VOID
+(*BFP_BTC_W_SCBD_32BIT)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			bitpos,
+	IN	BOOLEAN			state
+	);
+typedef VOID
+(*BFP_BTC_W_LINDIRECT)(
+	IN 	PVOID			pBtcContext,
+	IN	u2Byte			reg_addr,
+	IN	u4Byte			bit_mask,
+	IN	u4Byte 			reg_value
+	);
+typedef VOID
+(*BFP_BTC_SET_BB_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte
+(*BFP_BTC_GET_BB_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_SET_RF_REG)(
+	IN	PVOID			pBtcContext,
+	IN	enum rf_path		eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte
+(*BFP_BTC_GET_RF_REG)(
+	IN	PVOID			pBtcContext,
+	IN	enum rf_path		eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_FILL_H2C)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			elementId,
+	IN	u4Byte			cmdLen,
+	IN	pu1Byte			pCmdBuffer
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_GET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_SET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			setType,
+	OUT	PVOID			pInBuf
+	);
+typedef u2Byte
+(*BFP_BTC_SET_BT_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset,
+	IN	u4Byte			value
+	);
+typedef BOOLEAN
+(*BFP_BTC_SET_BT_ANT_DETECTION)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			txTime,
+	IN	u1Byte			btChnl
+	);
+
+typedef BOOLEAN
+(*BFP_BTC_SET_BT_TRX_MASK)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			bt_trx_mask
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset
+	);
+typedef VOID
+(*BFP_BTC_DISP_DBG_MSG)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			dispType
+	);
+
+typedef COL_H2C_STATUS
+(*BFP_BTC_COEX_H2C_PROCESS)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			opcode,
+	IN	u1Byte			opcode_ver,
+	IN	pu1Byte			ph2c_par,
+	IN	u1Byte			h2c_par_len
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_PHYDM_VERSION)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u1Byte
+(*BFP_BTC_SET_TIMER) 	(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte 			type,
+	IN	u4Byte			val
+	);
+
+typedef u4Byte
+(*BFP_BTC_SET_ATOMIC) 	(
+	IN	PVOID			pBtcContext,
+	IN	pu4Byte 		target,
+	IN	u4Byte			val
+	);
+
+
+typedef VOID
+(*BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD)(
+	IN	PVOID		pDM_Odm,
+	IN	u1Byte		RA_offset_direction,
+	IN	u1Byte		RA_threshold_offset
+	);
+
+typedef u4Byte
+(*BTC_PHYDM_CMNINFOQUERY)(
+	IN		PVOID	pDM_Odm,
+	IN		u1Byte	info_type
+	);
+
+typedef VOID
+(*BTC_REDUCE_WL_TX_POWER)(
+	IN		PVOID		pDM_Odm,
+	IN		s1Byte		tx_power
+	);
+
+typedef VOID
+(*BTC_PHYDM_MODIFY_ANTDIV_HWSW)(
+	IN		PVOID	pDM_Odm,
+	IN		u1Byte	type
+	);
+
+typedef u1Byte
+(*BFP_BTC_GET_ANT_DET_VAL_FROM_BT)(
+
+	IN	PVOID			pBtcContext
+	);
+
+typedef u1Byte
+(*BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT)(
+	IN	PVOID			pBtcContext,
+	IN  u1Byte			scanType
+	);
+
+typedef BOOLEAN
+(*BFP_BTC_GET_BT_AFH_MAP_FROM_BT)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			mapType,
+	OUT	pu1Byte			afhMap
+	);
+
+struct  btc_bt_info {
+	boolean					bt_disabled;
+	boolean				bt_enable_disable_change;
+	u8					rssi_adjust_for_agc_table_on;
+	u8					rssi_adjust_for_1ant_coex_type;
+	boolean					pre_bt_ctrl_agg_buf_size;
+	boolean					bt_ctrl_agg_buf_size;
+	boolean					pre_reject_agg_pkt;
+	boolean					reject_agg_pkt;
+	boolean					increase_scan_dev_num;
+	boolean					bt_tx_rx_mask;
+	u8					pre_agg_buf_size;
+	u8					agg_buf_size;
+	boolean					bt_busy;
+	boolean					limited_dig;
+	u16					bt_hci_ver;
+	u32					bt_real_fw_ver;
+	u32					get_bt_fw_ver_cnt;
+	u32					bt_get_fw_ver;
+	boolean					miracast_plus_bt;
+
+	boolean					bt_disable_low_pwr;
+
+	boolean					bt_ctrl_lps;
+	boolean					bt_lps_on;
+	boolean					force_to_roam;	/* for 1Ant solution */
+	u8					lps_val;
+	u8					rpwm_val;
+	u32					ra_mask;
+};
+
+struct btc_stack_info {
+	boolean					profile_notified;
+	u16					hci_version;	/* stack hci version */
+	u8					num_of_link;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					acl_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	u8					num_of_hid;
+	boolean					pan_exist;
+	boolean					unknown_acl_exist;
+	s8					min_bt_rssi;
+};
+
+struct btc_bt_link_info {
+	boolean					bt_link_exist;
+	boolean					bt_hi_pri_link_exist;
+	boolean					sco_exist;
+	boolean					sco_only;
+	boolean					a2dp_exist;
+	boolean					a2dp_only;
+	boolean					hid_exist;
+	boolean					hid_only;
+	boolean					pan_exist;
+	boolean					pan_only;
+	boolean					slave_role;
+	boolean					acl_busy;
+};
+
+#ifdef CONFIG_RF4CE_COEXIST
+struct btc_rf4ce_info {
+	u8					link_state;
+};
+#endif
+
+struct btc_statistics {
+	u32					cnt_bind;
+	u32					cnt_power_on;
+	u32					cnt_pre_load_firmware;
+	u32					cnt_init_hw_config;
+	u32					cnt_init_coex_dm;
+	u32					cnt_ips_notify;
+	u32					cnt_lps_notify;
+	u32					cnt_scan_notify;
+	u32					cnt_connect_notify;
+	u32					cnt_media_status_notify;
+	u32					cnt_specific_packet_notify;
+	u32					cnt_bt_info_notify;
+	u32					cnt_rf_status_notify;
+	u32					cnt_periodical;
+	u32					cnt_coex_dm_switch;
+	u32					cnt_stack_operation_notify;
+	u32					cnt_dbg_ctrl;
+	u32					cnt_rate_id_notify;
+	u32					cnt_halt_notify;
+	u32					cnt_pnp_notify;
+};
+
+struct btc_coexist {
+	BOOLEAN				bBinded;		/*make sure only one adapter can bind the data context*/
+	PVOID				Adapter;		/*default adapter*/
+	struct  btc_board_info		board_info;
+	struct  btc_bt_info			bt_info;		/*some bt info referenced by non-bt module*/
+	struct  btc_stack_info		stack_info;
+	struct  btc_bt_link_info		bt_link_info;
+	struct btc_wifi_link_info	wifi_link_info;
+	struct btc_wifi_link_info_ext		wifi_link_info_ext;
+	struct btc_coex_dm			coex_dm;
+	struct btc_coex_sta			coex_sta;
+	struct btc_rfe_type			rfe_type;
+	const struct btc_chip_para		*chip_para;
+	u8					wifi_black_bssid[6];
+	u8					wifi_bssid[6];
+
+#ifdef CONFIG_RF4CE_COEXIST
+	struct  btc_rf4ce_info		rf4ce_info;
+#endif
+	BTC_CHIP_INTERFACE		chip_interface;
+	PVOID					odm_priv;
+
+	BOOLEAN					initilized;
+	BOOLEAN					stop_coex_dm;
+	BOOLEAN					manual_control;
+	BOOLEAN					bdontenterLPS;
+	pu1Byte					cli_buf;
+	struct btc_statistics		statistics;
+	u1Byte				pwrModeVal[10];
+	BOOLEAN dbg_mode;
+	BOOLEAN auto_report;
+	u8	chip_type;
+	BOOLEAN wl_rf_state_off;
+
+	/* function pointers */
+	/* io related */
+	BFP_BTC_R1			btc_read_1byte;
+	BFP_BTC_W1			btc_write_1byte;
+	BFP_BTC_W1_BIT_MASK	btc_write_1byte_bitmask;
+	BFP_BTC_R2			btc_read_2byte;
+	BFP_BTC_W2			btc_write_2byte;
+	BFP_BTC_R4			btc_read_4byte;
+	BFP_BTC_W4			btc_write_4byte;
+	BFP_BTC_LOCAL_REG_W1	btc_write_local_reg_1byte;
+	BFP_BTC_R_LINDIRECT		btc_read_linderct;
+	BFP_BTC_W_LINDIRECT		btc_write_linderct;
+	BFP_BTC_R_SCBD			btc_read_scbd;
+	BFP_BTC_R_SCBD_32BIT	btc_read_scbd_32bit;
+	BFP_BTC_W_SCBD			btc_write_scbd;
+	BFP_BTC_W_SCBD_32BIT	btc_write_scbd_32bit;
+
+	/* read/write bb related */
+	BFP_BTC_SET_BB_REG	btc_set_bb_reg;
+	BFP_BTC_GET_BB_REG	btc_get_bb_reg;
+
+	/* read/write rf related */
+	BFP_BTC_SET_RF_REG	btc_set_rf_reg;
+	BFP_BTC_GET_RF_REG	btc_get_rf_reg;
+
+	/* fill h2c related */
+	BFP_BTC_FILL_H2C		btc_fill_h2c;
+	/* other */
+	BFP_BTC_DISP_DBG_MSG	btc_disp_dbg_msg;
+	/* normal get/set related */
+	BFP_BTC_GET			btc_get;
+	BFP_BTC_SET			btc_set;
+
+	BFP_BTC_GET_BT_REG	btc_get_bt_reg;
+	BFP_BTC_SET_BT_REG	btc_set_bt_reg;
+
+	BFP_BTC_SET_BT_ANT_DETECTION	btc_set_bt_ant_detection;
+
+	BFP_BTC_COEX_H2C_PROCESS	btc_coex_h2c_process;
+	BFP_BTC_SET_BT_TRX_MASK		btc_set_bt_trx_mask;
+	BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE btc_get_bt_coex_supported_feature;
+	BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION btc_get_bt_coex_supported_version;
+	BFP_BTC_GET_PHYDM_VERSION		btc_get_bt_phydm_version;
+	BFP_BTC_SET_TIMER				btc_set_timer;
+	BFP_BTC_SET_ATOMIC			btc_set_atomic;
+	BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD	btc_phydm_modify_RA_PCR_threshold;
+	BTC_PHYDM_CMNINFOQUERY				btc_phydm_query_PHY_counter;
+	BTC_REDUCE_WL_TX_POWER				btc_reduce_wl_tx_power;
+	BTC_PHYDM_MODIFY_ANTDIV_HWSW		btc_phydm_modify_antdiv_hwsw;
+	BFP_BTC_GET_ANT_DET_VAL_FROM_BT		btc_get_ant_det_val_from_bt;
+	BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT	btc_get_ble_scan_type_from_bt;
+	BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT	btc_get_ble_scan_para_from_bt;
+	BFP_BTC_GET_BT_AFH_MAP_FROM_BT		btc_get_bt_afh_map_from_bt;
+
+	union {
+		#ifdef CONFIG_RTL8822B
+		struct coex_dm_8822b_1ant	coex_dm_8822b_1ant;
+		struct coex_dm_8822b_2ant	coex_dm_8822b_2ant;
+		#endif /* 8822B */
+		#ifdef CONFIG_RTL8821C
+		struct coex_dm_8821c_1ant	coex_dm_8821c_1ant;
+		struct coex_dm_8821c_2ant	coex_dm_8821c_2ant;
+		#endif /* 8821C */
+        #ifdef CONFIG_RTL8723D
+        struct coex_dm_8723d_1ant   coex_dm_8723d_1ant;
+        struct coex_dm_8723d_2ant   coex_dm_8723d_2ant;
+        #endif /* 8723D */
+	};
+
+	union {
+		#ifdef CONFIG_RTL8822B
+		struct coex_sta_8822b_1ant	coex_sta_8822b_1ant;
+		struct coex_sta_8822b_2ant	coex_sta_8822b_2ant;
+		#endif /* 8822B */
+		#ifdef CONFIG_RTL8821C
+		struct coex_sta_8821c_1ant	coex_sta_8821c_1ant;
+		struct coex_sta_8821c_2ant	coex_sta_8821c_2ant;
+		#endif /* 8821C */
+        #ifdef CONFIG_RTL8723D
+        struct coex_sta_8723d_1ant  coex_sta_8723d_1ant;
+        struct coex_sta_8723d_2ant  coex_sta_8723d_2ant;
+        #endif /* 8723D */
+	};
+
+	union {
+		#ifdef CONFIG_RTL8822B
+		struct rfe_type_8822b_1ant	rfe_type_8822b_1ant;
+		struct rfe_type_8822b_2ant	rfe_type_8822b_2ant;
+		#endif /* 8822B */
+		#ifdef CONFIG_RTL8821C
+		struct rfe_type_8821c_1ant	rfe_type_8821c_1ant;
+		struct rfe_type_8821c_2ant	rfe_type_8821c_2ant;
+		#endif /* 8821C */
+	};
+
+	union {
+		#ifdef CONFIG_RTL8822B
+		struct wifi_link_info_8822b_1ant	wifi_link_info_8822b_1ant;
+		struct wifi_link_info_8822b_2ant	wifi_link_info_8822b_2ant;
+		#endif /* 8822B */
+		#ifdef CONFIG_RTL8821C
+		struct wifi_link_info_8821c_1ant	wifi_link_info_8821c_1ant;
+		struct wifi_link_info_8821c_2ant	wifi_link_info_8821c_2ant;
+		#endif /* 8821C */
+	};
+
+};
+typedef struct btc_coexist *PBTC_COEXIST;
+
+extern struct btc_coexist	GLBtCoexist;
+
+typedef	void
+(*BFP_BTC_CHIP_SETUP)(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u1Byte			setType
+	);
+
+struct btc_chip_para {
+	const char				*chip_name;
+	u32				para_ver_date;
+	u32				para_ver;
+	u32				bt_desired_ver;
+	boolean			scbd_support;
+	u32				scbd_reg;
+	u8				scbd_bit_num;
+	boolean			mailbox_support;
+	boolean			lte_indirect_access;
+	boolean			new_scbd10_def; /* TRUE: 1:fix 2M(8822c) */
+	u8				indirect_type;	/* 0:17xx, 1:7cx */
+	u8				pstdma_type; /* 0: LPSoff, 1:LPSon */
+	u8				bt_rssi_type;
+	u8				ant_isolation;
+	u8				rssi_tolerance;
+	u8				rx_path_num;
+	u8				wl_rssi_step_num;
+	const u8				*wl_rssi_step;
+	u8				bt_rssi_step_num;
+	const u8				*bt_rssi_step;
+	u8				table_sant_num;
+	const struct btc_coex_table_para 	*table_sant;
+	u8				table_nsant_num;
+	const struct btc_coex_table_para 	*table_nsant;
+	u8				tdma_sant_num;
+	const struct btc_tdma_para 	*tdma_sant;
+	u8				tdma_nsant_num;
+	const struct btc_tdma_para 	*tdma_nsant;
+	u8				wl_rf_para_tx_num;
+	const struct btc_rf_para		*wl_rf_para_tx;
+	const struct btc_rf_para		*wl_rf_para_rx;
+	u8				bt_afh_span_bw20;
+	u8				bt_afh_span_bw40;
+	u8				afh_5g_num;
+	const struct btc_5g_afh_map	*afh_5g;
+	BFP_BTC_CHIP_SETUP		chip_setup;
+};
+
+BOOLEAN
+EXhalbtcoutsrc_InitlizeVariables(
+	IN	PVOID		Adapter
+	);
+VOID
+EXhalbtcoutsrc_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtcoutsrc_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_SetAntennaPathNotify(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			action
+	);
+VOID
+EXhalbtcoutsrc_MediaStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	RT_MEDIA_STATUS	mediaStatus
+	);
+VOID
+EXhalbtcoutsrc_SpecificPacketNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pktType
+	);
+VOID
+EXhalbtcoutsrc_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				type
+	);
+u4Byte
+EXhalbtcoutsrc_CoexTimerCheck(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+u4Byte
+EXhalbtcoutsrc_WLStatusCheck(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_WlFwDbgInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtcoutsrc_rx_rate_change_notify(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN 	BOOLEAN			is_data_frame,
+	IN	u1Byte			btc_rate_id
+	);
+VOID
+EXhalbtcoutsrc_StackOperationNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_HaltNotify(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PnpNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pnpState
+	);
+VOID
+EXhalbtcoutsrc_TimerNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u4Byte timer_type
+);
+VOID
+EXhalbtcoutsrc_WLStatusChangeNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u4Byte change_type
+);
+VOID
+EXhalbtcoutsrc_WL_RFK_Notify(
+	IN	PBTC_COEXIST 		pBtCoexist,
+	IN	u1Byte			path,
+	IN	u1Byte			type,
+	IN	u1Byte			state
+	);
+VOID
+EXhalbtcoutsrc_CoexDmSwitch(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_Periodical(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DbgControl(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				opCode,
+	IN	u1Byte				opLen,
+	IN	pu1Byte				pData
+	);
+VOID
+EXhalbtcoutsrc_AntennaDetection(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u4Byte					centFreq,
+	IN	u4Byte					offset,
+	IN	u4Byte					span,
+	IN	u4Byte					seconds
+	);
+VOID
+EXhalbtcoutsrc_StackUpdateProfileInfo(
+	VOID
+	);
+VOID
+EXhalbtcoutsrc_SetHciVersion(
+	IN	u2Byte	hciVersion
+	);
+VOID
+EXhalbtcoutsrc_SetBtPatchVersion(
+	IN	u2Byte	btHciVersion,
+	IN	u2Byte	btPatchVersion
+	);
+VOID
+EXhalbtcoutsrc_UpdateMinBtRssi(
+	IN	s1Byte	btRssi
+	);
+#if 0
+VOID
+EXhalbtcoutsrc_SetBtExist(
+	IN	BOOLEAN		bBtExist
+	);
+#endif
+VOID
+EXhalbtcoutsrc_SetChipType(
+	IN	u1Byte		chipType
+	);
+VOID
+EXhalbtcoutsrc_SetAntNum(
+	IN	u1Byte		type,
+	IN	u1Byte		antNum
+	);
+VOID
+EXhalbtcoutsrc_SetSingleAntPath(
+	IN	u1Byte		singleAntPath
+	);
+VOID
+EXhalbtcoutsrc_DisplayBtCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DisplayAntDetection(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
+#define	MASKBYTE0		0xff
+#define	MASKBYTE1		0xff00
+#define	MASKBYTE2		0xff0000
+#define	MASKBYTE3		0xff000000
+#define	MASKHWORD	0xffff0000
+#define	MASKLWORD		0x0000ffff
+#define	MASKDWORD	0xffffffff
+#define	MASK12BITS		0xfff
+#define	MASKH4BITS		0xf0000000
+#define	MASKOFDM_D	0xffc00000
+#define	MASKCCK		0x3f3f3f3f
+
+#endif
diff -Naur /hal/btc/mp_precomp.h /hal/btc/mp_precomp.h
--- /hal/btc/mp_precomp.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/btc/mp_precomp.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef __MP_PRECOMP_H__
+#define __MP_PRECOMP_H__
+
+#include <drv_types.h>
+#include <hal_data.h>
+#include "btc_basic_types.h"
+
+#define BT_TMP_BUF_SIZE	100
+
+#ifdef PLATFORM_LINUX
+#define rsprintf snprintf
+#define rstrncat(dst, src, src_size) strncat(dst, src, src_size)
+#elif defined(PLATFORM_WINDOWS)
+#define rsprintf sprintf_s
+#endif
+
+#define DCMD_Printf			DBG_BT_INFO
+
+#define delay_ms(ms)		rtw_mdelay_os(ms)
+
+#ifdef bEnable
+#undef bEnable
+#endif
+
+#define WPP_SOFTWARE_TRACE 0
+
+typedef enum _BTC_MSG_COMP_TYPE {
+	COMP_COEX		= 0,
+	COMP_MAX
+} BTC_MSG_COMP_TYPE;
+extern u4Byte GLBtcDbgType[];
+
+#define DBG_OFF			0
+#define DBG_SEC			1
+#define DBG_SERIOUS		2
+#define DBG_WARNING		3
+#define DBG_LOUD		4
+#define DBG_TRACE		5
+
+#ifdef CONFIG_BT_COEXIST
+#define BT_SUPPORT		1
+#define COEX_SUPPORT	1
+#define HS_SUPPORT		1
+#else
+#define BT_SUPPORT		0
+#define COEX_SUPPORT	0
+#define HS_SUPPORT		0
+#endif
+
+/* for wifi only mode */
+#include "hal_btcoex_wifionly.h"
+
+#ifdef CONFIG_BT_COEXIST
+#define BTC_BTINFO_LENGTH_MAX 10
+
+struct wifi_only_cfg;
+struct btc_coexist;
+
+#ifdef CONFIG_RTL8192E
+#include "halbtc8192e1ant.h"
+#include "halbtc8192e2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8723B
+#include "halbtc8723bwifionly.h"
+#include "halbtc8723b1ant.h"
+#include "halbtc8723b2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8812A
+#include "halbtc8812a1ant.h"
+#include "halbtc8812a2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8821A
+#include "halbtc8821a1ant.h"
+#include "halbtc8821a2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8703B
+#include "halbtc8703b1ant.h"
+#endif
+
+#ifdef CONFIG_RTL8723D
+#include "halbtc8723d1ant.h"
+#include "halbtc8723d2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8822B
+#include "halbtc8822bwifionly.h"
+#include "halbtc8822b1ant.h"
+#include "halbtc8822b2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8821C
+#include "halbtc8821cwifionly.h"
+#include "halbtc8821c1ant.h"
+#include "halbtc8821c2ant.h"
+#endif
+
+#ifdef CONFIG_RTL8814A
+#include "halbtc8814a2ant.h"
+#endif
+
+#if (CONFIG_BTCOEX_SUPPORT_BTC_CMN == 1)
+#include "halbtccommon.h"
+
+#ifdef CONFIG_RTL8822C
+#include "halbtc8822cwifionly.h"
+#include "halbtc8822c.h"
+#endif
+
+#ifdef CONFIG_RTL8723F
+#include "halbtc8723fwifionly.h"
+#include "halbtc8723f.h"
+#endif
+
+#ifdef CONFIG_RTL8192F
+#include "halbtc8192f.h"
+#endif
+
+#endif
+
+#include "halbtcoutsrc.h"
+
+#else /* CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_RTL8723B
+#include "halbtc8723bwifionly.h"
+#endif
+
+#ifdef CONFIG_RTL8822B
+#include "halbtc8822bwifionly.h"
+#endif
+
+#ifdef CONFIG_RTL8821C
+#include "halbtc8821cwifionly.h"
+#endif
+
+#ifdef CONFIG_RTL8822C
+#include "halbtc8822cwifionly.h"
+#endif
+
+#ifdef CONFIG_RTL8723F
+#include "halbtc8723fwifionly.h"
+#endif
+
+#ifdef CONFIG_RTL8814B
+#include "halbtc8814bwifionly.h"
+#endif
+
+#endif /* CONFIG_BT_COEXIST */
+
+#endif /*  __MP_PRECOMP_H__ */
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.c /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.c
--- /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,311 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "../../phydm_precomp.h"
+
+/*---------------------------Define Local Constant---------------------------*/
+/* 2010/04/25 MH Define the max tx power tracking tx agc power. */
+#define ODM_TXPWRTRACK_MAX_IDX8821A 6
+
+/*---------------------------Define Local Constant---------------------------*/
+
+/* 3 ============================================================
+ * 3 Tx Power Tracking
+ * 3 ============================================================
+ */
+void halrf_rf_lna_setting_8821a(struct dm_struct *dm, enum halrf_lna_set type)
+{
+	/*phydm_disable_lna*/
+	if (type == HALRF_LNA_DISABLE) {
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x1);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x30, 0xfffff, 0x18000); /*select Rx mode*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x31, 0xfffff, 0x0002f);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x32, 0xfffff, 0xfb09b); /*disable LNA*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x0);
+	} else if (type == HALRF_LNA_ENABLE) {
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x1);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x30, 0xfffff, 0x18000); /*select Rx mode*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x31, 0xfffff, 0x0002f);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x32, 0xfffff, 0xfb0bb); /*disable LNA*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x0);
+	}
+}
+void odm_tx_pwr_track_set_pwr8821a(void *dm_void, enum pwrtrack_method method,
+				   u8 rf_path, u8 channel_mapped_index)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+	struct _ADAPTER *adapter = dm->adapter;
+	PHAL_DATA_TYPE hal_data = GET_HAL_DATA(adapter);
+
+	u8 pwr_tracking_limit = 26; /* +1.0dB */
+	u8 tx_rate = 0xFF;
+	u8 final_ofdm_swing_index = 0;
+	u8 final_cck_swing_index = 0;
+	u8 i = 0;
+	u32 final_bb_swing_idx[1];
+	struct dm_rf_calibration_struct *cali_info = &(dm->rf_calibrate_info);
+	struct _hal_rf_ *rf = &(dm->rf_table);
+
+	if (*dm->mp_mode == true) {
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (MP_DRIVER == 1)
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#ifdef CONFIG_MP_INCLUDED
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mppriv.mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#endif
+#endif
+	} else {
+		u16 rate = *(dm->forced_data_rate);
+
+		if (!rate) { /*auto rate*/
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+			tx_rate = adapter->HalFunc.GetHwRateFromMRateHandler(dm->tx_rate);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+			if (dm->number_linked_client != 0)
+				tx_rate = hw_rate_to_m_rate(dm->tx_rate);
+			else
+				tx_rate = rf->p_rate_index;
+#endif
+		} else /*force rate*/
+			tx_rate = (u8)rate;
+	}
+
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "Power Tracking tx_rate=0x%X\n",
+	       tx_rate);
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "===>%s\n", __func__);
+
+	if (tx_rate != 0xFF) {
+		/* 2 CCK */
+		if ((tx_rate >= MGN_1M && tx_rate <= MGN_5_5M) || tx_rate == MGN_11M)
+			pwr_tracking_limit = 32; /* +4dB */
+		/* 2 OFDM */
+		else if ((tx_rate >= MGN_6M) && (tx_rate <= MGN_48M))
+			pwr_tracking_limit = 30; /* +3dB */
+		else if (tx_rate == MGN_54M)
+			pwr_tracking_limit = 28; /* +2dB */
+		/* 2 HT */
+		else if ((tx_rate >= MGN_MCS0) && (tx_rate <= MGN_MCS2)) /* QPSK/BPSK */
+			pwr_tracking_limit = 34; /* +5dB */
+		else if ((tx_rate >= MGN_MCS3) && (tx_rate <= MGN_MCS4)) /* 16QAM */
+			pwr_tracking_limit = 30; /* +3dB */
+		else if ((tx_rate >= MGN_MCS5) && (tx_rate <= MGN_MCS7)) /* 64QAM */
+			pwr_tracking_limit = 28; /* +2dB */
+
+		/* 2 VHT */
+		else if ((tx_rate >= MGN_VHT1SS_MCS0) && (tx_rate <= MGN_VHT1SS_MCS2)) /* QPSK/BPSK */
+			pwr_tracking_limit = 34; /* +5dB */
+		else if ((tx_rate >= MGN_VHT1SS_MCS3) && (tx_rate <= MGN_VHT1SS_MCS4)) /* 16QAM */
+			pwr_tracking_limit = 30; /* +3dB */
+		else if ((tx_rate >= MGN_VHT1SS_MCS5) && (tx_rate <= MGN_VHT1SS_MCS6)) /* 64QAM */
+			pwr_tracking_limit = 28; /* +2dB */
+		else if (tx_rate == MGN_VHT1SS_MCS7) /* 64QAM */
+			pwr_tracking_limit = 26; /* +1dB */
+		else if (tx_rate == MGN_VHT1SS_MCS8) /* 256QAM */
+			pwr_tracking_limit = 24; /* +0dB */
+		else if (tx_rate == MGN_VHT1SS_MCS9) /* 256QAM */
+			pwr_tracking_limit = 22; /* -1dB */
+
+		else
+			pwr_tracking_limit = 24;
+	}
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "tx_rate=0x%x, pwr_tracking_limit=%d\n",
+	       tx_rate, pwr_tracking_limit);
+
+	if (method == BBSWING) {
+		if (rf_path == RF_PATH_A) {
+			final_bb_swing_idx[RF_PATH_A] = (dm->rf_calibrate_info.OFDM_index[RF_PATH_A] > pwr_tracking_limit) ? pwr_tracking_limit : dm->rf_calibrate_info.OFDM_index[RF_PATH_A];
+			RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
+			       "dm->rf_calibrate_info.OFDM_index[RF_PATH_A]=%d, dm->RealBbSwingIdx[RF_PATH_A]=%d\n",
+			       dm->rf_calibrate_info.OFDM_index[RF_PATH_A],
+			       final_bb_swing_idx[RF_PATH_A]);
+
+			odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[final_bb_swing_idx[RF_PATH_A]]);
+		}
+	} else if (method == MIX_MODE) {
+		RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
+		       "cali_info->default_ofdm_index=%d, cali_info->absolute_ofdm_swing_idx[rf_path]=%d, rf_path = %d\n",
+		       cali_info->default_ofdm_index,
+		       cali_info->absolute_ofdm_swing_idx[rf_path], rf_path);
+
+		final_cck_swing_index = cali_info->default_cck_index + cali_info->absolute_ofdm_swing_idx[rf_path];
+		final_ofdm_swing_index = cali_info->default_ofdm_index + cali_info->absolute_ofdm_swing_idx[rf_path];
+
+		if (rf_path == RF_PATH_A) {
+			if (final_ofdm_swing_index > pwr_tracking_limit) { /*BBSwing higher then Limit*/
+				cali_info->remnant_cck_swing_idx = final_cck_swing_index - pwr_tracking_limit;
+				cali_info->remnant_ofdm_swing_idx[rf_path] = final_ofdm_swing_index - pwr_tracking_limit;
+
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[pwr_tracking_limit]);
+
+				cali_info->modify_tx_agc_flag_path_a = true;
+
+				phy_set_tx_power_level_by_path(adapter, *dm->channel, RF_PATH_A);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
+				       "******Path_A Over BBSwing Limit, pwr_tracking_limit = %d, Remnant tx_agc value = %d\n",
+				       pwr_tracking_limit,
+				       cali_info->remnant_ofdm_swing_idx[rf_path
+				       ]);
+			} else if (final_ofdm_swing_index <= 0) {
+				cali_info->remnant_cck_swing_idx = final_cck_swing_index;
+				cali_info->remnant_ofdm_swing_idx[rf_path] = final_ofdm_swing_index;
+
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[0]);
+
+				cali_info->modify_tx_agc_flag_path_a = true;
+
+				phy_set_tx_power_level_by_path(adapter, *dm->channel, RF_PATH_A);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
+				       "******Path_A Lower then BBSwing lower bound  0, Remnant tx_agc value = %d\n",
+				       cali_info->remnant_ofdm_swing_idx[rf_path
+				       ]);
+			} else {
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[final_ofdm_swing_index]);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
+				       "******Path_A Compensate with BBSwing, final_ofdm_swing_index = %d\n",
+				       final_ofdm_swing_index);
+
+				if (cali_info->modify_tx_agc_flag_path_a) { /*If tx_agc has changed, reset tx_agc again*/
+					cali_info->remnant_cck_swing_idx = 0;
+					cali_info->remnant_ofdm_swing_idx[rf_path] = 0;
+
+					phy_set_tx_power_level_by_path(adapter, *dm->channel, RF_PATH_A);
+
+					cali_info->modify_tx_agc_flag_path_a = false;
+
+					RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "******Path_A dm->Modify_TxAGC_Flag = false\n");
+				}
+			}
+		}
+	} else
+		return;
+} /* odm_TxPwrTrackSetPwr88E */
+
+void get_delta_swing_table_8821a(void *dm_void, u8 **temperature_up_a,
+				 u8 **temperature_down_a, u8 **temperature_up_b,
+				 u8 **temperature_down_b)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+	struct _ADAPTER *adapter = dm->adapter;
+	struct dm_rf_calibration_struct *cali_info = &(dm->rf_calibrate_info);
+	struct _hal_rf_ *rf = &(dm->rf_table);
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	u8 tx_rate = 0xFF;
+	u8 channel = *dm->channel;
+
+	if (*dm->mp_mode == true) {
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (MP_DRIVER == 1)
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#ifdef CONFIG_MP_INCLUDED
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mppriv.mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#endif
+#endif
+	} else {
+		u16 rate = *(dm->forced_data_rate);
+
+		if (!rate) { /*auto rate*/
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+			tx_rate = adapter->HalFunc.GetHwRateFromMRateHandler(dm->tx_rate);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+			if (dm->number_linked_client != 0)
+				tx_rate = hw_rate_to_m_rate(dm->tx_rate);
+			else
+				tx_rate = rf->p_rate_index;
+#endif
+		} else /*force rate*/
+			tx_rate = (u8)rate;
+	}
+
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "Power Tracking tx_rate=0x%X\n",
+	       tx_rate);
+
+	if (1 <= channel && channel <= 14) {
+		if (IS_CCK_RATE(tx_rate)) {
+			*temperature_up_a = cali_info->delta_swing_table_idx_2g_cck_a_p;
+			*temperature_down_a = cali_info->delta_swing_table_idx_2g_cck_a_n;
+			*temperature_up_b = cali_info->delta_swing_table_idx_2g_cck_b_p;
+			*temperature_down_b = cali_info->delta_swing_table_idx_2g_cck_b_n;
+		} else {
+			*temperature_up_a = cali_info->delta_swing_table_idx_2ga_p;
+			*temperature_down_a = cali_info->delta_swing_table_idx_2ga_n;
+			*temperature_up_b = cali_info->delta_swing_table_idx_2gb_p;
+			*temperature_down_b = cali_info->delta_swing_table_idx_2gb_n;
+		}
+	} else if (36 <= channel && channel <= 64) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[0];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[0];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[0];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[0];
+	} else if (100 <= channel && channel <= 144) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[1];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[1];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[1];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[1];
+	} else if (149 <= channel && channel <= 177) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[2];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[2];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[2];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[2];
+	} else {
+		*temperature_up_a = (u8 *)delta_swing_table_idx_2ga_p_8188e;
+		*temperature_down_a = (u8 *)delta_swing_table_idx_2ga_n_8188e;
+		*temperature_up_b = (u8 *)delta_swing_table_idx_2ga_p_8188e;
+		*temperature_down_b = (u8 *)delta_swing_table_idx_2ga_n_8188e;
+	}
+
+	return;
+}
+
+void configure_txpower_track_8821a(struct txpwrtrack_cfg *config)
+{
+	config->swing_table_size_cck = TXSCALE_TABLE_SIZE;
+	config->swing_table_size_ofdm = TXSCALE_TABLE_SIZE;
+	config->threshold_iqk = IQK_THRESHOLD;
+	config->average_thermal_num = AVG_THERMAL_NUM_8812A;
+	config->rf_path_count = MAX_PATH_NUM_8821A;
+	config->thermal_reg_addr = RF_T_METER_8812A;
+
+	config->odm_tx_pwr_track_set_pwr = odm_tx_pwr_track_set_pwr8821a;
+	config->do_iqk = do_iqk_8821a;
+	config->phy_lc_calibrate = halrf_lck_trigger;
+	config->get_delta_swing_table = get_delta_swing_table_8821a;
+}
+
+void phy_lc_calibrate_8821a(void *dm_void)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+
+	phy_lc_calibrate_8812a(dm);
+}
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.h /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.h
--- /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_8821a_ce.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#ifndef __HALRF_8821A_H__
+#define __HALRF_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+void configure_txpower_track_8821a(struct txpwrtrack_cfg *config);
+
+void odm_tx_pwr_track_set_pwr8821a(void *dm_void, enum pwrtrack_method method,
+				   u8 rf_path, u8 channel_mapped_index);
+
+void phy_lc_calibrate_8821a(void *dm_void);
+
+void get_delta_swing_table_8821a(void *dm_void, u8 **temperature_up_a,
+				 u8 **temperature_down_a, u8 **temperature_up_b,
+				 u8 **temperature_down_b);
+
+void halrf_rf_lna_setting_8821a(struct dm_struct *dm, enum halrf_lna_set type);
+
+#endif /*#ifndef __HALRF_8821A_H__*/
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_8821a_win.c /hal/phydm/halrf/rtl8821a/halrf_8821a_win.c
--- /hal/phydm/halrf/rtl8821a/halrf_8821a_win.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_8821a_win.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,1050 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+
+#if RT_PLATFORM==PLATFORM_MACOSX
+#include "phydm_precomp.h"
+#else
+#include "../phydm_precomp.h"
+#endif
+
+#if (RTL8821A_SUPPORT == 1)
+
+/*---------------------------Define Local Constant---------------------------*/
+/* 2010/04/25 MH Define the max tx power tracking tx agc power. */
+#define		ODM_TXPWRTRACK_MAX_IDX8821A		6
+
+/*---------------------------Define Local Constant---------------------------*/
+
+
+/* 3 ============================================================
+ * 3 Tx Power Tracking
+ * 3 ============================================================ */
+
+void halrf_rf_lna_setting_8821a(
+		struct dm_struct	*dm,
+		enum halrf_lna_set type
+)
+{
+	/*phydm_disable_lna*/
+	if (type == HALRF_LNA_DISABLE) {
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x1);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x31, 0xfffff, 0x0002f);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x32, 0xfffff, 0xfb09b);	/*disable LNA*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x0);
+	} else if (type == HALRF_LNA_ENABLE) {
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x1);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x30, 0xfffff, 0x18000);	/*select Rx mode*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x31, 0xfffff, 0x0002f);
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0x32, 0xfffff, 0xfb0bb);	/*disable LNA*/
+		odm_set_rf_reg(dm, RF_PATH_A, RF_0xef, 0x80000, 0x0);
+	}
+}
+
+
+void set_iqk_matrix_8821a(
+	struct dm_struct	*dm,
+	u8		OFDM_index,
+	u8		rf_path,
+	s32		iqk_result_x,
+	s32		iqk_result_y
+)
+{
+	s32			ele_A = 0, ele_D, ele_C = 0, value32;
+
+	ele_D = (ofdm_swing_table_new[OFDM_index] & 0xFFC00000) >> 22;
+
+	/* new element A = element D x X */
+	if ((iqk_result_x != 0) && (*(dm->band_type) == ODM_BAND_2_4G)) {
+		if ((iqk_result_x & 0x00000200) != 0)	/* consider minus */
+			iqk_result_x = iqk_result_x | 0xFFFFFC00;
+		ele_A = ((iqk_result_x * ele_D) >> 8) & 0x000003FF;
+
+		/* new element C = element D x Y */
+		if ((iqk_result_y & 0x00000200) != 0)
+			iqk_result_y = iqk_result_y | 0xFFFFFC00;
+		ele_C = ((iqk_result_y * ele_D) >> 8) & 0x000003FF;
+
+		if (rf_path == RF_PATH_A)
+			switch (rf_path) {
+			case RF_PATH_A:
+				/* wirte new elements A, C, D to regC80 and regC94, element B is always 0 */
+				value32 = (ele_D << 22) | ((ele_C & 0x3F) << 16) | ele_A;
+				odm_set_bb_reg(dm, REG_OFDM_0_XA_TX_IQ_IMBALANCE, MASKDWORD, value32);
+
+				value32 = (ele_C & 0x000003C0) >> 6;
+				odm_set_bb_reg(dm, REG_OFDM_0_XC_TX_AFE, MASKH4BITS, value32);
+
+				value32 = ((iqk_result_x * ele_D) >> 7) & 0x01;
+				odm_set_bb_reg(dm, REG_OFDM_0_ECCA_THRESHOLD, BIT(24), value32);
+				break;
+			default:
+				break;
+			}
+	} else {
+		switch (rf_path) {
+		case RF_PATH_A:
+			odm_set_bb_reg(dm, REG_OFDM_0_XA_TX_IQ_IMBALANCE, MASKDWORD, ofdm_swing_table_new[OFDM_index]);
+			odm_set_bb_reg(dm, REG_OFDM_0_XC_TX_AFE, MASKH4BITS, 0x00);
+			odm_set_bb_reg(dm, REG_OFDM_0_ECCA_THRESHOLD, BIT(24), 0x00);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "TxPwrTracking path B: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x 0xeb4 = 0x%x 0xebc = 0x%x\n",
+		(u32)iqk_result_x, (u32)iqk_result_y, (u32)ele_A, (u32)ele_C, (u32)ele_D, (u32)iqk_result_x, (u32)iqk_result_y);
+}
+
+void do_iqk_8821a(
+	void *dm_void,
+	u8		delta_thermal_index,
+	u8		thermal_value,
+	u8		threshold
+)
+{
+	struct dm_struct		*dm = (struct dm_struct *)dm_void;
+
+	odm_reset_iqk_result(dm);
+	dm->rf_calibrate_info.thermal_value_iqk = thermal_value;
+	halrf_iqk_trigger(dm, false);
+}
+
+
+void
+odm_tx_pwr_track_set_pwr8821a(
+	void *dm_void,
+	enum pwrtrack_method	method,
+	u8				rf_path,
+	u8				channel_mapped_index
+)
+{
+	struct dm_struct		*dm = (struct dm_struct *)dm_void;
+	struct _ADAPTER *adapter = dm->adapter;
+
+	u8			pwr_tracking_limit = 26; /* +1.0dB */
+	u8			tx_rate = 0xFF;
+	u8			final_ofdm_swing_index = 0;
+	u8			final_cck_swing_index = 0;
+	u32			final_bb_swing_idx[1];
+	struct dm_rf_calibration_struct	*cali_info = &(dm->rf_calibrate_info);
+
+	if (*(dm->mp_mode) == true) {
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (MP_DRIVER == 1)
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->MptCtx);
+
+		tx_rate = MptToMgntRate(p_mpt_ctx->MptRateIndex);
+#endif
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#ifdef CONFIG_MP_INCLUDED
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mppriv.mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#endif
+#endif
+	} else {
+		u16	rate	 = *(dm->forced_data_rate);
+
+		if (!rate) { /*auto rate*/
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+			tx_rate = ((PADAPTER)adapter)->HalFunc.GetHwRateFromMRateHandler(dm->tx_rate);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+			tx_rate = hw_rate_to_m_rate(dm->tx_rate);
+#endif
+		} else   /*force rate*/
+			tx_rate = (u8)rate;
+	}
+
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "Power Tracking tx_rate=0x%X\n", tx_rate);
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "===>odm_tx_pwr_track_set_pwr8821a\n");
+
+	if (tx_rate != 0xFF) {
+		/* 2 CCK */
+		if (((tx_rate >= MGN_1M) && (tx_rate <= MGN_5_5M)) || (tx_rate == MGN_11M))
+			pwr_tracking_limit = 32; /* +4dB */
+		/* 2 OFDM */
+		else if ((tx_rate >= MGN_6M) && (tx_rate <= MGN_48M))
+			pwr_tracking_limit = 30; /* +3dB */
+		else if (tx_rate == MGN_54M)
+			pwr_tracking_limit = 28; /* +2dB */
+		/* 2 HT */
+		else if ((tx_rate >= MGN_MCS0) && (tx_rate <= MGN_MCS2)) /* QPSK/BPSK */
+			pwr_tracking_limit = 34; /* +5dB */
+		else if ((tx_rate >= MGN_MCS3) && (tx_rate <= MGN_MCS4)) /* 16QAM */
+			pwr_tracking_limit = 30; /* +3dB */
+		else if ((tx_rate >= MGN_MCS5) && (tx_rate <= MGN_MCS7)) /* 64QAM */
+			pwr_tracking_limit = 28; /* +2dB */
+
+		/* 2 VHT */
+		else if ((tx_rate >= MGN_VHT1SS_MCS0) && (tx_rate <= MGN_VHT1SS_MCS2)) /* QPSK/BPSK */
+			pwr_tracking_limit = 34; /* +5dB */
+		else if ((tx_rate >= MGN_VHT1SS_MCS3) && (tx_rate <= MGN_VHT1SS_MCS4)) /* 16QAM */
+			pwr_tracking_limit = 30; /* +3dB */
+		else if ((tx_rate >= MGN_VHT1SS_MCS5) && (tx_rate <= MGN_VHT1SS_MCS6)) /* 64QAM */
+			pwr_tracking_limit = 28; /* +2dB */
+		else if (tx_rate == MGN_VHT1SS_MCS7) /* 64QAM */
+			pwr_tracking_limit = 26; /* +1dB */
+		else if (tx_rate == MGN_VHT1SS_MCS8) /* 256QAM */
+			pwr_tracking_limit = 24; /* +0dB */
+		else if (tx_rate == MGN_VHT1SS_MCS9) /* 256QAM */
+			pwr_tracking_limit = 22; /* -1dB */
+
+		else
+			pwr_tracking_limit = 24;
+	}
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "tx_rate=0x%x, pwr_tracking_limit=%d\n", tx_rate, pwr_tracking_limit);
+
+	if (method == BBSWING) {
+		if (rf_path == RF_PATH_A) {
+			final_bb_swing_idx[RF_PATH_A] = (cali_info->OFDM_index[RF_PATH_A] > pwr_tracking_limit) ? pwr_tracking_limit : cali_info->OFDM_index[RF_PATH_A];
+			RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "cali_info->OFDM_index[RF_PATH_A]=%d, dm->RealBbSwingIdx[RF_PATH_A]=%d\n",
+				cali_info->OFDM_index[RF_PATH_A], final_bb_swing_idx[RF_PATH_A]);
+
+			odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[final_bb_swing_idx[RF_PATH_A]]);
+		}
+	} else if (method == MIX_MODE) {
+		RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "cali_info->default_ofdm_index=%d, cali_info->absolute_ofdm_swing_idx[rf_path]=%d, rf_path = %d\n",
+			cali_info->default_ofdm_index, cali_info->absolute_ofdm_swing_idx[rf_path], rf_path);
+
+		final_cck_swing_index = cali_info->default_cck_index + cali_info->absolute_ofdm_swing_idx[rf_path];
+		final_ofdm_swing_index = cali_info->default_ofdm_index + cali_info->absolute_ofdm_swing_idx[rf_path];
+
+		if (rf_path == RF_PATH_A) {
+			if (final_ofdm_swing_index > pwr_tracking_limit) {  /* BBSwing higher then Limit */
+				cali_info->remnant_cck_swing_idx = final_cck_swing_index - pwr_tracking_limit;
+				cali_info->remnant_ofdm_swing_idx[rf_path] = final_ofdm_swing_index - pwr_tracking_limit;
+
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[pwr_tracking_limit]);
+
+				cali_info->modify_tx_agc_flag_path_a = true;
+
+				PHY_SetTxPowerLevelByPath(adapter, *dm->channel, RF_PATH_A);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "******Path_A Over BBSwing Limit, pwr_tracking_limit = %d, Remnant tx_agc value = %d\n", pwr_tracking_limit, cali_info->remnant_ofdm_swing_idx[rf_path]);
+			} else if (final_ofdm_swing_index < 0) {
+				cali_info->remnant_cck_swing_idx = final_cck_swing_index;
+				cali_info->remnant_ofdm_swing_idx[rf_path] = final_ofdm_swing_index;
+
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[0]);
+
+				cali_info->modify_tx_agc_flag_path_a = true;
+
+				PHY_SetTxPowerLevelByPath(adapter, *dm->channel, RF_PATH_A);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "******Path_A Lower then BBSwing lower bound  0, Remnant tx_agc value = %d\n", cali_info->remnant_ofdm_swing_idx[rf_path]);
+			} else {
+				odm_set_bb_reg(dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000, tx_scaling_table_jaguar[final_ofdm_swing_index]);
+
+				RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "******Path_A Compensate with BBSwing, final_ofdm_swing_index = %d\n", final_ofdm_swing_index);
+
+				if (cali_info->modify_tx_agc_flag_path_a) { /* If tx_agc has changed, reset tx_agc again */
+					cali_info->remnant_cck_swing_idx = 0;
+					cali_info->remnant_ofdm_swing_idx[rf_path] = 0;
+
+					PHY_SetTxPowerLevelByPath(adapter, *dm->channel, RF_PATH_A);
+
+					cali_info->modify_tx_agc_flag_path_a = false;
+
+					RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "******Path_A dm->Modify_TxAGC_Flag = false\n");
+				}
+			}
+		}
+	} else
+		return;
+}	/* odm_TxPwrTrackSetPwr88E */
+
+void
+get_delta_swing_table_8821a(
+	void *dm_void,
+	u8 **temperature_up_a,
+	u8 **temperature_down_a,
+	u8 **temperature_up_b,
+	u8 **temperature_down_b
+)
+{
+	struct dm_struct		*dm = (struct dm_struct *)dm_void;
+	struct _ADAPTER *adapter = dm->adapter;
+	struct dm_rf_calibration_struct	*cali_info = &(dm->rf_calibrate_info);
+	u8		tx_rate			= 0xFF;
+	u8	channel		 = *dm->channel;
+
+	if (*(dm->mp_mode) == true) {
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (MP_DRIVER == 1)
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->MptCtx);
+
+		tx_rate = MptToMgntRate(p_mpt_ctx->MptRateIndex);
+#endif
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#ifdef CONFIG_MP_INCLUDED
+		PMPT_CONTEXT p_mpt_ctx = &(adapter->mppriv.mpt_ctx);
+
+		tx_rate = mpt_to_mgnt_rate(p_mpt_ctx->mpt_rate_index);
+#endif
+#endif
+#endif
+	} else {
+		u16	rate	 = *(dm->forced_data_rate);
+
+		if (!rate) { /*auto rate*/
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+			tx_rate = ((PADAPTER)adapter)->HalFunc.GetHwRateFromMRateHandler(dm->tx_rate);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE)
+			tx_rate = hw_rate_to_m_rate(dm->tx_rate);
+#endif
+		} else   /*force rate*/
+			tx_rate = (u8)rate;
+	}
+
+	RF_DBG(dm, DBG_RF_TX_PWR_TRACK, "Power Tracking tx_rate=0x%X\n", tx_rate);
+
+
+	if (1 <= channel && channel <= 14) {
+		if (IS_CCK_RATE(tx_rate)) {
+			*temperature_up_a   = cali_info->delta_swing_table_idx_2g_cck_a_p;
+			*temperature_down_a = cali_info->delta_swing_table_idx_2g_cck_a_n;
+			*temperature_up_b   = cali_info->delta_swing_table_idx_2g_cck_b_p;
+			*temperature_down_b = cali_info->delta_swing_table_idx_2g_cck_b_n;
+		} else {
+			*temperature_up_a   = cali_info->delta_swing_table_idx_2ga_p;
+			*temperature_down_a = cali_info->delta_swing_table_idx_2ga_n;
+			*temperature_up_b   = cali_info->delta_swing_table_idx_2gb_p;
+			*temperature_down_b = cali_info->delta_swing_table_idx_2gb_n;
+		}
+	} else if (36 <= channel && channel <= 64) {
+		*temperature_up_a   = cali_info->delta_swing_table_idx_5ga_p[0];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[0];
+		*temperature_up_b   = cali_info->delta_swing_table_idx_5gb_p[0];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[0];
+	} else if (100 <= channel && channel <= 144) {
+		*temperature_up_a   = cali_info->delta_swing_table_idx_5ga_p[1];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[1];
+		*temperature_up_b   = cali_info->delta_swing_table_idx_5gb_p[1];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[1];
+	} else if (149 <= channel && channel <= 177) {
+		*temperature_up_a   = cali_info->delta_swing_table_idx_5ga_p[2];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[2];
+		*temperature_up_b   = cali_info->delta_swing_table_idx_5gb_p[2];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[2];
+	} else {
+		*temperature_up_a   = (u8 *)delta_swing_table_idx_2ga_p_8188e;
+		*temperature_down_a = (u8 *)delta_swing_table_idx_2ga_n_8188e;
+		*temperature_up_b   = (u8 *)delta_swing_table_idx_2ga_p_8188e;
+		*temperature_down_b = (u8 *)delta_swing_table_idx_2ga_n_8188e;
+	}
+
+	return;
+}
+
+void configure_txpower_track_8821a(
+	struct txpwrtrack_cfg	*config
+)
+{
+	config->swing_table_size_cck = TXSCALE_TABLE_SIZE;
+	config->swing_table_size_ofdm = TXSCALE_TABLE_SIZE;
+	config->threshold_iqk = IQK_THRESHOLD;
+	config->average_thermal_num = AVG_THERMAL_NUM_8812A;
+	config->rf_path_count = MAX_PATH_NUM_8821A;
+	config->thermal_reg_addr = RF_T_METER_8812A;
+
+	config->odm_tx_pwr_track_set_pwr = odm_tx_pwr_track_set_pwr8821a;
+	config->do_iqk = do_iqk_8821a;
+	config->phy_lc_calibrate = phy_lc_calibrate_8821a;
+	config->get_delta_swing_table = get_delta_swing_table_8821a;
+}
+
+/* 1 7.	IQK */
+#define MAX_TOLERANCE		5
+#define IQK_DELAY_TIME		1		/* ms */
+
+void _iqk_rx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			RX_X,
+	unsigned int			RX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		odm_set_bb_reg(dm, R_0xc10, 0x000003ff, RX_X >> 1);
+		odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, RX_Y >> 1);
+		RF_DBG(dm, DBG_RF_IQK, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X >> 1, RX_Y >> 1);
+		RF_DBG(dm, DBG_RF_IQK, "0xc10 = %x ====>fill to IQC\n", odm_read_4byte(dm, 0xc10));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_tx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			TX_X,
+	unsigned int			TX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		odm_write_4byte(dm, 0xc90, 0x00000080);
+		odm_write_4byte(dm, 0xcc4, 0x20040000);
+		odm_write_4byte(dm, 0xcc8, 0x20000000);
+		odm_set_bb_reg(dm, R_0xccc, 0x000007ff, TX_Y);
+		odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, TX_X);
+		RF_DBG(dm, DBG_RF_IQK, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X, TX_Y);
+		RF_DBG(dm, DBG_RF_IQK, "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n", odm_get_bb_reg(dm, R_0xcd4, 0x000007ff), odm_get_bb_reg(dm, R_0xccc, 0x000007ff));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_backup_mac_bb_8821a(
+	struct dm_struct	*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < MACBB_NUM; i++)
+		MACBB_backup[i] = odm_read_4byte(dm, backup_macbb_reg[i]);
+
+	RF_DBG(dm, DBG_RF_IQK, "BackupMacBB Success!!!!\n");
+}
+void _iqk_backup_rf_8821a(
+	struct dm_struct	*dm,
+	u32		*RFA_backup,
+	u32		*RFB_backup,
+	u32		*backup_rf_reg,
+	u32		RF_NUM
+)
+{
+
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < RF_NUM; i++)
+		RFA_backup[i] = odm_get_rf_reg(dm, RF_PATH_A, backup_rf_reg[i], MASKDWORD);
+	RF_DBG(dm, DBG_RF_IQK, "BackupRF Success!!!!\n");
+}
+void _iqk_backup_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		AFE_backup[i] = odm_read_4byte(dm, backup_afe_reg[i]);
+	RF_DBG(dm, DBG_RF_IQK, "BackupAFE Success!!!!\n");
+}
+void _iqk_restore_mac_bb_8821a(
+	struct dm_struct		*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < MACBB_NUM; i++)
+		odm_write_4byte(dm, backup_macbb_reg[i], MACBB_backup[i]);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreMacBB Success!!!!\n");
+}
+void _iqk_restore_rf_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	u32			*backup_rf_reg,
+	u32			*RF_backup,
+	u32			RF_REG_NUM
+)
+{
+	u32 i;
+
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	for (i = 0; i < RF_REG_NUM; i++)
+		odm_set_rf_reg(dm, (enum rf_path)path, backup_rf_reg[i], RFREGOFFSETMASK, RF_backup[i]);
+
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "RestoreRF path A Success!!!!\n");
+	}
+	break;
+	default:
+		break;
+	}
+}
+void _iqk_restore_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		odm_write_4byte(dm, backup_afe_reg[i], AFE_backup[i]);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_write_4byte(dm, 0xc80, 0x0);
+	odm_write_4byte(dm, 0xc84, 0x0);
+	odm_write_4byte(dm, 0xc88, 0x0);
+	odm_write_4byte(dm, 0xc8c, 0x3c000000);
+	odm_write_4byte(dm, 0xc90, 0x00000080);
+	odm_write_4byte(dm, 0xc94, 0x00000000);
+	odm_write_4byte(dm, 0xcc4, 0x20040000);
+	odm_write_4byte(dm, 0xcc8, 0x20000000);
+	odm_write_4byte(dm, 0xcb8, 0x0);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreAFE Success!!!!\n");
+}
+
+
+void _iqk_configure_mac_8821a(
+	struct dm_struct		*dm
+)
+{
+	/* ========MAC register setting======== */
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_write_1byte(dm, 0x522, 0x3f);
+	odm_set_bb_reg(dm, R_0x550, BIT(11) | BIT(3), 0x0);
+	odm_write_1byte(dm, 0x808, 0x00);		/*		RX ante off */
+	odm_set_bb_reg(dm, R_0x838, 0xf, 0xc);		/*		CCA off */
+	odm_write_1byte(dm, 0xa07, 0xf);		/*		CCK RX path off */
+}
+
+#define cal_num 3
+
+void _iqk_tx_8821a(
+	struct dm_struct		*dm,
+	enum rf_path path
+)
+{
+	u32		TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0;
+	int		TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, tx_average = 0, rx_average = 0, rx_iqk_loop = 0, RX_X_temp = 0, RX_Y_temp = 0;
+	int		TX_X0[cal_num], TX_Y0[cal_num], RX_X0[2][cal_num], RX_Y0[2][cal_num];
+	boolean	TX0IQKOK = false, RX0IQKOK = false;
+	int			i, ii, dx = 0, dy = 0, TX_finish = 0, RX_finish1 = 0, RX_finish2 = 0;
+
+
+	RF_DBG(dm, DBG_RF_IQK, "band_width = %d, support_interface = %d, ext_pa = %d, ext_pa_5g = %d\n", *dm->band_width, dm->support_interface, dm->ext_pa, dm->ext_pa_5g);
+	/*EFEM off*/
+	odm_set_bb_reg(dm, R_0xcb0, 0xf0, 0x7);
+	odm_set_bb_reg(dm, R_0xcb0, 0xf000, 0x7);
+
+	while (cal < cal_num) {
+		switch (path) {
+		case RF_PATH_A:
+		{
+			/* path-A LOK */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* ========path-A AFE all on======== */
+			/* Port 0 DAC/ADC on */
+			odm_write_4byte(dm, 0xc60, 0x77777777);
+			odm_write_4byte(dm, 0xc64, 0x77777777);
+
+			odm_write_4byte(dm, 0xc68, 0x19791979);
+
+			odm_set_bb_reg(dm, R_0xc00, 0xf, 0x4);/*	hardware 3-wire off */
+
+			/* LOK setting */
+			/* ====== LOK ====== */
+			/* 1. DAC/ADC sampling rate (160 MHz) */
+			odm_set_bb_reg(dm, R_0xc5c, BIT(26) | BIT(25) | BIT(24), 0x7);
+
+			/* 2. LoK RF setting (at BW = 20M) */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80002);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x00462910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403f4);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x68163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x28163e96);
+
+			odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xcb8, 0x00100000);
+			odm_write_4byte(dm, 0x980, 0xfa000000);
+			odm_write_4byte(dm, 0x980, 0xf8000000);
+
+			delay_ms(10); /* delay 10ms */
+			odm_write_4byte(dm, 0xcb8, 0x00000000);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x58, 0x7fe00, odm_get_rf_reg(dm, (enum rf_path)path, RF_0x8, 0xffc00));
+			switch (*dm->band_width) {
+			case 1:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x1);
+			}
+			break;
+			case 2:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x0);
+			}
+			break;
+			default:
+				break;
+
+			}
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			/* 3. TX RF setting */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403e3);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x40163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x00163e96);
+
+			odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xcb8, 0x00100000);
+			cal_retry = 0;
+			while (1) {
+				/* one shot */
+				odm_write_4byte(dm, 0x980, 0xfa000000);
+				odm_write_4byte(dm, 0x980, 0xf8000000);
+
+				delay_ms(10); /* delay 10ms */
+				odm_write_4byte(dm, 0xcb8, 0x00000000);
+				delay_count = 0;
+				while (1) {
+					IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+					if ((~IQK_ready) || (delay_count > 20))
+						break;
+					else {
+						delay_ms(1);
+						delay_count++;
+					}
+				}
+
+				if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+					/* ============TXIQK Check============== */
+					TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+					if (~TX_fail) {
+						odm_write_4byte(dm, 0xcb8, 0x02000000);
+						TX_X0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+						odm_write_4byte(dm, 0xcb8, 0x04000000);
+						TX_Y0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+						TX0IQKOK = true;
+						break;
+					} else {
+						odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+						odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				} else {
+					TX0IQKOK = false;
+					cal_retry++;
+					if (cal_retry == 10)
+						break;
+				}
+			}
+
+
+			if (TX0IQKOK == false)
+				break;				/* TXK fail, Don't do RXK */
+
+			/* ====== RX IQK ====== */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* 1. RX RF setting */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x30000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0002f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xfffbb);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x88001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d8);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+
+			odm_set_bb_reg(dm, R_0x978, 0x03FF8000, (TX_X0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, 0x000007FF, (TX_Y0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, BIT(31), 0x1);
+			odm_set_bb_reg(dm, R_0x97c, BIT(31), 0x0);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_write_4byte(dm, 0x984, 0x0046a911);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+			odm_write_4byte(dm, 0xc80, 0x38008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x18008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xc88, 0x02140119);
+
+			if (dm->support_interface == 1) {
+				rx_iqk_loop = 2;				/* for 2% fail; */
+			} else
+				rx_iqk_loop = 1;
+			for (i = 0; i < rx_iqk_loop; i++) {
+				if (dm->support_interface == 1)
+					if (i == 0)
+						odm_write_4byte(dm, 0xc8c, 0x28161100);  /* Good */
+					else
+						odm_write_4byte(dm, 0xc8c, 0x28160d00);
+				else
+					odm_write_4byte(dm, 0xc8c, 0x28160d00);
+
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+					delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20))
+							break;
+						else {
+							delay_ms(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(11));
+						if (RX_fail == 0) {
+							/*
+							dbg_print("====== RXIQK (%d) ======", i);
+							odm_write_4byte(dm, 0xcb8, 0x05000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							dbg_print("reg1 = %d, reg2 = %d", reg1, reg2);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("Before PW = %d\n", image_power);
+							odm_write_4byte(dm, 0xcb8, 0x07000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("After PW = %d\n", image_power);
+							*/
+
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							RX_X0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							RX_Y0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							RX0IQKOK = true;
+							break;
+						} else {
+							odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x200 >> 1);
+							odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, 0x0 >> 1);
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						}
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK)
+				tx_average++;
+			if (RX0IQKOK)
+				rx_average++;
+		}
+		break;
+		default:
+			break;
+		}
+		cal++;
+	}
+	/* FillIQK Result */
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "========Path_A =======\n");
+		if (tx_average == 0)
+			break;
+
+		for (i = 0; i < tx_average; i++)
+			RF_DBG(dm, DBG_RF_IQK, "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i]) >> 21 & 0x000007ff, i, (TX_Y0[i]) >> 21 & 0x000007ff);
+		for (i = 0; i < tx_average; i++) {
+			for (ii = i + 1; ii < tx_average; ii++) {
+				dx = (TX_X0[i] >> 21) - (TX_X0[ii] >> 21);
+				if (dx < 3 && dx > -3) {
+					dy = (TX_Y0[i] >> 21) - (TX_Y0[ii] >> 21);
+					if (dy < 3 && dy > -3) {
+						TX_X = ((TX_X0[i] >> 21) + (TX_X0[ii] >> 21)) / 2;
+						TX_Y = ((TX_Y0[i] >> 21) + (TX_Y0[ii] >> 21)) / 2;
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (TX_finish == 1)
+			_iqk_tx_fill_iqc_8821a(dm, path, TX_X, TX_Y);
+		else
+			_iqk_tx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+
+		if (rx_average == 0)
+			break;
+
+		for (i = 0; i < rx_average; i++) {
+			RF_DBG(dm, DBG_RF_IQK, "RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i, (RX_X0[0][i]) >> 21 & 0x000007ff, i, (RX_Y0[0][i]) >> 21 & 0x000007ff);
+			if (rx_iqk_loop == 2)
+				RF_DBG(dm, DBG_RF_IQK, "RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n", i, (RX_X0[1][i]) >> 21 & 0x000007ff, i, (RX_Y0[1][i]) >> 21 & 0x000007ff);
+		}
+		for (i = 0; i < rx_average; i++) {
+			for (ii = i + 1; ii < rx_average; ii++) {
+				dx = (RX_X0[0][i] >> 21) - (RX_X0[0][ii] >> 21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y0[0][i] >> 21) - (RX_Y0[0][ii] >> 21);
+					if (dy < 4 && dy > -4) {
+						RX_X_temp = ((RX_X0[0][i] >> 21) + (RX_X0[0][ii] >> 21)) / 2;
+						RX_Y_temp = ((RX_Y0[0][i] >> 21) + (RX_Y0[0][ii] >> 21)) / 2;
+						RX_finish1 = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish1 == 1) {
+				RX_X = RX_X_temp;
+				RX_Y = RX_Y_temp;
+				break;
+			}
+		}
+		if (rx_iqk_loop == 2) {
+			for (i = 0; i < rx_average; i++) {
+				for (ii = i + 1; ii < rx_average; ii++) {
+					dx = (RX_X0[1][i] >> 21) - (RX_X0[1][ii] >> 21);
+					if (dx < 4 && dx > -4) {
+						dy = (RX_Y0[1][i] >> 21) - (RX_Y0[1][ii] >> 21);
+						if (dy < 4 && dy > -4) {
+							RX_X = ((RX_X0[1][i] >> 21) + (RX_X0[1][ii] >> 21)) / 2;
+							RX_Y = ((RX_Y0[1][i] >> 21) + (RX_Y0[1][ii] >> 21)) / 2;
+							RX_finish2 = 1;
+							break;
+						}
+					}
+				}
+				if (RX_finish2 == 1)
+					break;
+			}
+			if (RX_finish1 && RX_finish2) {
+				RX_X = (RX_X + RX_X_temp) / 2;
+				RX_Y = (RX_Y + RX_Y_temp) / 2;
+			}
+		}
+		if (RX_finish1 || RX_finish1)
+			_iqk_rx_fill_iqc_8821a(dm, path, RX_X, RX_Y);
+		else
+			_iqk_rx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+#define MACBB_REG_NUM 9
+#define AFE_REG_NUM 4
+#define RF_REG_NUM 3
+
+void
+_phy_iq_calibrate_by_fw_8821a(
+	struct dm_struct		*dm
+)
+{
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+	u8			iqk_cmd[3] = {hal_data->CurrentChannel, 0x0, 0x0};
+	u8			buf1 = 0x0;
+	u8			buf2 = 0x0;
+
+	/* Byte 2, Bit 4 ~ Bit 5 : band_type */
+	if (hal_data->CurrentBandType)
+		buf1 = 0x2 << 4;
+	else
+		buf1 = 0x1 << 4;
+
+	/* Byte 2, Bit 0 ~ Bit 3 : bandwidth */
+	if (hal_data->CurrentChannelBW == CHANNEL_WIDTH_20)
+		buf2 = 0x1;
+	else if (hal_data->CurrentChannelBW == CHANNEL_WIDTH_40)
+		buf2 = 0x1 << 1;
+	else if (hal_data->CurrentChannelBW == CHANNEL_WIDTH_80)
+		buf2 = 0x1 << 2;
+	else
+		buf2 = 0x1 << 3;
+
+	iqk_cmd[1] = buf1 | buf2;
+	iqk_cmd[2] = hal_data->ExternalPA_5G | hal_data->ExternalLNA_5G << 1;
+
+
+	RT_TRACE(COMP_MP, DBG_LOUD, ("== FW IQK Start ==\n"));
+	hal_data->IQK_StartTimer = 0;
+	hal_data->IQK_StartTimer = PlatformGetCurrentTime();
+	RT_TRACE(COMP_MP, DBG_LOUD, ("== start_time: %u\n", hal_data->IQK_StartTimer));
+
+#if (H2C_USE_IO_THREAD == 1)
+	FW8821A_FillH2cCommand(adapter, 0x45, 3, iqk_cmd);
+#else
+	FillH2CCommand8821A(adapter, 0x45, 3, iqk_cmd);
+#endif
+}
+
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+)
+{
+	u32	MACBB_backup[MACBB_REG_NUM], AFE_backup[AFE_REG_NUM], RFA_backup[RF_REG_NUM], RFB_backup[RF_REG_NUM];
+	u32	backup_macbb_reg[MACBB_REG_NUM] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c, 0xcb0};
+	u32	backup_afe_reg[AFE_REG_NUM] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u32	backup_rf_reg[RF_REG_NUM] = {0x65, 0x8f, 0x0};
+
+	_iqk_backup_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM);
+	_iqk_backup_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM);
+	_iqk_backup_rf_8821a(dm, RFA_backup, RFB_backup, backup_rf_reg, RF_REG_NUM);
+
+	_iqk_configure_mac_8821a(dm);
+	_iqk_tx_8821a(dm, RF_PATH_A);
+	_iqk_restore_rf_8821a(dm, RF_PATH_A, backup_rf_reg, RFA_backup, RF_REG_NUM);
+
+	_iqk_restore_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM);
+	_iqk_restore_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM);
+
+	/* _IQK_Exit_8821A(dm); */
+	/* _IQK_TX_CheckResult_8821A */
+
+}
+
+void
+phy_reset_iqk_result_8821a(
+	struct dm_struct	*dm
+)
+{
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+	odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+	odm_write_4byte(dm, 0xce8, 0x0);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x100);
+}
+
+/*for win*/
+/*IQK:0x1*/
+void
+phy_iq_calibrate_8821a(
+	void		*dm_void,
+	boolean	is_recovery
+)
+{
+
+	struct dm_struct	*dm = (struct dm_struct *)dm_void;
+	u32			counter = 0;
+
+	if (dm->fw_offload_ability & PHYDM_RF_IQK_OFFLOAD) {
+		_phy_iq_calibrate_by_fw_8821a(dm);
+		for (counter = 0; counter < 10; counter++) {
+			RF_DBG(dm, DBG_RF_IQK, "== FW IQK PROGRESS == #%d\n", counter);
+			ODM_delay_ms(50);
+			if (!dm->rf_calibrate_info.is_iqk_in_progress) {
+				RF_DBG(dm, DBG_RF_IQK, "== FW IQK RETURN FROM WAITING ==\n");
+				break;
+			}
+		}
+		if (dm->rf_calibrate_info.is_iqk_in_progress)
+			RF_DBG(dm, DBG_RF_IQK, "== FW IQK TIMEOUT (Still in progress after 500ms) ==\n");
+	} else
+		_phy_iq_calibrate_8821a(dm);
+}
+
+
+void
+phy_lc_calibrate_8821a(
+	void		*dm_void
+)
+{
+	struct dm_struct		*dm = (struct dm_struct *)dm_void;
+
+	phy_lc_calibrate_8812a(dm);
+}
+#endif
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_8821a_win.h /hal/phydm/halrf/rtl8821a/halrf_8821a_win.h
--- /hal/phydm/halrf/rtl8821a/halrf_8821a_win.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_8821a_win.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,72 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#ifndef __HALRF_8821A_H__
+#define __HALRF_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define	IQK_DELAY_TIME_8821A		10		/* ms */
+#define	index_mapping_NUM_8821A	15
+#define AVG_THERMAL_NUM_8821A	4
+#define RF_T_METER_8821A		0x42
+
+void configure_txpower_track_8821a(
+	struct txpwrtrack_cfg	*config
+);
+
+void do_iqk_8821a(
+	void *dm_void,
+	u8		delta_thermal_index,
+	u8		thermal_value,
+	u8		threshold
+);
+
+void
+odm_tx_pwr_track_set_pwr8821a(
+	void *dm_void,
+	enum pwrtrack_method	method,
+	u8				rf_path,
+	u8				channel_mapped_index
+);
+
+/* 1 7.	IQK */
+
+void
+phy_iq_calibrate_8821a(
+	void		*dm_void,
+	boolean	is_recovery
+);
+
+void
+phy_lc_calibrate_8821a(
+	IN void *dm_void
+);
+
+void
+get_delta_swing_table_8821a(
+	void *dm_void,
+	u8 **temperature_up_a,
+	u8 **temperature_down_a,
+	u8 **temperature_up_b,
+	u8 **temperature_down_b
+);
+
+void
+halrf_rf_lna_setting_8821a(
+	struct dm_struct	*dm,
+	enum halrf_lna_set type
+);
+
+#endif	/*#ifndef __HALRF_8821A_H__*/
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.c /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.c
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,730 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "../../phydm_precomp.h"
+
+
+
+/*---------------------------Define Local Constant---------------------------*/
+#define cal_num_8821A 3
+#define MACBB_REG_NUM_8821A 8
+#define AFE_REG_NUM_8821A 4
+#define RF_REG_NUM_8821A 3
+/*---------------------------Define Local Constant---------------------------*/
+void _iqk_rx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			RX_X,
+	unsigned int			RX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		odm_set_bb_reg(dm, R_0xc10, 0x000003ff, RX_X >> 1);
+		odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, (RX_Y >> 1) & 0x000003ff);
+		RF_DBG(dm, DBG_RF_IQK, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X >> 1, RX_Y >> 1);
+		RF_DBG(dm, DBG_RF_IQK, "0xc10 = %x ====>fill to IQC\n", odm_read_4byte(dm, 0xc10));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_tx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			TX_X,
+	unsigned int			TX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		odm_write_4byte(dm, 0xc90, 0x00000080);
+		odm_write_4byte(dm, 0xcc4, 0x20040000);
+		odm_write_4byte(dm, 0xcc8, 0x20000000);
+		odm_set_bb_reg(dm, R_0xccc, 0x000007ff, TX_Y);
+		odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, TX_X);
+		RF_DBG(dm, DBG_RF_IQK, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X, TX_Y);
+		RF_DBG(dm, DBG_RF_IQK, "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n", odm_get_bb_reg(dm, R_0xcd4, 0x000007ff), odm_get_bb_reg(dm, R_0xccc, 0x000007ff));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_backup_mac_bb_8821a(
+	struct dm_struct	*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < MACBB_NUM; i++)
+		MACBB_backup[i] = odm_read_4byte(dm, backup_macbb_reg[i]);
+
+	RF_DBG(dm, DBG_RF_IQK, "BackupMacBB Success!!!!\n");
+}
+
+void _iqk_backup_rf_8821a(
+	struct dm_struct	*dm,
+	u32		*RFA_backup,
+	u32		*RFB_backup,
+	u32		*backup_rf_reg,
+	u32		RF_NUM
+)
+{
+
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < RF_NUM; i++)
+		RFA_backup[i] = odm_get_rf_reg(dm, RF_PATH_A, backup_rf_reg[i], MASKDWORD);
+	RF_DBG(dm, DBG_RF_IQK, "BackupRF Success!!!!\n");
+}
+
+void _iqk_backup_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		AFE_backup[i] = odm_read_4byte(dm, backup_afe_reg[i]);
+	RF_DBG(dm, DBG_RF_IQK, "BackupAFE Success!!!!\n");
+}
+
+void _iqk_restore_mac_bb_8821a(
+	struct dm_struct		*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < MACBB_NUM; i++)
+		odm_write_4byte(dm, backup_macbb_reg[i], MACBB_backup[i]);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreMacBB Success!!!!\n");
+}
+
+void _iqk_restore_rf_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	u32				*backup_rf_reg,
+	u32				*RF_backup,
+	u32				RF_REG_NUM
+)
+{
+	u32 i;
+
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	for (i = 0; i < RF_REG_NUM; i++)
+		odm_set_rf_reg(dm, (enum rf_path)path, backup_rf_reg[i], RFREGOFFSETMASK, RF_backup[i]);
+
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "RestoreRF path A Success!!!!\n");
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+void _iqk_restore_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		odm_write_4byte(dm, backup_afe_reg[i], AFE_backup[i]);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_write_4byte(dm, 0xc80, 0x0);
+	odm_write_4byte(dm, 0xc84, 0x0);
+	odm_write_4byte(dm, 0xc88, 0x0);
+	odm_write_4byte(dm, 0xc8c, 0x3c000000);
+	odm_write_4byte(dm, 0xc90, 0x00000080);
+	odm_write_4byte(dm, 0xc94, 0x00000000);
+	odm_write_4byte(dm, 0xcc4, 0x20040000);
+	odm_write_4byte(dm, 0xcc8, 0x20000000);
+	odm_write_4byte(dm, 0xcb8, 0x0);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreAFE Success!!!!\n");
+}
+
+void _iqk_configure_mac_8821a(
+	struct dm_struct		*dm
+)
+{
+	/* ========MAC register setting======== */
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_write_1byte(dm, 0x522, 0x3f);
+	odm_set_bb_reg(dm, R_0x550, BIT(11) | BIT(3), 0x0);
+	odm_write_1byte(dm, 0x808, 0x00);		/*		RX ante off */
+	odm_set_bb_reg(dm, R_0x838, 0xf, 0xc);		/*		CCA off */
+	odm_write_1byte(dm, 0xa07, 0xf);		/*		CCK RX path off */
+}
+
+void _iqk_tx_8821a(
+	struct dm_struct		*dm,
+	enum rf_path path
+)
+{
+	u32		TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0;
+	int		TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, tx_average = 0, rx_average = 0, rx_iqk_loop = 0, RX_X_temp = 0, RX_Y_temp = 0;
+	int		TX_X0[cal_num_8821A], TX_Y0[cal_num_8821A], RX_X0[2][cal_num_8821A], RX_Y0[2][cal_num_8821A];
+	boolean	TX0IQKOK = false, RX0IQKOK = false;
+	boolean	VDF_enable = false;
+	int			i, k, VDF_Y[3], VDF_X[3], tx_dt[3], ii, dx = 0, dy = 0, TX_finish = 0, RX_finish1 = 0, RX_finish2 = 0;
+
+	RF_DBG(dm, DBG_RF_IQK, "band_width = %d, support_interface = %d, ext_pa = %d, ext_pa_5g = %d\n", *dm->band_width, dm->support_interface, dm->ext_pa, dm->ext_pa_5g);
+	if (*dm->band_width == 2)
+		VDF_enable = true;
+
+	while (cal < cal_num_8821A) {
+		switch (path) {
+		case RF_PATH_A:
+		{
+			/* path-A LOK */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* ========path-A AFE all on======== */
+			/* Port 0 DAC/ADC on */
+			odm_write_4byte(dm, 0xc60, 0x77777777);
+			odm_write_4byte(dm, 0xc64, 0x77777777);
+
+			odm_write_4byte(dm, 0xc68, 0x19791979);
+
+			odm_set_bb_reg(dm, R_0xc00, 0xf, 0x4);/*	hardware 3-wire off */
+
+			/* LOK setting */
+			/* ====== LOK ====== */
+			/* 1. DAC/ADC sampling rate (160 MHz) */
+			odm_set_bb_reg(dm, R_0xc5c, BIT(26) | BIT(25) | BIT(24), 0x7);
+
+			/* 2. LoK RF setting (at BW = 20M) */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80002);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x00462910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403f4);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x68163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x28163e96);
+
+			odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xcb8, 0x00100000);
+			odm_write_4byte(dm, 0x980, 0xfa000000);
+			odm_write_4byte(dm, 0x980, 0xf8000000);
+
+			ODM_delay_ms(10); /* delay 10ms */
+			odm_write_4byte(dm, 0xcb8, 0x00000000);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x58, 0x7fe00,
+				odm_get_rf_reg(dm, (enum rf_path)path, RF_0x8, 0xffc00));
+			switch (*dm->band_width) {
+			case 1:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x1);
+			}
+			break;
+			case 2:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x0);
+			}
+			break;
+			default:
+				break;
+			}
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			/* 3. TX RF setting */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403e3);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x40163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x00163e96);
+
+			if (VDF_enable == 1) {
+				for (k = 0; k <= 2; k++) {
+					switch (k) {
+					case 0:
+					{
+						odm_write_4byte(dm, 0xc80, 0x18008c38);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c38);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					}
+					break;
+					case 1:
+					{
+						odm_set_bb_reg(dm, R_0xc80, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xc84, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					}
+					break;
+					case 2:
+					{
+						RF_DBG(dm, DBG_RF_IQK, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1] >> 21 & 0x00007ff, VDF_Y[0] >> 21 & 0x00007ff);
+						RF_DBG(dm, DBG_RF_IQK, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1] >> 21 & 0x00007ff, VDF_X[0] >> 21 & 0x00007ff);
+						tx_dt[cal] = (VDF_Y[1] >> 20) - (VDF_Y[0] >> 20);
+						tx_dt[cal] = ((16 * tx_dt[cal]) * 10000 / 15708);
+						tx_dt[cal] = (tx_dt[cal] >> 1) + (tx_dt[cal] & BIT(0));
+						odm_write_4byte(dm, 0xc80, 0x18008c20);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c20);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x1);
+						odm_set_bb_reg(dm, R_0xce8, 0x3fff0000, tx_dt[cal] & 0x00003fff);
+					}
+					break;
+					}
+					odm_write_4byte(dm, 0xcb8, 0x00100000);
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						odm_write_4byte(dm, 0x980, 0xfa000000);
+						odm_write_4byte(dm, 0x980, 0xf8000000);
+
+						ODM_delay_ms(10); /* delay 10ms */
+						odm_write_4byte(dm, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+							if ((~IQK_ready) || (delay_count > 20))
+								break;
+							else {
+								ODM_delay_ms(1);
+								delay_count++;
+							}
+						}
+
+						if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+							/* ============TXIQK Check============== */
+							TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+							if (~TX_fail) {
+								odm_write_4byte(dm, 0xcb8, 0x02000000);
+								VDF_X[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								odm_write_4byte(dm, 0xcb8, 0x04000000);
+								VDF_Y[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								TX0IQKOK = true;
+								break;
+							} else {
+								odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+								odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+								TX0IQKOK = false;
+								cal_retry++;
+								if (cal_retry == 10)
+									break;
+							}
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					}
+				}
+				if (k == 3) {
+					TX_X0[cal] = VDF_X[k - 1] ;
+					TX_Y0[cal] = VDF_Y[k - 1];
+				}
+			} else {
+				odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20))
+							break;
+						else {
+							ODM_delay_ms(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+						if (~TX_fail) {
+							odm_write_4byte(dm, 0xcb8, 0x02000000);
+							TX_X0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x04000000);
+							TX_Y0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							TX0IQKOK = true;
+							break;
+						} else {
+							odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+							odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK == false)
+				break;				/* TXK fail, Don't do RXK */
+
+			/* ====== RX IQK ====== */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* 1. RX RF setting */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x30000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0002f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xfffbb);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x88001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d8);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+
+			if ((get_bonding_type_8881A() == BOND_8881AM) && (dm->ext_pa_5g) && (dm->ext_lna_5g)) {
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0xdf, 0x00800, 0x1);
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x56, 0x003e0, 0x1);
+			}
+
+			odm_set_bb_reg(dm, R_0x978, 0x03FF8000, (TX_X0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, 0x000007FF, (TX_Y0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, BIT(31), 0x1);
+			RF_DBG(dm, DBG_RF_IQK, "0x978 = 0x%x\n", odm_get_bb_reg(dm, R_0x978, MASKDWORD));
+			odm_set_bb_reg(dm, R_0x97c, BIT(31), 0x0);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_write_4byte(dm, 0x984, 0x0046a911);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+			odm_write_4byte(dm, 0xc80, 0x38008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x18008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xc88, 0x02140119);
+
+			if (dm->support_interface == 1) {
+				rx_iqk_loop = 2;				/* for 2% fail; */
+			} else
+				rx_iqk_loop = 1;
+			for (i = 0; i < rx_iqk_loop; i++) {
+				if (dm->support_interface == 1)
+					if (i == 0) {
+						if ((get_bonding_type_8881A() == BOND_8881AM) && (dm->ext_pa_5g) && (dm->ext_lna_5g))
+							odm_write_4byte(dm, 0xc8c, 0x28161800);  /* Good */
+						else
+							odm_write_4byte(dm, 0xc8c, 0x28161100);
+						RF_DBG(dm, DBG_RF_IQK, "0xc8c (i=0) = 0x%x\n", odm_get_bb_reg(dm, R_0xc8c, MASKDWORD));
+					} else {
+						if ((get_bonding_type_8881A() == BOND_8881AM) && (dm->ext_pa_5g) && (dm->ext_lna_5g))
+							odm_write_4byte(dm, 0xc8c, 0x28160c00);
+						else
+							odm_write_4byte(dm, 0xc8c, 0x28160d00);
+						RF_DBG(dm, DBG_RF_IQK, "0xc8c = 0x%x\n", odm_get_bb_reg(dm, R_0xc8c, MASKDWORD));
+					}
+				else
+					odm_write_4byte(dm, 0xc8c, 0x28160d00);
+
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20))
+							break;
+						else {
+							ODM_delay_ms(1);
+							delay_count++;
+						}
+					}
+
+					odm_set_rf_reg(dm, RF_PATH_A, RF_0xdf, 0x00800, 0x0);
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(11));
+						if (RX_fail == 0) {
+							/*
+							dbg_print("====== RXIQK (%d) ======", i);
+							odm_write_4byte(dm, 0xcb8, 0x05000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							dbg_print("reg1 = %d, reg2 = %d", reg1, reg2);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("Before PW = %d\n", image_power);
+							odm_write_4byte(dm, 0xcb8, 0x07000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("After PW = %d\n", image_power);
+							*/
+
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							RX_X0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							RX_Y0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							RX0IQKOK = true;
+							break;
+						} else {
+							odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x200 >> 1);
+							odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, 0x0 >> 1);
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						}
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK)
+				tx_average++;
+			if (RX0IQKOK)
+				rx_average++;
+		}
+		break;
+		default:
+			break;
+		}
+		cal++;
+	}
+	/* FillIQK Result */
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "========Path_A =======\n");
+		if (tx_average == 0)
+			break;
+
+		for (i = 0; i < tx_average; i++)
+			RF_DBG(dm, DBG_RF_IQK, "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i]) >> 21 & 0x000007ff, i, (TX_Y0[i]) >> 21 & 0x000007ff);
+		for (i = 0; i < tx_average; i++) {
+			for (ii = i + 1; ii < tx_average; ii++) {
+				dx = (TX_X0[i] >> 21) - (TX_X0[ii] >> 21);
+				if (dx < 3 && dx > -3) {
+					dy = (TX_Y0[i] >> 21) - (TX_Y0[ii] >> 21);
+					if (dy < 3 && dy > -3) {
+						TX_X = ((TX_X0[i] >> 21) + (TX_X0[ii] >> 21)) / 2;
+						TX_Y = ((TX_Y0[i] >> 21) + (TX_Y0[ii] >> 21)) / 2;
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (TX_finish == 1)
+			_iqk_tx_fill_iqc_8821a(dm, path, TX_X, TX_Y);
+		else
+			_iqk_tx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+
+		if (rx_average == 0)
+			break;
+
+		for (i = 0; i < rx_average; i++) {
+			RF_DBG(dm, DBG_RF_IQK, "RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i, (RX_X0[0][i]) >> 21 & 0x000007ff, i, (RX_Y0[0][i]) >> 21 & 0x000007ff);
+			if (rx_iqk_loop == 2)
+				RF_DBG(dm, DBG_RF_IQK, "RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n", i, (RX_X0[1][i]) >> 21 & 0x000007ff, i, (RX_Y0[1][i]) >> 21 & 0x000007ff);
+		}
+		for (i = 0; i < rx_average; i++) {
+			for (ii = i + 1; ii < rx_average; ii++) {
+				dx = (RX_X0[0][i] >> 21) - (RX_X0[0][ii] >> 21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y0[0][i] >> 21) - (RX_Y0[0][ii] >> 21);
+					if (dy < 4 && dy > -4) {
+						RX_X_temp = ((RX_X0[0][i] >> 21) + (RX_X0[0][ii] >> 21)) / 2;
+						RX_Y_temp = ((RX_Y0[0][i] >> 21) + (RX_Y0[0][ii] >> 21)) / 2;
+						RX_finish1 = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish1 == 1) {
+				RX_X = RX_X_temp;
+				RX_Y = RX_Y_temp;
+				break;
+			}
+		}
+		if (rx_iqk_loop == 2) {
+			for (i = 0; i < rx_average; i++) {
+				for (ii = i + 1; ii < rx_average; ii++) {
+					dx = (RX_X0[1][i] >> 21) - (RX_X0[1][ii] >> 21);
+					if (dx < 4 && dx > -4) {
+						dy = (RX_Y0[1][i] >> 21) - (RX_Y0[1][ii] >> 21);
+						if (dy < 4 && dy > -4) {
+							RX_X = ((RX_X0[1][i] >> 21) + (RX_X0[1][ii] >> 21)) / 2;
+							RX_Y = ((RX_Y0[1][i] >> 21) + (RX_Y0[1][ii] >> 21)) / 2;
+							RX_finish2 = 1;
+							break;
+						}
+					}
+				}
+				if (RX_finish2 == 1)
+					break;
+			}
+			if (RX_finish1 && RX_finish2) {
+				RX_X = (RX_X + RX_X_temp) / 2;
+				RX_Y = (RX_Y + RX_Y_temp) / 2;
+			}
+		}
+		if (RX_finish1 || RX_finish2)
+			_iqk_rx_fill_iqc_8821a(dm, path, RX_X, RX_Y);
+		else
+			_iqk_rx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+	}
+	break;
+	default:
+		break;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	if (!TX0IQKOK)
+		panic_printk("[IQK] please check TXIQK\n");
+	if (!RX0IQKOK)
+		panic_printk("[IQK] please check RXIQK\n");
+#endif
+}
+
+
+/*IQK: 0x1*/
+/*1. add IQK debug message*/
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+)
+{
+	u32	MACBB_backup[MACBB_REG_NUM_8821A], AFE_backup[AFE_REG_NUM_8821A], RFA_backup[RF_REG_NUM_8821A], RFB_backup[RF_REG_NUM_8821A];
+	u32	backup_macbb_reg[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c};
+	u32	backup_afe_reg[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u32	backup_rf_reg[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0};
+
+	_iqk_backup_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+	_iqk_backup_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_backup_rf_8821a(dm, RFA_backup, RFB_backup, backup_rf_reg, RF_REG_NUM_8821A);
+
+	_iqk_configure_mac_8821a(dm);
+	_iqk_tx_8821a(dm, RF_PATH_A);
+
+	_iqk_restore_rf_8821a(dm, RF_PATH_A, backup_rf_reg, RFA_backup, RF_REG_NUM_8821A);
+	_iqk_restore_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_restore_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+}
+
+void
+phy_reset_iqk_result_8821a(
+	struct dm_struct	*dm
+)
+{
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+	odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+	odm_write_4byte(dm, 0xce8, 0x0);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x100);
+	odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, 0x0);
+}
+
+void
+phy_iq_calibrate_8821a(
+	void		*dm_void,
+	boolean	is_recovery
+)
+{
+	struct dm_struct	*dm = (struct dm_struct *)dm_void;
+	u32			counter = 0;
+
+	_phy_iq_calibrate_8821a(dm);
+}
\ No newline at end of file
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.h /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.h
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ap.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#ifndef __HALRF_IQK_8821A_H__
+#define __HALRF_IQK_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*---------------------------End Define Parameters-------------------------------*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void
+do_iqk_8821a(
+	struct dm_struct	*dm,
+	u8		delta_thermal_index,
+	u8		thermal_value,
+	u8		threshold
+);
+void
+phy_iq_calibrate_8821a(
+	struct dm_struct	*dm,
+	boolean	is_recovery
+);
+#else
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+);
+#endif
+#endif	/*#ifndef __HALRF_IQK_8821A_H__*/
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,707 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "../../phydm_precomp.h"
+
+/*---------------------------Define Local Constant---------------------------*/
+#define cal_num_8821A 3
+#define MACBB_REG_NUM_8821A 8
+#define AFE_REG_NUM_8821A 4
+#define RF_REG_NUM_8821A 3
+/*---------------------------Define Local Constant---------------------------*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void do_iqk_8821a(void *dm_void, u8 delta_thermal_index, u8 thermal_value,
+		  u8 threshold)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+	dm->rf_calibrate_info.thermal_value_iqk = thermal_value;
+	halrf_iqk_trigger(dm, false);
+}
+#endif
+void _iqk_rx_fill_iqc_8821a(struct dm_struct *dm, enum rf_path path,
+			    unsigned int RX_X, unsigned int RX_Y)
+{
+	switch (path) {
+	case RF_PATH_A: {
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		odm_set_bb_reg(dm, R_0xc10, 0x000003ff, RX_X >> 1);
+		odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, (RX_Y >> 1) & 0x000003ff);
+		RF_DBG(dm, DBG_RF_IQK,
+		       "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X >> 1,
+		       RX_Y >> 1);
+		RF_DBG(dm, DBG_RF_IQK, "0xc10 = %x ====>fill to IQC\n",
+		       odm_read_4byte(dm, 0xc10));
+	} break;
+	default:
+		break;
+	};
+}
+
+void _iqk_tx_fill_iqc_8821a(struct dm_struct *dm, enum rf_path path,
+			    unsigned int TX_X, unsigned int TX_Y)
+{
+	switch (path) {
+	case RF_PATH_A: {
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		odm_write_4byte(dm, 0xc90, 0x00000080);
+		odm_write_4byte(dm, 0xcc4, 0x20040000);
+		odm_write_4byte(dm, 0xcc8, 0x20000000);
+		odm_set_bb_reg(dm, R_0xccc, 0x000007ff, TX_Y);
+		odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, TX_X);
+		RF_DBG(dm, DBG_RF_IQK,
+		       "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X, TX_Y);
+		RF_DBG(dm, DBG_RF_IQK,
+		       "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n",
+		       odm_get_bb_reg(dm, R_0xcd4, 0x000007ff),
+		       odm_get_bb_reg(dm, R_0xccc, 0x000007ff));
+	} break;
+	default:
+		break;
+	};
+}
+
+void _iqk_backup_mac_bb_8821a(struct dm_struct *dm, u32 *MACBB_backup,
+			      u32 *backup_macbb_reg, u32 MACBB_NUM)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < MACBB_NUM; i++)
+		MACBB_backup[i] = odm_read_4byte(dm, backup_macbb_reg[i]);
+
+	RF_DBG(dm, DBG_RF_IQK, "BackupMacBB Success!!!!\n");
+}
+
+void _iqk_backup_rf_8821a(struct dm_struct *dm, u32 *RFA_backup,
+			  u32 *RFB_backup, u32 *backup_rf_reg, u32 RF_NUM)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < RF_NUM; i++)
+		RFA_backup[i] = odm_get_rf_reg(dm, RF_PATH_A, backup_rf_reg[i], MASKDWORD);
+	RF_DBG(dm, DBG_RF_IQK, "BackupRF Success!!!!\n");
+}
+
+void _iqk_backup_afe_8821a(struct dm_struct *dm, u32 *AFE_backup,
+			   u32 *backup_afe_reg, u32 AFE_NUM)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		AFE_backup[i] = odm_read_4byte(dm, backup_afe_reg[i]);
+	RF_DBG(dm, DBG_RF_IQK, "BackupAFE Success!!!!\n");
+}
+
+void _iqk_restore_mac_bb_8821a(struct dm_struct *dm, u32 *MACBB_backup,
+			       u32 *backup_macbb_reg, u32 MACBB_NUM)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < MACBB_NUM; i++)
+		odm_write_4byte(dm, backup_macbb_reg[i], MACBB_backup[i]);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreMacBB Success!!!!\n");
+}
+
+void _iqk_restore_rf_8821a(struct dm_struct *dm, enum rf_path path,
+			   u32 *backup_rf_reg, u32 *RF_backup, u32 RF_REG_NUM)
+{
+	u32 i;
+
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	for (i = 0; i < RF_REG_NUM; i++)
+		odm_set_rf_reg(dm, (enum rf_path)path, backup_rf_reg[i], RFREGOFFSETMASK, RF_backup[i]);
+
+	switch (path) {
+	case RF_PATH_A: {
+		RF_DBG(dm, DBG_RF_IQK, "RestoreRF path A Success!!!!\n");
+	} break;
+	default:
+		break;
+	}
+}
+
+void _iqk_restore_afe_8821a(struct dm_struct *dm, u32 *AFE_backup,
+			    u32 *backup_afe_reg, u32 AFE_NUM)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		odm_write_4byte(dm, backup_afe_reg[i], AFE_backup[i]);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_write_4byte(dm, 0xc80, 0x0);
+	odm_write_4byte(dm, 0xc84, 0x0);
+	odm_write_4byte(dm, 0xc88, 0x0);
+	odm_write_4byte(dm, 0xc8c, 0x3c000000);
+	odm_write_4byte(dm, 0xc90, 0x00000080);
+	odm_write_4byte(dm, 0xc94, 0x00000000);
+	odm_write_4byte(dm, 0xcc4, 0x20040000);
+	odm_write_4byte(dm, 0xcc8, 0x20000000);
+	odm_write_4byte(dm, 0xcb8, 0x0);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreAFE Success!!!!\n");
+}
+
+void _iqk_configure_mac_8821a(struct dm_struct *dm)
+{
+	/* ========MAC register setting======== */
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_write_1byte(dm, 0x522, 0x3f);
+	odm_set_bb_reg(dm, R_0x550, BIT(11) | BIT(3), 0x0);
+	odm_write_1byte(dm, 0x808, 0x00); /*		RX ante off */
+	odm_set_bb_reg(dm, R_0x838, 0xf, 0xc); /*		CCA off */
+	odm_write_1byte(dm, 0xa07, 0xf); /*		CCK RX path off */
+}
+
+void _iqk_tx_8821a(struct dm_struct *dm, enum rf_path path)
+{
+	u32 TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0;
+	int TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, tx_average = 0, rx_average = 0, rx_iqk_loop = 0, RX_X_temp = 0, RX_Y_temp = 0;
+	int TX_X0[cal_num_8821A], TX_Y0[cal_num_8821A], RX_X0[2][cal_num_8821A], RX_Y0[2][cal_num_8821A];
+	boolean TX0IQKOK = false, RX0IQKOK = false;
+	boolean VDF_enable = false;
+	int i, k, VDF_Y[3], VDF_X[3], tx_dt[3], ii, dx = 0, dy = 0, TX_finish = 0, RX_finish1 = 0, RX_finish2 = 0;
+
+	RF_DBG(dm, DBG_RF_IQK,
+	       "band_width = %d, support_interface = %d, ext_pa = %d, ext_pa_5g = %d\n",
+	       *dm->band_width, dm->support_interface, dm->ext_pa,
+	       dm->ext_pa_5g);
+	if (*dm->band_width == 2)
+		VDF_enable = true;
+
+	while (cal < cal_num_8821A) {
+		switch (path) {
+		case RF_PATH_A: {
+			/* path-A LOK */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* ========path-A AFE all on======== */
+			/* Port 0 DAC/ADC on */
+			odm_write_4byte(dm, 0xc60, 0x77777777);
+			odm_write_4byte(dm, 0xc64, 0x77777777);
+
+			odm_write_4byte(dm, 0xc68, 0x19791979);
+
+			odm_set_bb_reg(dm, R_0xc00, 0xf, 0x4); /*	hardware 3-wire off */
+
+			/* LOK setting */
+			/* ====== LOK ====== */
+			/* 1. DAC/ADC sampling rate (160 MHz) */
+			odm_set_bb_reg(dm, R_0xc5c, BIT(26) | BIT(25) | BIT(24), 0x7);
+
+			/* 2. LoK RF setting (at BW = 20M) */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80002);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+
+			if (dm->rf_calibrate_info.is_iqk_pa_off == 1)
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3ec3);
+			else
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000); /* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000); /* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x00462910); /* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403f4);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x68163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x28163e96);
+
+			odm_write_4byte(dm, 0xc80, 0x18008c10); /* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x38008c10); /* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xcb8, 0x00100000);
+			odm_write_4byte(dm, 0x980, 0xfa000000);
+			odm_write_4byte(dm, 0x980, 0xf8000000);
+
+			ODM_delay_ms(10); /* delay 10ms */
+			odm_write_4byte(dm, 0xcb8, 0x00000000);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x58, 0x7fe00, odm_get_rf_reg(dm, (enum rf_path)path, RF_0x8, 0xffc00));
+			switch (*dm->band_width) {
+			case 1: {
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x1);
+			} break;
+			case 2: {
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x0);
+			} break;
+			default:
+				break;
+			}
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			/* 3. TX RF setting */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+
+			if (dm->rf_calibrate_info.is_iqk_pa_off == 1)
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3ec3);
+			else
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000); /* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000); /* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x0046a910); /* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403e3);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x40163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x00163e96);
+
+			if (VDF_enable == 1) {
+				for (k = 0; k <= 2; k++) {
+					switch (k) {
+					case 0: {
+						odm_write_4byte(dm, 0xc80, 0x18008c38); /* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c38); /* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					} break;
+					case 1: {
+						odm_set_bb_reg(dm, R_0xc80, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xc84, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					} break;
+					case 2: {
+						RF_DBG(dm, DBG_RF_IQK, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1] >> 21 & 0x00007ff, VDF_Y[0] >> 21 & 0x00007ff);
+						RF_DBG(dm, DBG_RF_IQK, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1] >> 21 & 0x00007ff, VDF_X[0] >> 21 & 0x00007ff);
+						tx_dt[cal] = (VDF_Y[1] >> 20) - (VDF_Y[0] >> 20);
+						tx_dt[cal] = ((16 * tx_dt[cal]) * 10000 / 15708);
+						tx_dt[cal] = (tx_dt[cal] >> 1) + (tx_dt[cal] & BIT(0));
+						odm_write_4byte(dm, 0xc80, 0x18008c20); /* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c20); /* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x1);
+						odm_set_bb_reg(dm, R_0xce8, 0x3fff0000, tx_dt[cal] & 0x00003fff);
+					} break;
+					}
+					odm_write_4byte(dm, 0xcb8, 0x00100000);
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						odm_write_4byte(dm, 0x980, 0xfa000000);
+						odm_write_4byte(dm, 0x980, 0xf8000000);
+
+						ODM_delay_ms(10); /* delay 10ms */
+						odm_write_4byte(dm, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+							if (~IQK_ready || delay_count > 20)
+								break;
+
+							ODM_delay_ms(1);
+							delay_count++;
+						}
+
+						if (delay_count < 20) { /* If 20ms No Result, then cal_retry++ */
+							/* ============TXIQK Check============== */
+							TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+							if (~TX_fail) {
+								odm_write_4byte(dm, 0xcb8, 0x02000000);
+								VDF_X[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								odm_write_4byte(dm, 0xcb8, 0x04000000);
+								VDF_Y[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								TX0IQKOK = true;
+								break;
+							}
+
+							odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+							odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					}
+				}
+				if (k == 3) {
+					TX_X0[cal] = VDF_X[k - 1];
+					TX_Y0[cal] = VDF_Y[k - 1];
+				}
+			} else {
+				odm_write_4byte(dm, 0xc80, 0x18008c10); /* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				odm_write_4byte(dm, 0xc84, 0x38008c10); /* RX_Tone_idx[9:0], RxK_Mask[29] */
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if (~IQK_ready || delay_count > 20)
+							break;
+
+						ODM_delay_ms(1);
+						delay_count++;
+					}
+
+					if (delay_count < 20) { /* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+						if (~TX_fail) {
+							odm_write_4byte(dm, 0xcb8, 0x02000000);
+							TX_X0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x04000000);
+							TX_Y0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							TX0IQKOK = true;
+							break;
+						}
+
+						odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+						odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK == false)
+				break; /* TXK fail, Don't do RXK */
+
+			/* ====== RX IQK ====== */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* 1. RX RF setting */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x30000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0002f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xfffbb);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x88001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d8);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+
+			odm_set_bb_reg(dm, R_0x978, 0x03FF8000, (TX_X0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, 0x000007FF, (TX_Y0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, BIT(31), 0x1);
+			odm_set_bb_reg(dm, R_0x97c, BIT(31), 0x0);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_write_4byte(dm, 0x984, 0x0046a911);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+			odm_write_4byte(dm, 0xc80, 0x38008c10); /* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x18008c10); /* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xc88, 0x02140119);
+
+			if (dm->support_interface == 1) {
+				rx_iqk_loop = 2; /* for 2% fail; */
+			} else
+				rx_iqk_loop = 1;
+			for (i = 0; i < rx_iqk_loop; i++) {
+				if (dm->support_interface == 1)
+					if (i == 0)
+						odm_write_4byte(dm, 0xc8c, 0x28161100); /* Good */
+					else
+						odm_write_4byte(dm, 0xc8c, 0x28160d00);
+				else
+					odm_write_4byte(dm, 0xc8c, 0x28160d00);
+
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if (~IQK_ready || delay_count > 20)
+							break;
+
+						ODM_delay_ms(1);
+						delay_count++;
+					}
+
+					if (delay_count < 20) { /* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(11));
+						if (RX_fail == 0) {
+#if 0
+							/*
+							dbg_print("====== RXIQK (%d) ======", i);
+							odm_write_4byte(dm, 0xcb8, 0x05000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							dbg_print("reg1 = %d, reg2 = %d", reg1, reg2);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("Before PW = %d\n", image_power);
+							odm_write_4byte(dm, 0xcb8, 0x07000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("After PW = %d\n", image_power);
+							*/
+#endif
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							RX_X0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							RX_Y0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							RX0IQKOK = true;
+							break;
+						}
+
+						odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x200 >> 1);
+						odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, 0x0 >> 1);
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK)
+				tx_average++;
+			if (RX0IQKOK)
+				rx_average++;
+		} break;
+		default:
+			break;
+		}
+		cal++;
+	}
+	/* FillIQK Result */
+	switch (path) {
+	case RF_PATH_A: {
+		RF_DBG(dm, DBG_RF_IQK, "========Path_A =======\n");
+		if (tx_average == 0)
+			break;
+
+		for (i = 0; i < tx_average; i++)
+			RF_DBG(dm, DBG_RF_IQK,
+			       "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i,
+			       (TX_X0[i]) >> 21 & 0x000007ff, i,
+			       (TX_Y0[i]) >> 21 & 0x000007ff);
+		for (i = 0; i < tx_average; i++) {
+			for (ii = i + 1; ii < tx_average; ii++) {
+				dx = (TX_X0[i] >> 21) - (TX_X0[ii] >> 21);
+				if (dx < 3 && dx > -3) {
+					dy = (TX_Y0[i] >> 21) - (TX_Y0[ii] >> 21);
+					if (dy < 3 && dy > -3) {
+						TX_X = ((TX_X0[i] >> 21) + (TX_X0[ii] >> 21)) / 2;
+						TX_Y = ((TX_Y0[i] >> 21) + (TX_Y0[ii] >> 21)) / 2;
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (TX_finish == 1)
+			_iqk_tx_fill_iqc_8821a(dm, path, TX_X, TX_Y);
+		else
+			_iqk_tx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+
+		if (rx_average == 0)
+			break;
+
+		for (i = 0; i < rx_average; i++) {
+			RF_DBG(dm, DBG_RF_IQK,
+			       "RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i,
+			       (RX_X0[0][i]) >> 21 & 0x000007ff, i,
+			       (RX_Y0[0][i]) >> 21 & 0x000007ff);
+			if (rx_iqk_loop == 2)
+				RF_DBG(dm, DBG_RF_IQK,
+				       "RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n",
+				       i, (RX_X0[1][i]) >> 21 & 0x000007ff, i,
+				       (RX_Y0[1][i]) >> 21 & 0x000007ff);
+		}
+		for (i = 0; i < rx_average; i++) {
+			for (ii = i + 1; ii < rx_average; ii++) {
+				dx = (RX_X0[0][i] >> 21) - (RX_X0[0][ii] >> 21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y0[0][i] >> 21) - (RX_Y0[0][ii] >> 21);
+					if (dy < 4 && dy > -4) {
+						RX_X_temp = ((RX_X0[0][i] >> 21) + (RX_X0[0][ii] >> 21)) / 2;
+						RX_Y_temp = ((RX_Y0[0][i] >> 21) + (RX_Y0[0][ii] >> 21)) / 2;
+						RX_finish1 = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish1 == 1) {
+				RX_X = RX_X_temp;
+				RX_Y = RX_Y_temp;
+				break;
+			}
+		}
+		if (rx_iqk_loop == 2) {
+			for (i = 0; i < rx_average; i++) {
+				for (ii = i + 1; ii < rx_average; ii++) {
+					dx = (RX_X0[1][i] >> 21) - (RX_X0[1][ii] >> 21);
+					if (dx < 4 && dx > -4) {
+						dy = (RX_Y0[1][i] >> 21) - (RX_Y0[1][ii] >> 21);
+						if (dy < 4 && dy > -4) {
+							RX_X = ((RX_X0[1][i] >> 21) + (RX_X0[1][ii] >> 21)) / 2;
+							RX_Y = ((RX_Y0[1][i] >> 21) + (RX_Y0[1][ii] >> 21)) / 2;
+							RX_finish2 = 1;
+							break;
+						}
+					}
+				}
+				if (RX_finish2 == 1)
+					break;
+			}
+			if (RX_finish1 && RX_finish2) {
+				RX_X = (RX_X + RX_X_temp) / 2;
+				RX_Y = (RX_Y + RX_Y_temp) / 2;
+			}
+		}
+		if (RX_finish1 || RX_finish2)
+			_iqk_rx_fill_iqc_8821a(dm, path, RX_X, RX_Y);
+		else
+			_iqk_rx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+	} break;
+	default:
+		break;
+	}
+}
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void _phy_iq_calibrate_by_fw_8821a(struct dm_struct *dm)
+{
+	u8 iqk_cmd[3] = {*dm->channel, 0x0, 0x0};
+	u8 buf1 = 0x0;
+	u8 buf2 = 0x0;
+	RF_DBG(dm, DBG_RF_IQK, "channel: %d\n", *dm->channel);
+
+	/* Byte 2, Bit 4 ~ Bit 5 : band_type */
+	if (*dm->band_type == ODM_BAND_5G)
+		buf1 = 0x2 << 4;
+	else
+		buf1 = 0x1 << 4;
+
+	/* Byte 2, Bit 0 ~ Bit 3 : bandwidth */
+	if (*dm->band_width == CHANNEL_WIDTH_20)
+		buf2 = 0x1;
+	else if (*dm->band_width == CHANNEL_WIDTH_40)
+		buf2 = 0x1 << 1;
+	else if (*dm->band_width == CHANNEL_WIDTH_80)
+		buf2 = 0x1 << 2;
+	else
+		buf2 = 0x1 << 3;
+
+	iqk_cmd[1] = buf1 | buf2;
+	iqk_cmd[2] = dm->ext_pa_5g | dm->ext_lna_5g << 1;
+
+	odm_fill_h2c_cmd(dm, ODM_H2C_IQ_CALIBRATION, 3, iqk_cmd);
+}
+#endif
+
+void _phy_iq_calibrate_8821a(struct dm_struct *dm)
+{
+	u32 MACBB_backup[MACBB_REG_NUM_8821A], AFE_backup[AFE_REG_NUM_8821A], RFA_backup[RF_REG_NUM_8821A], RFB_backup[RF_REG_NUM_8821A];
+	u32 backup_macbb_reg[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c};
+	u32 backup_afe_reg[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u32 backup_rf_reg[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0};
+
+	_iqk_backup_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+	_iqk_backup_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_backup_rf_8821a(dm, RFA_backup, RFB_backup, backup_rf_reg, RF_REG_NUM_8821A);
+
+	_iqk_configure_mac_8821a(dm);
+	_iqk_tx_8821a(dm, RF_PATH_A);
+
+	_iqk_restore_rf_8821a(dm, RF_PATH_A, backup_rf_reg, RFA_backup, RF_REG_NUM_8821A);
+	_iqk_restore_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_restore_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+}
+
+void phy_reset_iqk_result_8821a(struct dm_struct *dm)
+{
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+	odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+	odm_write_4byte(dm, 0xce8, 0x0);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x100);
+}
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+/*IQK: 0x1*/
+void phy_iq_calibrate_8821a(void *dm_void, boolean is_recovery)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+	u32 counter = 0;
+
+	if ((dm->fw_offload_ability & PHYDM_RF_IQK_OFFLOAD) && !(*dm->mp_mode)) {
+		_phy_iq_calibrate_by_fw_8821a(dm);
+		phydm_iqk_wait(dm, 500);
+		if (dm->rf_calibrate_info.is_iqk_in_progress)
+			RF_DBG(dm, DBG_RF_IQK,
+			       "== FW IQK TIMEOUT (Still in progress after 500ms) ==\n");
+	} else
+		_phy_iq_calibrate_8821a(dm);
+}
+#endif
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.h /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.h
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#ifndef __HALRF_IQK_8821A_H__
+#define __HALRF_IQK_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*---------------------------End Define Parameters-------------------------------*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void do_iqk_8821a(void *dm_void, u8 delta_thermal_index, u8 thermal_value,
+		  u8 threshold);
+void phy_iq_calibrate_8821a(void *dm_void, boolean is_recovery);
+#else
+void _phy_iq_calibrate_8821a(struct dm_struct *dm);
+#endif
+#endif /*#ifndef __HALRF_IQK_8821A_H__*/
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.c /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.c
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,777 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+
+
+/*---------------------------Define Local Constant---------------------------*/
+#define cal_num_8821A 3
+#define MACBB_REG_NUM_8821A 9
+#define AFE_REG_NUM_8821A 4
+#define RF_REG_NUM_8821A 3
+/*---------------------------Define Local Constant---------------------------*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void do_iqk_8821a(
+	struct dm_struct	*dm,
+	u8		delta_thermal_index,
+	u8		thermal_value,
+	u8		threshold
+)
+{
+	dm->rf_calibrate_info.thermal_value_iqk = thermal_value;
+	halrf_iqk_trigger(dm, false);
+}
+#endif
+void _iqk_rx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			RX_X,
+	unsigned int			RX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		odm_set_bb_reg(dm, R_0xc10, 0x000003ff, RX_X >> 1);
+		odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, (RX_Y >> 1) & 0x000003ff);
+		RF_DBG(dm, DBG_RF_IQK, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X >> 1, RX_Y >> 1);
+		RF_DBG(dm, DBG_RF_IQK, "0xc10 = %x ====>fill to IQC\n", odm_read_4byte(dm, 0xc10));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_tx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			TX_X,
+	unsigned int			TX_Y
+)
+{
+	switch (path) {
+	case RF_PATH_A:
+	{
+		odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		odm_write_4byte(dm, 0xc90, 0x00000080);
+		odm_write_4byte(dm, 0xcc4, 0x20040000);
+		odm_write_4byte(dm, 0xcc8, 0x20000000);
+		odm_set_bb_reg(dm, R_0xccc, 0x000007ff, TX_Y);
+		odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, TX_X);
+		RF_DBG(dm, DBG_RF_IQK, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X, TX_Y);
+		RF_DBG(dm, DBG_RF_IQK, "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n", odm_get_bb_reg(dm, R_0xcd4, 0x000007ff), odm_get_bb_reg(dm, R_0xccc, 0x000007ff));
+	}
+	break;
+	default:
+		break;
+	};
+}
+
+void _iqk_backup_mac_bb_8821a(
+	struct dm_struct	*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < MACBB_NUM; i++)
+		MACBB_backup[i] = odm_read_4byte(dm, backup_macbb_reg[i]);
+
+	RF_DBG(dm, DBG_RF_IQK, "BackupMacBB Success!!!!\n");
+}
+
+void _iqk_backup_rf_8821a(
+	struct dm_struct	*dm,
+	u32		*RFA_backup,
+	u32		*RFB_backup,
+	u32		*backup_rf_reg,
+	u32		RF_NUM
+)
+{
+
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < RF_NUM; i++)
+		RFA_backup[i] = odm_get_rf_reg(dm, RF_PATH_A, backup_rf_reg[i], MASKDWORD);
+	RF_DBG(dm, DBG_RF_IQK, "BackupRF Success!!!!\n");
+}
+
+void _iqk_backup_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		AFE_backup[i] = odm_read_4byte(dm, backup_afe_reg[i]);
+	RF_DBG(dm, DBG_RF_IQK, "BackupAFE Success!!!!\n");
+}
+
+void _iqk_restore_mac_bb_8821a(
+	struct dm_struct		*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < MACBB_NUM; i++)
+		odm_write_4byte(dm, backup_macbb_reg[i], MACBB_backup[i]);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreMacBB Success!!!!\n");
+}
+
+void _iqk_restore_rf_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	u32				*backup_rf_reg,
+	u32				*RF_backup,
+	u32				RF_REG_NUM
+)
+{
+	u32 i;
+
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	for (i = 0; i < RF_REG_NUM; i++)
+		odm_set_rf_reg(dm, (enum rf_path)path, backup_rf_reg[i], RFREGOFFSETMASK, RF_backup[i]);
+
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "RestoreRF path A Success!!!!\n");
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+void _iqk_restore_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+)
+{
+	u32 i;
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++)
+		odm_write_4byte(dm, backup_afe_reg[i], AFE_backup[i]);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_write_4byte(dm, 0xc80, 0x0);
+	odm_write_4byte(dm, 0xc84, 0x0);
+	odm_write_4byte(dm, 0xc88, 0x0);
+	odm_write_4byte(dm, 0xc8c, 0x3c000000);
+	odm_write_4byte(dm, 0xc90, 0x00000080);
+	odm_write_4byte(dm, 0xc94, 0x00000000);
+	odm_write_4byte(dm, 0xcc4, 0x20040000);
+	odm_write_4byte(dm, 0xcc8, 0x20000000);
+	odm_write_4byte(dm, 0xcb8, 0x0);
+	RF_DBG(dm, DBG_RF_IQK, "RestoreAFE Success!!!!\n");
+}
+
+void _iqk_configure_mac_8821a(
+	struct dm_struct		*dm
+)
+{
+	/* ========MAC register setting======== */
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_write_1byte(dm, 0x522, 0x3f);
+	odm_set_bb_reg(dm, R_0x550, BIT(11) | BIT(3), 0x0);
+	odm_write_1byte(dm, 0x808, 0x00);		/*		RX ante off */
+	odm_set_bb_reg(dm, R_0x838, 0xf, 0xc);		/*		CCA off */
+	odm_write_1byte(dm, 0xa07, 0xf);		/*		CCK RX path off */
+}
+
+void _iqk_tx_8821a(
+	struct dm_struct		*dm,
+	enum rf_path path
+)
+{
+	u32		TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0;
+	int		TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, tx_average = 0, rx_average = 0, rx_iqk_loop = 0, RX_X_temp = 0, RX_Y_temp = 0;
+	int		TX_X0[cal_num_8821A], TX_Y0[cal_num_8821A], RX_X0[2][cal_num_8821A], RX_Y0[2][cal_num_8821A];
+	boolean	TX0IQKOK = false, RX0IQKOK = false;
+	boolean	VDF_enable = false;
+	int			i, k, VDF_Y[3], VDF_X[3], tx_dt[3], ii, dx = 0, dy = 0, TX_finish = 0, RX_finish1 = 0, RX_finish2 = 0;
+
+	RF_DBG(dm, DBG_RF_IQK, "band_width = %d, support_interface = %d, ext_pa = %d, ext_pa_5g = %d\n", *dm->band_width, dm->support_interface, dm->ext_pa, dm->ext_pa_5g);
+	if (*dm->band_width == 2)
+		VDF_enable = true;
+	/*EFEM off*/
+	odm_set_bb_reg(dm, R_0xcb0, 0xf0, 0x7);
+	odm_set_bb_reg(dm, R_0xcb0, 0xf000, 0x7);
+
+	while (cal < cal_num_8821A) {
+		switch (path) {
+		case RF_PATH_A:
+		{
+			/* path-A LOK */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* ========path-A AFE all on======== */
+			/* Port 0 DAC/ADC on */
+			odm_write_4byte(dm, 0xc60, 0x77777777);
+			odm_write_4byte(dm, 0xc64, 0x77777777);
+
+			odm_write_4byte(dm, 0xc68, 0x19791979);
+
+			odm_set_bb_reg(dm, R_0xc00, 0xf, 0x4);/*	hardware 3-wire off */
+
+			/* LOK setting */
+			/* ====== LOK ====== */
+			/* 1. DAC/ADC sampling rate (160 MHz) */
+			odm_set_bb_reg(dm, R_0xc5c, BIT(26) | BIT(25) | BIT(24), 0x7);
+
+			/* 2. LoK RF setting (at BW = 20M) */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80002);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x00462910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403f4);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x68163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x28163e96);
+
+			odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xcb8, 0x00100000);
+			odm_write_4byte(dm, 0x980, 0xfa000000);
+			odm_write_4byte(dm, 0x980, 0xf8000000);
+
+			ODM_delay_ms(10); /* delay 10ms */
+			odm_write_4byte(dm, 0xcb8, 0x00000000);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x58, 0x7fe00,
+				odm_get_rf_reg(dm, (enum rf_path)path, RF_0x8, 0xffc00));
+
+			switch (*dm->band_width) {
+			case 1:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x1);
+			}
+			break;
+			case 2:
+			{
+				odm_set_rf_reg(dm, (enum rf_path)path, RF_0x18, 0x00c00, 0x0);
+			}
+			break;
+			default:
+				break;
+			}
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			/* 3. TX RF setting */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x20000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0003f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xf3fc3);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d5);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x8a001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_set_bb_reg(dm, R_0xc94, BIT(0), 0x1);
+			odm_write_4byte(dm, 0x978, 0x29002000);/* TX (X,Y) */
+			odm_write_4byte(dm, 0x97c, 0xa9002000);/* RX (X,Y) */
+			odm_write_4byte(dm, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (dm->ext_pa_5g)
+				odm_write_4byte(dm, 0xc88, 0x821403f7);
+			else
+				odm_write_4byte(dm, 0xc88, 0x821403e3);
+
+			if (*dm->band_type == ODM_BAND_5G)
+				odm_write_4byte(dm, 0xc8c, 0x40163e96);
+			else
+				odm_write_4byte(dm, 0xc8c, 0x00163e96);
+
+			if (VDF_enable == 1) {
+				for (k = 0; k <= 2; k++) {
+					switch (k) {
+					case 0:
+					{
+						odm_write_4byte(dm, 0xc80, 0x18008c38);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c38);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					}
+					break;
+					case 1:
+					{
+						odm_set_bb_reg(dm, R_0xc80, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xc84, BIT(28), 0x0);
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x0);
+					}
+					break;
+					case 2:
+					{
+						RF_DBG(dm, DBG_RF_IQK, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1] >> 21 & 0x00007ff, VDF_Y[0] >> 21 & 0x00007ff);
+						RF_DBG(dm, DBG_RF_IQK, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1] >> 21 & 0x00007ff, VDF_X[0] >> 21 & 0x00007ff);
+						tx_dt[cal] = (VDF_Y[1] >> 20) - (VDF_Y[0] >> 20);
+						tx_dt[cal] = ((16 * tx_dt[cal]) * 10000 / 15708);
+						tx_dt[cal] = (tx_dt[cal] >> 1) + (tx_dt[cal] & BIT(0));
+						odm_write_4byte(dm, 0xc80, 0x18008c20);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						odm_write_4byte(dm, 0xc84, 0x38008c20);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						odm_set_bb_reg(dm, R_0xce8, BIT(31), 0x1);
+						odm_set_bb_reg(dm, R_0xce8, 0x3fff0000, tx_dt[cal] & 0x00003fff);
+					}
+					break;
+					}
+					odm_write_4byte(dm, 0xcb8, 0x00100000);
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						odm_write_4byte(dm, 0x980, 0xfa000000);
+						odm_write_4byte(dm, 0x980, 0xf8000000);
+
+						ODM_delay_ms(10); /* delay 10ms */
+						odm_write_4byte(dm, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+							if ((~IQK_ready) || (delay_count > 20))
+								break;
+							else {
+								ODM_delay_ms(1);
+								delay_count++;
+							}
+						}
+
+						if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+							/* ============TXIQK Check============== */
+							TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+							if (~TX_fail) {
+								odm_write_4byte(dm, 0xcb8, 0x02000000);
+								VDF_X[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								odm_write_4byte(dm, 0xcb8, 0x04000000);
+								VDF_Y[k] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+								TX0IQKOK = true;
+								break;
+							} else {
+								odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+								odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+								TX0IQKOK = false;
+								cal_retry++;
+								if (cal_retry == 10)
+									break;
+							}
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					}
+				}
+				if (k == 3) {
+					TX_X0[cal] = VDF_X[k - 1] ;
+					TX_Y0[cal] = VDF_Y[k - 1];
+				}
+			} else {
+				odm_write_4byte(dm, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				odm_write_4byte(dm, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20))
+							break;
+						else {
+							ODM_delay_ms(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(12));
+
+						if (~TX_fail) {
+							odm_write_4byte(dm, 0xcb8, 0x02000000);
+							TX_X0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x04000000);
+							TX_Y0[cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							TX0IQKOK = true;
+							break;
+						} else {
+							odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+							odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK == false)
+				break;				/* TXK fail, Don't do RXK */
+
+			/* ====== RX IQK ====== */
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* 1. RX RF setting */
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x80000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x30, RFREGOFFSETMASK, 0x30000);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x31, RFREGOFFSETMASK, 0x0002f);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x32, RFREGOFFSETMASK, 0xfffbb);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x8f, RFREGOFFSETMASK, 0x88001);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0x65, RFREGOFFSETMASK, 0x931d8);
+			odm_set_rf_reg(dm, (enum rf_path)path, RF_0xef, RFREGOFFSETMASK, 0x00000);
+
+			odm_set_bb_reg(dm, R_0x978, 0x03FF8000, (TX_X0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, 0x000007FF, (TX_Y0[cal]) >> 21 & 0x000007ff);
+			odm_set_bb_reg(dm, R_0x978, BIT(31), 0x1);
+			odm_set_bb_reg(dm, R_0x97c, BIT(31), 0x0);
+			odm_write_4byte(dm, 0x90c, 0x00008000);
+			odm_write_4byte(dm, 0x984, 0x0046a911);
+
+			odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+			odm_write_4byte(dm, 0xc80, 0x38008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			odm_write_4byte(dm, 0xc84, 0x18008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			odm_write_4byte(dm, 0xc88, 0x02140119);
+
+			if (dm->support_interface == 1) {
+				rx_iqk_loop = 2;				/* for 2% fail; */
+			} else
+				rx_iqk_loop = 1;
+			for (i = 0; i < rx_iqk_loop; i++) {
+				if (dm->support_interface == 1)
+					if (i == 0)
+						odm_write_4byte(dm, 0xc8c, 0x28161100);  /* Good */
+					else
+						odm_write_4byte(dm, 0xc8c, 0x28160d00);
+				else
+					odm_write_4byte(dm, 0xc8c, 0x28160d00);
+
+				odm_write_4byte(dm, 0xcb8, 0x00100000);
+
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					odm_write_4byte(dm, 0x980, 0xfa000000);
+					odm_write_4byte(dm, 0x980, 0xf8000000);
+
+					ODM_delay_ms(10); /* delay 10ms */
+					odm_write_4byte(dm, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = odm_get_bb_reg(dm, R_0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20))
+							break;
+						else {
+							ODM_delay_ms(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = odm_get_bb_reg(dm, R_0xd00, BIT(11));
+						if (RX_fail == 0) {
+							/*
+							dbg_print("====== RXIQK (%d) ======", i);
+							odm_write_4byte(dm, 0xcb8, 0x05000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							dbg_print("reg1 = %d, reg2 = %d", reg1, reg2);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("Before PW = %d\n", image_power);
+							odm_write_4byte(dm, 0xcb8, 0x07000000);
+							reg1 = odm_get_bb_reg(dm, R_0xd00, 0xffffffff);
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							reg2 = odm_get_bb_reg(dm, R_0xd00, 0x0000001f);
+							image_power = (reg2<<32)+reg1;
+							dbg_print("After PW = %d\n", image_power);
+							*/
+
+							odm_write_4byte(dm, 0xcb8, 0x06000000);
+							RX_X0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							odm_write_4byte(dm, 0xcb8, 0x08000000);
+							RX_Y0[i][cal] = odm_get_bb_reg(dm, R_0xd00, 0x07ff0000) << 21;
+							RX0IQKOK = true;
+							break;
+						} else {
+							odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x200 >> 1);
+							odm_set_bb_reg(dm, R_0xc10, 0x03ff0000, 0x0 >> 1);
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						}
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK)
+				tx_average++;
+			if (RX0IQKOK)
+				rx_average++;
+		}
+		break;
+		default:
+			break;
+		}
+		cal++;
+	}
+	/* FillIQK Result */
+	switch (path) {
+	case RF_PATH_A:
+	{
+		RF_DBG(dm, DBG_RF_IQK, "========Path_A =======\n");
+		if (tx_average == 0)
+			break;
+
+		for (i = 0; i < tx_average; i++)
+			RF_DBG(dm, DBG_RF_IQK, "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i]) >> 21 & 0x000007ff, i, (TX_Y0[i]) >> 21 & 0x000007ff);
+		for (i = 0; i < tx_average; i++) {
+			for (ii = i + 1; ii < tx_average; ii++) {
+				dx = (TX_X0[i] >> 21) - (TX_X0[ii] >> 21);
+				if (dx < 3 && dx > -3) {
+					dy = (TX_Y0[i] >> 21) - (TX_Y0[ii] >> 21);
+					if (dy < 3 && dy > -3) {
+						TX_X = ((TX_X0[i] >> 21) + (TX_X0[ii] >> 21)) / 2;
+						TX_Y = ((TX_Y0[i] >> 21) + (TX_Y0[ii] >> 21)) / 2;
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (TX_finish == 1)
+			_iqk_tx_fill_iqc_8821a(dm, path, TX_X, TX_Y);
+		else
+			_iqk_tx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+
+		if (rx_average == 0)
+			break;
+
+		for (i = 0; i < rx_average; i++) {
+			RF_DBG(dm, DBG_RF_IQK, "RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i, (RX_X0[0][i]) >> 21 & 0x000007ff, i, (RX_Y0[0][i]) >> 21 & 0x000007ff);
+			if (rx_iqk_loop == 2)
+				RF_DBG(dm, DBG_RF_IQK, "RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n", i, (RX_X0[1][i]) >> 21 & 0x000007ff, i, (RX_Y0[1][i]) >> 21 & 0x000007ff);
+		}
+		for (i = 0; i < rx_average; i++) {
+			for (ii = i + 1; ii < rx_average; ii++) {
+				dx = (RX_X0[0][i] >> 21) - (RX_X0[0][ii] >> 21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y0[0][i] >> 21) - (RX_Y0[0][ii] >> 21);
+					if (dy < 4 && dy > -4) {
+						RX_X_temp = ((RX_X0[0][i] >> 21) + (RX_X0[0][ii] >> 21)) / 2;
+						RX_Y_temp = ((RX_Y0[0][i] >> 21) + (RX_Y0[0][ii] >> 21)) / 2;
+						RX_finish1 = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish1 == 1) {
+				RX_X = RX_X_temp;
+				RX_Y = RX_Y_temp;
+				break;
+			}
+		}
+		if (rx_iqk_loop == 2) {
+			for (i = 0; i < rx_average; i++) {
+				for (ii = i + 1; ii < rx_average; ii++) {
+					dx = (RX_X0[1][i] >> 21) - (RX_X0[1][ii] >> 21);
+					if (dx < 4 && dx > -4) {
+						dy = (RX_Y0[1][i] >> 21) - (RX_Y0[1][ii] >> 21);
+						if (dy < 4 && dy > -4) {
+							RX_X = ((RX_X0[1][i] >> 21) + (RX_X0[1][ii] >> 21)) / 2;
+							RX_Y = ((RX_Y0[1][i] >> 21) + (RX_Y0[1][ii] >> 21)) / 2;
+							RX_finish2 = 1;
+							break;
+						}
+					}
+				}
+				if (RX_finish2 == 1)
+					break;
+			}
+			if (RX_finish1 && RX_finish2) {
+				RX_X = (RX_X + RX_X_temp) / 2;
+				RX_Y = (RX_Y + RX_Y_temp) / 2;
+			}
+		}
+		if (RX_finish1 || RX_finish2)
+			_iqk_rx_fill_iqc_8821a(dm, path, RX_X, RX_Y);
+		else
+			_iqk_rx_fill_iqc_8821a(dm, path, 0x200, 0x0);
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void
+_phy_iq_calibrate_by_fw_8821a(
+	struct dm_struct	*dm
+)
+{
+
+	u8			iqk_cmd[3] = { *dm->channel, 0x0, 0x0};
+	u8			buf1 = 0x0;
+	u8			buf2 = 0x0;
+	RF_DBG(dm, DBG_RF_IQK, "channel: %d\n", *dm->channel);
+
+
+	/* Byte 2, Bit 4 ~ Bit 5 : band_type */
+	if (*dm->band_type == ODM_BAND_5G)
+		buf1 = 0x2 << 4;
+	else
+		buf1 = 0x1 << 4;
+
+	/* Byte 2, Bit 0 ~ Bit 3 : bandwidth */
+	if (*dm->band_width == CHANNEL_WIDTH_20)
+		buf2 = 0x1;
+	else if (*dm->band_width == CHANNEL_WIDTH_40)
+		buf2 = 0x1 << 1;
+	else if (*dm->band_width == CHANNEL_WIDTH_80)
+		buf2 = 0x1 << 2;
+	else
+		buf2 = 0x1 << 3;
+
+	iqk_cmd[1] = buf1 | buf2;
+	iqk_cmd[2] = dm->ext_pa_5g | dm->ext_lna_5g << 1;
+
+	RF_DBG(dm, DBG_RF_IQK, "== FW IQK Start ==\n");
+	dm->rf_calibrate_info.iqk_start_time = 0;
+	dm->rf_calibrate_info.iqk_start_time = odm_get_current_time(dm);
+	RF_DBG(dm, DBG_RF_IQK, "== start_time: %lld\n", dm->rf_calibrate_info.iqk_start_time);
+	odm_fill_h2c_cmd(dm, ODM_H2C_IQ_CALIBRATION, 3, iqk_cmd);
+
+
+}
+#endif
+
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+)
+{
+	u32	MACBB_backup[MACBB_REG_NUM_8821A], AFE_backup[AFE_REG_NUM_8821A], RFA_backup[RF_REG_NUM_8821A], RFB_backup[RF_REG_NUM_8821A];
+	u32	backup_macbb_reg[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c, 0xcb0};
+	u32	backup_afe_reg[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u32	backup_rf_reg[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0};
+
+	_iqk_backup_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+	_iqk_backup_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_backup_rf_8821a(dm, RFA_backup, RFB_backup, backup_rf_reg, RF_REG_NUM_8821A);
+
+	_iqk_configure_mac_8821a(dm);
+	_iqk_tx_8821a(dm, RF_PATH_A);
+
+	_iqk_restore_rf_8821a(dm, RF_PATH_A, backup_rf_reg, RFA_backup, RF_REG_NUM_8821A);
+	_iqk_restore_afe_8821a(dm, AFE_backup, backup_afe_reg, AFE_REG_NUM_8821A);
+	_iqk_restore_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
+}
+
+void
+phy_reset_iqk_result_8821a(
+	struct dm_struct	*dm
+)
+{
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	odm_set_bb_reg(dm, R_0xccc, 0x000007ff, 0x0);
+	odm_set_bb_reg(dm, R_0xcd4, 0x000007ff, 0x200);
+	odm_write_4byte(dm, 0xce8, 0x0);
+	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	odm_set_bb_reg(dm, R_0xc10, 0x000003ff, 0x100);
+}
+
+
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void
+phy_iq_calibrate_8821a(
+	void		*dm_void,
+	boolean	is_recovery
+)
+{
+	struct dm_struct	*dm = (struct dm_struct *)dm_void;
+	u32			counter = 0;
+
+	if ((dm->fw_offload_ability & PHYDM_RF_IQK_OFFLOAD) && !(*(dm->mp_mode))) {
+		_phy_iq_calibrate_by_fw_8821a(dm);
+		for (counter = 0; counter < 10; counter++) {
+			RF_DBG(dm, DBG_RF_IQK, "== FW IQK PROGRESS == #%d\n", counter);
+			ODM_delay_ms(50);
+			if (!dm->rf_calibrate_info.is_iqk_in_progress) {
+				RF_DBG(dm, DBG_RF_IQK, "== FW IQK RETURN FROM WAITING ==\n");
+				break;
+			}
+		}
+		if (dm->rf_calibrate_info.is_iqk_in_progress)
+			RF_DBG(dm, DBG_RF_IQK, "== FW IQK TIMEOUT (Still in progress after 500ms) ==\n");
+	} else
+		_phy_iq_calibrate_8821a(dm);
+}
+#endif
diff -Naur /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.h /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.h
--- /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_win.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#ifndef __HALRF_IQK_8821A_H__
+#define __HALRF_IQK_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*---------------------------End Define Parameters-------------------------------*/
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
+void
+do_iqk_8821a(
+	struct dm_struct	*dm,
+	u8		delta_thermal_index,
+	u8		thermal_value,
+	u8		threshold
+);
+void
+phy_iq_calibrate_8821a(
+	void		*dm_void,
+	boolean	is_recovery
+);
+#else
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+);
+#endif
+#endif	/*#ifndef __HALRF_IQK_8821A_H__*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_bb.c /hal/phydm/rtl8821a/halhwimg8821a_bb.c
--- /hal/phydm/rtl8821a/halhwimg8821a_bb.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_bb.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,906 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1)
+static boolean
+check_positive(
+	struct dm_struct     *dm,
+	const u32  condition1,
+	const u32  condition2,
+	const u32  condition3,
+	const u32  condition4
+)
+{
+	u8    _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+		    ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+		    ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+		    ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+		    ((dm->board_type & BIT(2)) >> 2) << 4;  /* _BT*/
+
+	u32	cond1   = condition1, cond2 = condition2, cond3 = condition3, cond4 = condition4;
+	u32    driver1 = dm->cut_version       << 24 |
+			 (dm->support_interface & 0xF0) << 16 |
+			 dm->support_platform  << 16 |
+			 dm->package_type      << 12 |
+			 (dm->support_interface & 0x0F) << 8  |
+			 _board_type;
+
+	u32    driver2 = (dm->type_glna & 0xFF) <<  0 |
+			 (dm->type_gpa & 0xFF)  <<  8 |
+			 (dm->type_alna & 0xFF) << 16 |
+			 (dm->type_apa & 0xFF)  << 24;
+
+	u32    driver3 = 0;
+
+	u32    driver4 = (dm->type_glna & 0xFF00) >>  8 |
+			 (dm->type_gpa & 0xFF00) |
+			 (dm->type_alna & 0xFF00) << 8 |
+			 (dm->type_apa & 0xFF00)  << 16;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, cond1, cond2, cond3, cond4);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, driver1, driver2, driver3, driver4);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		  dm->support_platform, dm->support_interface);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Board, Package) = (0x%X, 0x%X)\n", dm->board_type,
+		  dm->package_type);
+
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) && ((cond4 & bit_mask) == (driver4 & bit_mask)))  /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else
+		return false;
+}
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_agc_tab[] = {
+	0x81C, 0xBF000001,
+	0x81C, 0xBF020001,
+	0x81C, 0xBF040001,
+	0x81C, 0xBF060001,
+	0x81C, 0xBE080001,
+	0x81C, 0xBD0A0001,
+	0x81C, 0xBC0C0001,
+	0x81C, 0xBA0E0001,
+	0x81C, 0xB9100001,
+	0x81C, 0xB8120001,
+	0x81C, 0xB7140001,
+	0x81C, 0xB6160001,
+	0x81C, 0xB5180001,
+	0x81C, 0xB41A0001,
+	0x81C, 0xB31C0001,
+	0x81C, 0xB21E0001,
+	0x81C, 0xB1200001,
+	0x81C, 0xB0220001,
+	0x81C, 0xAF240001,
+	0x81C, 0xAE260001,
+	0x81C, 0xAD280001,
+	0x81C, 0xAC2A0001,
+	0x81C, 0xAB2C0001,
+	0x81C, 0xAA2E0001,
+	0x81C, 0xA9300001,
+	0x81C, 0xA8320001,
+	0x81C, 0xA7340001,
+	0x81C, 0xA6360001,
+	0x81C, 0xA5380001,
+	0x81C, 0xA43A0001,
+	0x81C, 0x683C0001,
+	0x81C, 0x673E0001,
+	0x81C, 0x66400001,
+	0x81C, 0x65420001,
+	0x81C, 0x64440001,
+	0x81C, 0x63460001,
+	0x81C, 0x62480001,
+	0x81C, 0x614A0001,
+	0x81C, 0x474C0001,
+	0x81C, 0x464E0001,
+	0x81C, 0x45500001,
+	0x81C, 0x44520001,
+	0x81C, 0x43540001,
+	0x81C, 0x42560001,
+	0x81C, 0x41580001,
+	0x81C, 0x285A0001,
+	0x81C, 0x275C0001,
+	0x81C, 0x265E0001,
+	0x81C, 0x25600001,
+	0x81C, 0x24620001,
+	0x81C, 0x0A640001,
+	0x81C, 0x09660001,
+	0x81C, 0x08680001,
+	0x81C, 0x076A0001,
+	0x81C, 0x066C0001,
+	0x81C, 0x056E0001,
+	0x81C, 0x04700001,
+	0x81C, 0x03720001,
+	0x81C, 0x02740001,
+	0x81C, 0x01760001,
+	0x81C, 0x01780001,
+	0x81C, 0x017A0001,
+	0x81C, 0x017C0001,
+	0x81C, 0x017E0001,
+	0x8000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x81C, 0xFB000101,
+	0x81C, 0xFA020101,
+	0x81C, 0xF9040101,
+	0x81C, 0xF8060101,
+	0x81C, 0xF7080101,
+	0x81C, 0xF60A0101,
+	0x81C, 0xF50C0101,
+	0x81C, 0xF40E0101,
+	0x81C, 0xF3100101,
+	0x81C, 0xF2120101,
+	0x81C, 0xF1140101,
+	0x81C, 0xF0160101,
+	0x81C, 0xEF180101,
+	0x81C, 0xEE1A0101,
+	0x81C, 0xED1C0101,
+	0x81C, 0xEC1E0101,
+	0x81C, 0xEB200101,
+	0x81C, 0xEA220101,
+	0x81C, 0xE9240101,
+	0x81C, 0xE8260101,
+	0x81C, 0xE7280101,
+	0x81C, 0xE62A0101,
+	0x81C, 0xE52C0101,
+	0x81C, 0xE42E0101,
+	0x81C, 0xE3300101,
+	0x81C, 0xA5320101,
+	0x81C, 0xA4340101,
+	0x81C, 0xA3360101,
+	0x81C, 0x87380101,
+	0x81C, 0x863A0101,
+	0x81C, 0x853C0101,
+	0x81C, 0x843E0101,
+	0x81C, 0x69400101,
+	0x81C, 0x68420101,
+	0x81C, 0x67440101,
+	0x81C, 0x66460101,
+	0x81C, 0x49480101,
+	0x81C, 0x484A0101,
+	0x81C, 0x474C0101,
+	0x81C, 0x2A4E0101,
+	0x81C, 0x29500101,
+	0x81C, 0x28520101,
+	0x81C, 0x27540101,
+	0x81C, 0x26560101,
+	0x81C, 0x25580101,
+	0x81C, 0x245A0101,
+	0x81C, 0x235C0101,
+	0x81C, 0x055E0101,
+	0x81C, 0x04600101,
+	0x81C, 0x03620101,
+	0x81C, 0x02640101,
+	0x81C, 0x01660101,
+	0x81C, 0x01680101,
+	0x81C, 0x016A0101,
+	0x81C, 0x016C0101,
+	0x81C, 0x016E0101,
+	0x81C, 0x01700101,
+	0x81C, 0x01720101,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x81C, 0xFB000101,
+	0x81C, 0xFA020101,
+	0x81C, 0xF9040101,
+	0x81C, 0xF8060101,
+	0x81C, 0xF7080101,
+	0x81C, 0xF60A0101,
+	0x81C, 0xF50C0101,
+	0x81C, 0xF40E0101,
+	0x81C, 0xF3100101,
+	0x81C, 0xF2120101,
+	0x81C, 0xF1140101,
+	0x81C, 0xF0160101,
+	0x81C, 0xEF180101,
+	0x81C, 0xEE1A0101,
+	0x81C, 0xED1C0101,
+	0x81C, 0xEC1E0101,
+	0x81C, 0xEB200101,
+	0x81C, 0xEA220101,
+	0x81C, 0xE9240101,
+	0x81C, 0xE8260101,
+	0x81C, 0xE7280101,
+	0x81C, 0xE62A0101,
+	0x81C, 0xE52C0101,
+	0x81C, 0xE42E0101,
+	0x81C, 0xE3300101,
+	0x81C, 0xA5320101,
+	0x81C, 0xA4340101,
+	0x81C, 0xA3360101,
+	0x81C, 0x87380101,
+	0x81C, 0x863A0101,
+	0x81C, 0x853C0101,
+	0x81C, 0x843E0101,
+	0x81C, 0x69400101,
+	0x81C, 0x68420101,
+	0x81C, 0x67440101,
+	0x81C, 0x66460101,
+	0x81C, 0x49480101,
+	0x81C, 0x484A0101,
+	0x81C, 0x474C0101,
+	0x81C, 0x2A4E0101,
+	0x81C, 0x29500101,
+	0x81C, 0x28520101,
+	0x81C, 0x27540101,
+	0x81C, 0x26560101,
+	0x81C, 0x25580101,
+	0x81C, 0x245A0101,
+	0x81C, 0x235C0101,
+	0x81C, 0x055E0101,
+	0x81C, 0x04600101,
+	0x81C, 0x03620101,
+	0x81C, 0x02640101,
+	0x81C, 0x01660101,
+	0x81C, 0x01680101,
+	0x81C, 0x016A0101,
+	0x81C, 0x016C0101,
+	0x81C, 0x016E0101,
+	0x81C, 0x01700101,
+	0x81C, 0x01720101,
+	0xA0000000,	0x00000000,
+	0x81C, 0xFF000101,
+	0x81C, 0xFF020101,
+	0x81C, 0xFE040101,
+	0x81C, 0xFD060101,
+	0x81C, 0xFC080101,
+	0x81C, 0xFD0A0101,
+	0x81C, 0xFC0C0101,
+	0x81C, 0xFB0E0101,
+	0x81C, 0xFA100101,
+	0x81C, 0xF9120101,
+	0x81C, 0xF8140101,
+	0x81C, 0xF7160101,
+	0x81C, 0xF6180101,
+	0x81C, 0xF51A0101,
+	0x81C, 0xF41C0101,
+	0x81C, 0xF31E0101,
+	0x81C, 0xF2200101,
+	0x81C, 0xF1220101,
+	0x81C, 0xF0240101,
+	0x81C, 0xEF260101,
+	0x81C, 0xEE280101,
+	0x81C, 0xED2A0101,
+	0x81C, 0xEC2C0101,
+	0x81C, 0xEB2E0101,
+	0x81C, 0xEA300101,
+	0x81C, 0xE9320101,
+	0x81C, 0xE8340101,
+	0x81C, 0xE7360101,
+	0x81C, 0xE6380101,
+	0x81C, 0xE53A0101,
+	0x81C, 0xE43C0101,
+	0x81C, 0xE33E0101,
+	0x81C, 0xA5400101,
+	0x81C, 0xA4420101,
+	0x81C, 0xA3440101,
+	0x81C, 0x87460101,
+	0x81C, 0x86480101,
+	0x81C, 0x854A0101,
+	0x81C, 0x844C0101,
+	0x81C, 0x694E0101,
+	0x81C, 0x68500101,
+	0x81C, 0x67520101,
+	0x81C, 0x66540101,
+	0x81C, 0x49560101,
+	0x81C, 0x48580101,
+	0x81C, 0x475A0101,
+	0x81C, 0x2A5C0101,
+	0x81C, 0x295E0101,
+	0x81C, 0x28600101,
+	0x81C, 0x27620101,
+	0x81C, 0x26640101,
+	0x81C, 0x25660101,
+	0x81C, 0x24680101,
+	0x81C, 0x236A0101,
+	0x81C, 0x056C0101,
+	0x81C, 0x046E0101,
+	0x81C, 0x03700101,
+	0x81C, 0x02720101,
+	0xB0000000,	0x00000000,
+	0x81C, 0x01740101,
+	0x81C, 0x01760101,
+	0x81C, 0x01780101,
+	0x81C, 0x017A0101,
+	0x81C, 0x017C0101,
+	0x81C, 0x017E0101,
+	0xC50, 0x00000022,
+	0xC50, 0x00000020,
+
+};
+
+void
+odm_read_and_config_mp_8821a_agc_tab(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u8     c_cond;
+	boolean is_matched = true, is_skipped = false;
+	u32     array_len    = sizeof(array_mp_8821a_agc_tab) / sizeof(u32);
+	u32    *array       = array_mp_8821a_agc_tab;
+
+	u32	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	while ((i + 1) < array_len) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & (BIT(31) | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT(31)) {/* positive condition*/
+				c_cond  = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+				if (c_cond == COND_ENDIF) {/*end*/
+					is_matched = true;
+					is_skipped = false;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ENDIF\n");
+				} else if (c_cond == COND_ELSE) { /*else*/
+					is_matched = is_skipped ? false : true;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ELSE\n");
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "IF or ELSE IF\n");
+				}
+			} else if (v1 & BIT(30)) { /*negative condition*/
+				if (is_skipped == false) {
+					if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+						is_matched = true;
+						is_skipped = true;
+					} else {
+						is_matched = false;
+						is_skipped = false;
+					}
+				} else
+					is_matched = false;
+			}
+		} else {
+			if (is_matched)
+				odm_config_bb_agc_8821a(dm, v1, MASKDWORD, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u32
+odm_get_version_mp_8821a_agc_tab(void)
+{
+	return 59;
+}
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_phy_reg[] = {
+	0x800, 0x0020D090,
+	0x804, 0x080112E0,
+	0x808, 0x0E028211,
+	0x80C, 0x92131111,
+	0x810, 0x20101261,
+	0x814, 0x020C3D10,
+	0x818, 0x03A00385,
+	0x820, 0x00000000,
+	0x824, 0x00030FE0,
+	0x828, 0x00000000,
+	0x82C, 0x002081DD,
+	0x830, 0x2AAAEEC8,
+	0x834, 0x0037A706,
+	0x838, 0x06489B44,
+	0x83C, 0x0000095B,
+	0x840, 0xC0000001,
+	0x844, 0x40003CDE,
+	0x848, 0x62103F8B,
+	0x84C, 0x6CFDFFB8,
+	0x850, 0x28874706,
+	0x854, 0x0001520C,
+	0x858, 0x8060E000,
+	0x85C, 0x74210168,
+	0x860, 0x6929C321,
+	0x864, 0x79727432,
+	0x868, 0x8CA7A314,
+	0x86C, 0x888C2878,
+	0x870, 0x08888888,
+	0x874, 0x31612C2E,
+	0x878, 0x00000152,
+	0x87C, 0x000FD000,
+	0x8A0, 0x00000013,
+	0x8A4, 0x7F7F7F7F,
+	0x8A8, 0xA2000338,
+	0x8AC, 0x0FF0FA0A,
+	0x8B4, 0x000FC080,
+	0x8B8, 0x6C10D7FF,
+	0x8BC, 0x0CA52090,
+	0x8C0, 0x1BF00020,
+	0x8C4, 0x00000000,
+	0x8C8, 0x00013169,
+	0x8CC, 0x08248492,
+	0x8D4, 0x940008A0,
+	0x8D8, 0x290B5612,
+	0x8F8, 0x400002C0,
+	0x8FC, 0x00000000,
+	0x900, 0x00000700,
+	0x90C, 0x00000000,
+	0x910, 0x0000FC00,
+	0x914, 0x00000404,
+	0x918, 0x1C1028C0,
+	0x91C, 0x64B11A1C,
+	0x920, 0xE0767233,
+	0x924, 0x055AA500,
+	0x928, 0x00000004,
+	0x92C, 0xFFFE0000,
+	0x930, 0xFFFFFFFE,
+	0x934, 0x001FFFFF,
+	0x960, 0x00000000,
+	0x964, 0x00000000,
+	0x968, 0x00000000,
+	0x96C, 0x00000000,
+	0x970, 0x801FFFFF,
+	0x974, 0x000003FF,
+	0x978, 0x00000000,
+	0x97C, 0x00000000,
+	0x980, 0x00000000,
+	0x984, 0x00000000,
+	0x988, 0x00000000,
+	0x990, 0x27100000,
+	0x994, 0xFFFF0100,
+	0x998, 0xFFFFFF5C,
+	0x99C, 0xFFFFFFFF,
+	0x9A0, 0x000000FF,
+	0x9A4, 0x00480080,
+	0x9A8, 0x00000000,
+	0x9AC, 0x00000000,
+	0x9B0, 0x81081008,
+	0x9B4, 0x01081008,
+	0x9B8, 0x01081008,
+	0x9BC, 0x01081008,
+	0x9D0, 0x00000000,
+	0x9D4, 0x00000000,
+	0x9D8, 0x00000000,
+	0x9DC, 0x00000000,
+	0x9E0, 0x00005D00,
+	0x9E4, 0x00000003,
+	0x9E8, 0x00000001,
+	0xA00, 0x00D047C8,
+	0xA04, 0x01FF800C,
+	0xA08, 0x8C8A8300,
+	0xA0C, 0x2E68000F,
+	0xA10, 0x9500BB78,
+	0xA14, 0x11144028,
+	0xA18, 0x00881117,
+	0xA1C, 0x89140F00,
+	0xA20, 0x1A1B0000,
+	0xA24, 0x090E1317,
+	0xA28, 0x00000204,
+	0xA2C, 0x00900000,
+	0xA70, 0x101FFF00,
+	0xA74, 0x00000008,
+	0xA78, 0x00000900,
+	0xA7C, 0x225B0606,
+	0xA80, 0x21805490,
+	0xA84, 0x001F0000,
+	0xB00, 0x03100040,
+	0xB04, 0x0000B000,
+	0xB08, 0xAE0201EB,
+	0xB0C, 0x01003207,
+	0xB10, 0x00009807,
+	0xB14, 0x01000000,
+	0xB18, 0x00000002,
+	0xB1C, 0x00000002,
+	0xB20, 0x0000001F,
+	0xB24, 0x03020100,
+	0xB28, 0x07060504,
+	0xB2C, 0x0B0A0908,
+	0xB30, 0x0F0E0D0C,
+	0xB34, 0x13121110,
+	0xB38, 0x17161514,
+	0xB3C, 0x0000003A,
+	0xB40, 0x00000000,
+	0xB44, 0x00000000,
+	0xB48, 0x13000032,
+	0xB4C, 0x48080000,
+	0xB50, 0x00000000,
+	0xB54, 0x00000000,
+	0xB58, 0x00000000,
+	0xB5C, 0x00000000,
+	0xC00, 0x00000007,
+	0xC04, 0x00042020,
+	0xC08, 0x80410231,
+	0xC0C, 0x00000000,
+	0xC10, 0x00000100,
+	0xC14, 0x01000000,
+	0xC1C, 0x40000003,
+	0xC20, 0x2C2C2C2C,
+	0xC24, 0x30303030,
+	0xC28, 0x30303030,
+	0xC2C, 0x2C2C2C2C,
+	0xC30, 0x2C2C2C2C,
+	0xC34, 0x2C2C2C2C,
+	0xC38, 0x2C2C2C2C,
+	0xC3C, 0x2A2A2A2A,
+	0xC40, 0x2A2A2A2A,
+	0xC44, 0x2A2A2A2A,
+	0xC48, 0x2A2A2A2A,
+	0xC4C, 0x2A2A2A2A,
+	0xC50, 0x00000020,
+	0xC54, 0x001C1208,
+	0xC58, 0x30000C1C,
+	0xC5C, 0x00000058,
+	0xC60, 0x34344443,
+	0xC64, 0x07003333,
+	0xC68, 0x19791979,
+	0xC6C, 0x19791979,
+	0xC70, 0x19791979,
+	0xC74, 0x19791979,
+	0xC78, 0x19791979,
+	0xC7C, 0x19791979,
+	0xC80, 0x19791979,
+	0xC84, 0x19791979,
+	0xC94, 0x0100005C,
+	0xC98, 0x00000000,
+	0xC9C, 0x00000000,
+	0xCA0, 0x00000029,
+	0xCA4, 0x08040201,
+	0xCA8, 0x80402010,
+	0xCB0, 0x77775747,
+	0xCB4, 0x10000077,
+	0xCB8, 0x00508240,
+
+};
+
+void
+odm_read_and_config_mp_8821a_phy_reg(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u8     c_cond;
+	boolean is_matched = true, is_skipped = false;
+	u32     array_len    = sizeof(array_mp_8821a_phy_reg) / sizeof(u32);
+	u32    *array       = array_mp_8821a_phy_reg;
+
+	u32	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	while ((i + 1) < array_len) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & (BIT(31) | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT(31)) {/* positive condition*/
+				c_cond  = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+				if (c_cond == COND_ENDIF) {/*end*/
+					is_matched = true;
+					is_skipped = false;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ENDIF\n");
+				} else if (c_cond == COND_ELSE) { /*else*/
+					is_matched = is_skipped ? false : true;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ELSE\n");
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "IF or ELSE IF\n");
+				}
+			} else if (v1 & BIT(30)) { /*negative condition*/
+				if (is_skipped == false) {
+					if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+						is_matched = true;
+						is_skipped = true;
+					} else {
+						is_matched = false;
+						is_skipped = false;
+					}
+				} else
+					is_matched = false;
+			}
+		} else {
+			if (is_matched)
+				odm_config_bb_phy_8821a(dm, v1, MASKDWORD, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u32
+odm_get_version_mp_8821a_phy_reg(void)
+{
+	return 59;
+}
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_phy_reg_pg[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x32343638,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x36363838,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28303234,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x34363838,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x26283032,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x32343636,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c44, 0x0000ffff, 0x00002022,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x34343636,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x26283032,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x32343636,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x32343636,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c44, 0x0000ffff, 0x00002022
+};
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u32     array_len    = sizeof(array_mp_8821a_phy_reg_pg) / sizeof(u32);
+	u32    *array       = array_mp_8821a_phy_reg_pg;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrByRate, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrByRate = array_len / 6;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	dm->phy_reg_pg_version = 1;
+	dm->phy_reg_pg_value_type = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < array_len; i += 6) {
+		u32 v1 = array[i];
+		u32 v2 = array[i + 1];
+		u32 v3 = array[i + 2];
+		u32 v4 = array[i + 3];
+		u32 v5 = array[i + 4];
+		u32 v6 = array[i + 5];
+
+		odm_config_bb_phy_reg_pg_8821a(dm, v1, v2, v3, v4, v5, v6);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrByRate[i / 6], 100, "%s, %s, %s, 0x%X, 0x%08X, 0x%08X,",
+			(v1 == 0 ? "2.4G" : "  5G"), (v2 == 0 ? "A" : "B"), (v3 == 0 ? "1Tx" : "2Tx"), v4, v5, v6);
+#endif
+	}
+}
+
+
+
+/******************************************************************************
+*                           PHY_REG_PG_DNI_JP.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_phy_reg_pg_dni_jp[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c44, 0x0000ffff, 0x00002424,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x23232323,
+	1, 0, 0, 0x00000c44, 0x0000ffff, 0x00002020
+};
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_dni_jp(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u32     array_len    = sizeof(array_mp_8821a_phy_reg_pg_dni_jp) / sizeof(u32);
+	u32    *array       = array_mp_8821a_phy_reg_pg_dni_jp;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrByRate, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrByRate = array_len / 6;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	dm->phy_reg_pg_version = 1;
+	dm->phy_reg_pg_value_type = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < array_len; i += 6) {
+		u32 v1 = array[i];
+		u32 v2 = array[i + 1];
+		u32 v3 = array[i + 2];
+		u32 v4 = array[i + 3];
+		u32 v5 = array[i + 4];
+		u32 v6 = array[i + 5];
+
+		odm_config_bb_phy_reg_pg_8821a(dm, v1, v2, v3, v4, v5, v6);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrByRate[i / 6], 100, "%s, %s, %s, 0x%X, 0x%08X, 0x%08X,",
+			(v1 == 0 ? "2.4G" : "  5G"), (v2 == 0 ? "A" : "B"), (v3 == 0 ? "1Tx" : "2Tx"), v4, v5, v6);
+#endif
+	}
+}
+
+
+
+/******************************************************************************
+*                           PHY_REG_PG_DNI_US.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_phy_reg_pg_dni_us[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c44, 0x0000ffff, 0x00002424,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c44, 0x0000ffff, 0x00002020
+};
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_dni_us(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u32     array_len    = sizeof(array_mp_8821a_phy_reg_pg_dni_us) / sizeof(u32);
+	u32    *array       = array_mp_8821a_phy_reg_pg_dni_us;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrByRate, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrByRate = array_len / 6;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	dm->phy_reg_pg_version = 1;
+	dm->phy_reg_pg_value_type = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < array_len; i += 6) {
+		u32 v1 = array[i];
+		u32 v2 = array[i + 1];
+		u32 v3 = array[i + 2];
+		u32 v4 = array[i + 3];
+		u32 v5 = array[i + 4];
+		u32 v6 = array[i + 5];
+
+		odm_config_bb_phy_reg_pg_8821a(dm, v1, v2, v3, v4, v5, v6);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrByRate[i / 6], 100, "%s, %s, %s, 0x%X, 0x%08X, 0x%08X,",
+			(v1 == 0 ? "2.4G" : "  5G"), (v2 == 0 ? "A" : "B"), (v3 == 0 ? "1Tx" : "2Tx"), v4, v5, v6);
+#endif
+	}
+}
+
+
+
+/******************************************************************************
+*                           PHY_REG_PG_E202SA.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_phy_reg_pg_e202sa[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x32323232,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28282828,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x22222222,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x22222222,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x32343636,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c44, 0x0000ffff, 0x00002022,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x26262626,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x20202020,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x20202020,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x16161616,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x16161616,
+	1, 0, 0, 0x00000c44, 0x0000ffff, 0x00001616
+};
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_e202_sa(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u32     array_len    = sizeof(array_mp_8821a_phy_reg_pg_e202sa) / sizeof(u32);
+	u32    *array       = array_mp_8821a_phy_reg_pg_e202sa;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrByRate, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrByRate = array_len / 6;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	dm->phy_reg_pg_version = 1;
+	dm->phy_reg_pg_value_type = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < array_len; i += 6) {
+		u32 v1 = array[i];
+		u32 v2 = array[i + 1];
+		u32 v3 = array[i + 2];
+		u32 v4 = array[i + 3];
+		u32 v5 = array[i + 4];
+		u32 v6 = array[i + 5];
+
+		odm_config_bb_phy_reg_pg_8821a(dm, v1, v2, v3, v4, v5, v6);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrByRate[i / 6], 100, "%s, %s, %s, 0x%X, 0x%08X, 0x%08X,",
+			(v1 == 0 ? "2.4G" : "  5G"), (v2 == 0 ? "A" : "B"), (v3 == 0 ? "1Tx" : "2Tx"), v4, v5, v6);
+#endif
+	}
+}
+
+
+
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_bb.h /hal/phydm/rtl8821a/halhwimg8821a_bb.h
--- /hal/phydm/rtl8821a/halhwimg8821a_bb.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_bb.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,77 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8821A_SUPPORT == 1)
+#ifndef __INC_MP_BB_HW_IMG_8821A_H
+#define __INC_MP_BB_HW_IMG_8821A_H
+
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_agc_tab( /* TC: Test Chip, MP: MP Chip*/
+				     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_agc_tab(void);
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_phy_reg( /* TC: Test Chip, MP: MP Chip*/
+				     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_phy_reg(void);
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg( /* TC: Test Chip, MP: MP Chip*/
+					struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_phy_reg_pg(void);
+
+/******************************************************************************
+*                           PHY_REG_PG_DNI_JP.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_dni_jp( /* TC: Test Chip, MP: MP Chip*/
+					       struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_phy_reg_pg_dni_jp(void);
+
+/******************************************************************************
+*                           PHY_REG_PG_DNI_US.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_dni_us( /* TC: Test Chip, MP: MP Chip*/
+					       struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_phy_reg_pg_dni_us(void);
+
+/******************************************************************************
+*                           PHY_REG_PG_E202SA.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_phy_reg_pg_e202_sa( /* TC: Test Chip, MP: MP Chip*/
+						struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_phy_reg_pg_e202sa(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_mac.c /hal/phydm/rtl8821a/halhwimg8821a_mac.c
--- /hal/phydm/rtl8821a/halhwimg8821a_mac.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_mac.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,272 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1)
+static boolean
+check_positive(
+	struct dm_struct     *dm,
+	const u32  condition1,
+	const u32  condition2,
+	const u32  condition3,
+	const u32  condition4
+)
+{
+	u8    _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+		    ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+		    ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+		    ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+		    ((dm->board_type & BIT(2)) >> 2) << 4;  /* _BT*/
+
+	u32	cond1   = condition1, cond2 = condition2, cond3 = condition3, cond4 = condition4;
+	u32    driver1 = dm->cut_version       << 24 |
+			 (dm->support_interface & 0xF0) << 16 |
+			 dm->support_platform  << 16 |
+			 dm->package_type      << 12 |
+			 (dm->support_interface & 0x0F) << 8  |
+			 _board_type;
+
+	u32    driver2 = (dm->type_glna & 0xFF) <<  0 |
+			 (dm->type_gpa & 0xFF)  <<  8 |
+			 (dm->type_alna & 0xFF) << 16 |
+			 (dm->type_apa & 0xFF)  << 24;
+
+	u32    driver3 = 0;
+
+	u32    driver4 = (dm->type_glna & 0xFF00) >>  8 |
+			 (dm->type_gpa & 0xFF00) |
+			 (dm->type_alna & 0xFF00) << 8 |
+			 (dm->type_apa & 0xFF00)  << 16;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, cond1, cond2, cond3, cond4);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, driver1, driver2, driver3, driver4);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		  dm->support_platform, dm->support_interface);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Board, Package) = (0x%X, 0x%X)\n", dm->board_type,
+		  dm->package_type);
+
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) && ((cond4 & bit_mask) == (driver4 & bit_mask)))  /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else
+		return false;
+}
+
+/******************************************************************************
+*                           MAC_REG.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_mac_reg[] = {
+	0x421, 0x0000000F,
+	0x428, 0x0000000A,
+	0x429, 0x00000010,
+	0x430, 0x00000000,
+	0x431, 0x00000000,
+	0x432, 0x00000000,
+	0x433, 0x00000001,
+	0x434, 0x00000004,
+	0x435, 0x00000005,
+	0x436, 0x00000007,
+	0x437, 0x00000008,
+	0x43C, 0x00000004,
+	0x43D, 0x00000005,
+	0x43E, 0x00000007,
+	0x43F, 0x00000008,
+	0x440, 0x0000005D,
+	0x441, 0x00000001,
+	0x442, 0x00000000,
+	0x444, 0x00000010,
+	0x445, 0x00000000,
+	0x446, 0x00000000,
+	0x447, 0x00000000,
+	0x448, 0x00000000,
+	0x449, 0x000000F0,
+	0x44A, 0x0000000F,
+	0x44B, 0x0000003E,
+	0x44C, 0x00000010,
+	0x44D, 0x00000000,
+	0x44E, 0x00000000,
+	0x44F, 0x00000000,
+	0x450, 0x00000000,
+	0x451, 0x000000F0,
+	0x452, 0x0000000F,
+	0x453, 0x00000000,
+	0x456, 0x0000005E,
+	0x460, 0x00000066,
+	0x461, 0x00000066,
+	0x4C8, 0x0000003F,
+	0x4C9, 0x000000FF,
+	0x4CC, 0x000000FF,
+	0x4CD, 0x000000FF,
+	0x4CE, 0x00000001,
+	0x500, 0x00000026,
+	0x501, 0x000000A2,
+	0x502, 0x0000002F,
+	0x503, 0x00000000,
+	0x504, 0x00000028,
+	0x505, 0x000000A3,
+	0x506, 0x0000005E,
+	0x507, 0x00000000,
+	0x508, 0x0000002B,
+	0x509, 0x000000A4,
+	0x50A, 0x0000005E,
+	0x50B, 0x00000000,
+	0x50C, 0x0000004F,
+	0x50D, 0x000000A4,
+	0x50E, 0x00000000,
+	0x50F, 0x00000000,
+	0x512, 0x0000001C,
+	0x514, 0x0000000A,
+	0x516, 0x0000000A,
+	0x525, 0x0000004F,
+	0x550, 0x00000010,
+	0x551, 0x00000010,
+	0x559, 0x00000002,
+	0x55C, 0x00000050,
+	0x55D, 0x000000FF,
+	0x605, 0x00000030,
+	0x607, 0x00000007,
+	0x608, 0x0000000E,
+	0x609, 0x0000002A,
+	0x620, 0x000000FF,
+	0x621, 0x000000FF,
+	0x622, 0x000000FF,
+	0x623, 0x000000FF,
+	0x624, 0x000000FF,
+	0x625, 0x000000FF,
+	0x626, 0x000000FF,
+	0x627, 0x000000FF,
+	0x638, 0x00000050,
+	0x63C, 0x0000000A,
+	0x63D, 0x0000000A,
+	0x63E, 0x0000000E,
+	0x63F, 0x0000000E,
+	0x640, 0x00000040,
+	0x642, 0x00000040,
+	0x643, 0x00000000,
+	0x652, 0x000000C8,
+	0x66E, 0x00000005,
+	0x700, 0x00000021,
+	0x701, 0x00000043,
+	0x702, 0x00000065,
+	0x703, 0x00000087,
+	0x708, 0x00000021,
+	0x709, 0x00000043,
+	0x70A, 0x00000065,
+	0x70B, 0x00000087,
+	0x718, 0x00000040,
+
+};
+
+void
+odm_read_and_config_mp_8821a_mac_reg(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u8     c_cond;
+	boolean is_matched = true, is_skipped = false;
+	u32     array_len    = sizeof(array_mp_8821a_mac_reg) / sizeof(u32);
+	u32    *array       = array_mp_8821a_mac_reg;
+
+	u32	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	while ((i + 1) < array_len) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & (BIT(31) | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT(31)) {/* positive condition*/
+				c_cond  = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+				if (c_cond == COND_ENDIF) {/*end*/
+					is_matched = true;
+					is_skipped = false;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ENDIF\n");
+				} else if (c_cond == COND_ELSE) { /*else*/
+					is_matched = is_skipped ? false : true;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ELSE\n");
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "IF or ELSE IF\n");
+				}
+			} else if (v1 & BIT(30)) { /*negative condition*/
+				if (is_skipped == false) {
+					if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+						is_matched = true;
+						is_skipped = true;
+					} else {
+						is_matched = false;
+						is_skipped = false;
+					}
+				} else
+					is_matched = false;
+			}
+		} else {
+			if (is_matched)
+				odm_config_mac_8821a(dm, v1, (u8)v2);
+		}
+		i = i + 2;
+	}
+}
+
+u32
+odm_get_version_mp_8821a_mac_reg(void)
+{
+	return 59;
+}
+
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_mac.h /hal/phydm/rtl8821a/halhwimg8821a_mac.h
--- /hal/phydm/rtl8821a/halhwimg8821a_mac.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_mac.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8821A_SUPPORT == 1)
+#ifndef __INC_MP_MAC_HW_IMG_8821A_H
+#define __INC_MP_MAC_HW_IMG_8821A_H
+
+
+/******************************************************************************
+*                           MAC_REG.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_mac_reg( /* TC: Test Chip, MP: MP Chip*/
+				     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_mac_reg(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_rf.c /hal/phydm/rtl8821a/halhwimg8821a_rf.c
--- /hal/phydm/rtl8821a/halhwimg8821a_rf.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_rf.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,5421 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1)
+static boolean
+check_positive(
+	struct dm_struct     *dm,
+	const u32  condition1,
+	const u32  condition2,
+	const u32  condition3,
+	const u32  condition4
+)
+{
+	u8    _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+		    ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+		    ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+		    ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+		    ((dm->board_type & BIT(2)) >> 2) << 4;  /* _BT*/
+
+	u32	cond1   = condition1, cond2 = condition2, cond3 = condition3, cond4 = condition4;
+	u32    driver1 = dm->cut_version       << 24 |
+			 (dm->support_interface & 0xF0) << 16 |
+			 dm->support_platform  << 16 |
+			 dm->package_type      << 12 |
+			 (dm->support_interface & 0x0F) << 8  |
+			 _board_type;
+
+	u32    driver2 = (dm->type_glna & 0xFF) <<  0 |
+			 (dm->type_gpa & 0xFF)  <<  8 |
+			 (dm->type_alna & 0xFF) << 16 |
+			 (dm->type_apa & 0xFF)  << 24;
+
+	u32    driver3 = 0;
+
+	u32    driver4 = (dm->type_glna & 0xFF00) >>  8 |
+			 (dm->type_gpa & 0xFF00) |
+			 (dm->type_alna & 0xFF00) << 8 |
+			 (dm->type_apa & 0xFF00)  << 16;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, cond1, cond2, cond3, cond4);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		  __func__, driver1, driver2, driver3, driver4);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		  dm->support_platform, dm->support_interface);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "	(Board, Package) = (0x%X, 0x%X)\n", dm->board_type,
+		  dm->package_type);
+
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1   &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) && ((cond4 & bit_mask) == (driver4 & bit_mask)))  /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else
+		return false;
+}
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+
+u32 array_mp_8821a_radioa[] = {
+	0x018, 0x0001712A,
+	0x056, 0x00051CF2,
+	0x066, 0x00040000,
+	0x000, 0x00010000,
+	0x01E, 0x00080000,
+	0x082, 0x00000830,
+	0x083, 0x00021800,
+	0x084, 0x00028000,
+	0x085, 0x00048000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x086, 0x0009483A,
+	0xA0000000,	0x00000000,
+	0x086, 0x00094838,
+	0xB0000000,	0x00000000,
+	0x087, 0x00044980,
+	0x088, 0x00048000,
+	0x089, 0x0000D480,
+	0x08A, 0x00042240,
+	0x08B, 0x000F0380,
+	0x08C, 0x00090000,
+	0x08D, 0x00022852,
+	0x08E, 0x00065540,
+	0x08F, 0x00088001,
+	0x0EF, 0x00020000,
+	0x03E, 0x00000380,
+	0x03F, 0x00090018,
+	0x03E, 0x00020380,
+	0x03F, 0x000A0018,
+	0x03E, 0x00040308,
+	0x03F, 0x000A0018,
+	0x03E, 0x00060018,
+	0x03F, 0x000A0018,
+	0x0EF, 0x00000000,
+	0x018, 0x0001712A,
+	0x089, 0x00000080,
+	0x08B, 0x00080180,
+	0x0EF, 0x00001000,
+	0x03A, 0x00000244,
+	0x03B, 0x00038027,
+	0x03C, 0x00082000,
+	0x03A, 0x00000244,
+	0x03B, 0x00030113,
+	0x03C, 0x00082000,
+	0x03A, 0x0000014C,
+	0x03B, 0x00028027,
+	0x03C, 0x00082000,
+	0x03A, 0x000000CC,
+	0x03B, 0x00027027,
+	0x03C, 0x00042000,
+	0x03A, 0x0000014C,
+	0x03B, 0x0001F913,
+	0x03C, 0x00042000,
+	0x03A, 0x0000010C,
+	0x03B, 0x00017F10,
+	0x03C, 0x00012000,
+	0x03A, 0x000000D0,
+	0x03B, 0x00008027,
+	0x03C, 0x000CA000,
+	0x03A, 0x00000244,
+	0x03B, 0x00078027,
+	0x03C, 0x00082000,
+	0x03A, 0x00000244,
+	0x03B, 0x00070113,
+	0x03C, 0x00082000,
+	0x03A, 0x0000014C,
+	0x03B, 0x00068027,
+	0x03C, 0x00082000,
+	0x03A, 0x000000CC,
+	0x03B, 0x00067027,
+	0x03C, 0x00042000,
+	0x03A, 0x0000014C,
+	0x03B, 0x0005F913,
+	0x03C, 0x00042000,
+	0x03A, 0x0000010C,
+	0x03B, 0x00057F10,
+	0x03C, 0x00012000,
+	0x03A, 0x000000D0,
+	0x03B, 0x00048027,
+	0x03C, 0x000CA000,
+	0x03A, 0x00000244,
+	0x03B, 0x000B8027,
+	0x03C, 0x00082000,
+	0x03A, 0x00000244,
+	0x03B, 0x000B0113,
+	0x03C, 0x00082000,
+	0x03A, 0x0000014C,
+	0x03B, 0x000A8027,
+	0x03C, 0x00082000,
+	0x03A, 0x000000CC,
+	0x03B, 0x000A7027,
+	0x03C, 0x00042000,
+	0x03A, 0x0000014C,
+	0x03B, 0x0009F913,
+	0x03C, 0x00042000,
+	0x03A, 0x0000010C,
+	0x03B, 0x00097F10,
+	0x03C, 0x00012000,
+	0x03A, 0x000000D0,
+	0x03B, 0x00088027,
+	0x03C, 0x000CA000,
+	0x0EF, 0x00000000,
+	0x0EF, 0x00001100,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004ADF3,
+	0x034, 0x00049DF0,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004ADF3,
+	0x034, 0x00049DF0,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004ADF5,
+	0x034, 0x00049DF2,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004A0F3,
+	0x034, 0x000490B1,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004A0F3,
+	0x034, 0x000490B1,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004ADF5,
+	0x034, 0x00049DF2,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0004ADF3,
+	0x034, 0x00049DF0,
+	0xA0000000,	0x00000000,
+	0x034, 0x0004ADF7,
+	0x034, 0x00049DF3,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00048DED,
+	0x034, 0x00047DEA,
+	0x034, 0x00046DE7,
+	0x034, 0x00045CE9,
+	0x034, 0x00044CE6,
+	0x034, 0x000438C6,
+	0x034, 0x00042886,
+	0x034, 0x00041486,
+	0x034, 0x00040447,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00048DED,
+	0x034, 0x00047DEA,
+	0x034, 0x00046DE7,
+	0x034, 0x00045CE9,
+	0x034, 0x00044CE6,
+	0x034, 0x000438C6,
+	0x034, 0x00042886,
+	0x034, 0x00041486,
+	0x034, 0x00040447,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000480AE,
+	0x034, 0x000470AB,
+	0x034, 0x0004608B,
+	0x034, 0x00045069,
+	0x034, 0x00044048,
+	0x034, 0x00043045,
+	0x034, 0x00042026,
+	0x034, 0x00041023,
+	0x034, 0x00040002,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000480AE,
+	0x034, 0x000470AB,
+	0x034, 0x0004608B,
+	0x034, 0x00045069,
+	0x034, 0x00044048,
+	0x034, 0x00043045,
+	0x034, 0x00042026,
+	0x034, 0x00041023,
+	0x034, 0x00040002,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00048DED,
+	0x034, 0x00047DEA,
+	0x034, 0x00046DE7,
+	0x034, 0x00045CE9,
+	0x034, 0x00044CE6,
+	0x034, 0x000438C6,
+	0x034, 0x00042886,
+	0x034, 0x00041486,
+	0x034, 0x00040447,
+	0xA0000000,	0x00000000,
+	0x034, 0x00048DEF,
+	0x034, 0x00047DEC,
+	0x034, 0x00046DE9,
+	0x034, 0x00045CCB,
+	0x034, 0x0004488D,
+	0x034, 0x0004348D,
+	0x034, 0x0004248A,
+	0x034, 0x0004108D,
+	0x034, 0x0004008A,
+	0xB0000000,	0x00000000,
+	0x80000210,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0002ADF4,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0002A0F3,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0002A0F3,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0002ADF4,
+	0xA0000000,	0x00000000,
+	0x034, 0x0002ADF7,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00029DF4,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00029DF4,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00029DF1,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000290F0,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000290F0,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00029DF1,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00029DF4,
+	0xA0000000,	0x00000000,
+	0x034, 0x00029DF2,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00028DF1,
+	0x034, 0x00027DEE,
+	0x034, 0x00026DEB,
+	0x034, 0x00025CEC,
+	0x034, 0x00024CE9,
+	0x034, 0x000238CA,
+	0x034, 0x00022889,
+	0x034, 0x00021489,
+	0x034, 0x0002044A,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00028DF1,
+	0x034, 0x00027DEE,
+	0x034, 0x00026DEB,
+	0x034, 0x00025CEC,
+	0x034, 0x00024CE9,
+	0x034, 0x000238CA,
+	0x034, 0x00022889,
+	0x034, 0x00021489,
+	0x034, 0x0002044A,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000280AF,
+	0x034, 0x000270AC,
+	0x034, 0x0002608B,
+	0x034, 0x00025069,
+	0x034, 0x00024048,
+	0x034, 0x00023045,
+	0x034, 0x00022026,
+	0x034, 0x00021023,
+	0x034, 0x00020002,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x000280AF,
+	0x034, 0x000270AC,
+	0x034, 0x0002608B,
+	0x034, 0x00025069,
+	0x034, 0x00024048,
+	0x034, 0x00023045,
+	0x034, 0x00022026,
+	0x034, 0x00021023,
+	0x034, 0x00020002,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00028DF1,
+	0x034, 0x00027DEE,
+	0x034, 0x00026DEB,
+	0x034, 0x00025CEC,
+	0x034, 0x00024CE9,
+	0x034, 0x000238CA,
+	0x034, 0x00022889,
+	0x034, 0x00021489,
+	0x034, 0x0002044A,
+	0xA0000000,	0x00000000,
+	0x034, 0x00028DEE,
+	0x034, 0x00027DEB,
+	0x034, 0x00026CCD,
+	0x034, 0x00025CCA,
+	0x034, 0x0002488C,
+	0x034, 0x0002384C,
+	0x034, 0x00022849,
+	0x034, 0x00021449,
+	0x034, 0x0002004D,
+	0xB0000000,	0x00000000,
+	0x8000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0000A0D7,
+	0x034, 0x000090D3,
+	0x034, 0x000080B1,
+	0x034, 0x000070AE,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0000A0D7,
+	0x034, 0x000090D3,
+	0x034, 0x000080B1,
+	0x034, 0x000070AE,
+	0xA0000000,	0x00000000,
+	0x034, 0x0000ADF7,
+	0x034, 0x00009DF4,
+	0x034, 0x00008DF1,
+	0x034, 0x00007DEE,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00006DEB,
+	0x034, 0x00005CEC,
+	0x034, 0x00004CE9,
+	0x034, 0x000038CA,
+	0x034, 0x00002889,
+	0x034, 0x00001489,
+	0x034, 0x0000044A,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00006DEB,
+	0x034, 0x00005CEC,
+	0x034, 0x00004CE9,
+	0x034, 0x000038CA,
+	0x034, 0x00002889,
+	0x034, 0x00001489,
+	0x034, 0x0000044A,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0000608D,
+	0x034, 0x0000506B,
+	0x034, 0x0000404A,
+	0x034, 0x00003047,
+	0x034, 0x00002044,
+	0x034, 0x00001025,
+	0x034, 0x00000004,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x0000608D,
+	0x034, 0x0000506B,
+	0x034, 0x0000404A,
+	0x034, 0x00003047,
+	0x034, 0x00002044,
+	0x034, 0x00001025,
+	0x034, 0x00000004,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x034, 0x00006DEB,
+	0x034, 0x00005CEC,
+	0x034, 0x00004CE9,
+	0x034, 0x000038CA,
+	0x034, 0x00002889,
+	0x034, 0x00001489,
+	0x034, 0x0000044A,
+	0xA0000000,	0x00000000,
+	0x034, 0x00006DCD,
+	0x034, 0x00005CCD,
+	0x034, 0x00004CCA,
+	0x034, 0x0000388C,
+	0x034, 0x00002888,
+	0x034, 0x00001488,
+	0x034, 0x00000486,
+	0xB0000000,	0x00000000,
+	0x0EF, 0x00000000,
+	0x018, 0x0001712A,
+	0x0EF, 0x00000040,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000187,
+	0x035, 0x00008187,
+	0x035, 0x00010187,
+	0x035, 0x00020188,
+	0x035, 0x00028188,
+	0x035, 0x00030188,
+	0x035, 0x00040188,
+	0x035, 0x00048188,
+	0x035, 0x00050188,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000187,
+	0x035, 0x00008187,
+	0x035, 0x00010187,
+	0x035, 0x00020188,
+	0x035, 0x00028188,
+	0x035, 0x00030188,
+	0x035, 0x00040188,
+	0x035, 0x00048188,
+	0x035, 0x00050188,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000128,
+	0x035, 0x00008128,
+	0x035, 0x00010128,
+	0x035, 0x000201C8,
+	0x035, 0x000281C8,
+	0x035, 0x000301C8,
+	0x035, 0x000401C8,
+	0x035, 0x000481C8,
+	0x035, 0x000501C8,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000145,
+	0x035, 0x00008145,
+	0x035, 0x00010145,
+	0x035, 0x00020196,
+	0x035, 0x00028196,
+	0x035, 0x00030196,
+	0x035, 0x000401C7,
+	0x035, 0x000481C7,
+	0x035, 0x000501C7,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000128,
+	0x035, 0x00008128,
+	0x035, 0x00010128,
+	0x035, 0x000201C8,
+	0x035, 0x000281C8,
+	0x035, 0x000301C8,
+	0x035, 0x000401C8,
+	0x035, 0x000481C8,
+	0x035, 0x000501C8,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x035, 0x00000187,
+	0x035, 0x00008187,
+	0x035, 0x00010187,
+	0x035, 0x00020188,
+	0x035, 0x00028188,
+	0x035, 0x00030188,
+	0x035, 0x00040188,
+	0x035, 0x00048188,
+	0x035, 0x00050188,
+	0xA0000000,	0x00000000,
+	0x035, 0x00000145,
+	0x035, 0x00008145,
+	0x035, 0x00010145,
+	0x035, 0x00020196,
+	0x035, 0x00028196,
+	0x035, 0x00030196,
+	0x035, 0x000401C7,
+	0x035, 0x000481C7,
+	0x035, 0x000501C7,
+	0xB0000000,	0x00000000,
+	0x0EF, 0x00000000,
+	0x018, 0x0001712A,
+	0x0EF, 0x00000010,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x00085733,
+	0x036, 0x0008D733,
+	0x036, 0x00095733,
+	0x036, 0x0009D733,
+	0x036, 0x000A64B4,
+	0x036, 0x000AE4B4,
+	0x036, 0x000B64B4,
+	0x036, 0x000BE4B4,
+	0x036, 0x000C64B4,
+	0x036, 0x000CE4B4,
+	0x036, 0x000D64B4,
+	0x036, 0x000DE4B4,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x00085733,
+	0x036, 0x0008D733,
+	0x036, 0x00095733,
+	0x036, 0x0009D733,
+	0x036, 0x000A64B4,
+	0x036, 0x000AE4B4,
+	0x036, 0x000B64B4,
+	0x036, 0x000BE4B4,
+	0x036, 0x000C64B4,
+	0x036, 0x000CE4B4,
+	0x036, 0x000D64B4,
+	0x036, 0x000DE4B4,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x000063B5,
+	0x036, 0x0000E3B5,
+	0x036, 0x000163B5,
+	0x036, 0x0001E3B5,
+	0x036, 0x000263B5,
+	0x036, 0x0002E3B5,
+	0x036, 0x000363B5,
+	0x036, 0x0003E3B5,
+	0x036, 0x000463B5,
+	0x036, 0x0004E3B5,
+	0x036, 0x000563B5,
+	0x036, 0x0005E3B5,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x000056B3,
+	0x036, 0x0000D6B3,
+	0x036, 0x000156B3,
+	0x036, 0x0001D6B3,
+	0x036, 0x00026634,
+	0x036, 0x0002E634,
+	0x036, 0x00036634,
+	0x036, 0x0003E634,
+	0x036, 0x000467B4,
+	0x036, 0x0004E7B4,
+	0x036, 0x000567B4,
+	0x036, 0x0005E7B4,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x000063B5,
+	0x036, 0x0000E3B5,
+	0x036, 0x000163B5,
+	0x036, 0x0001E3B5,
+	0x036, 0x000263B5,
+	0x036, 0x0002E3B5,
+	0x036, 0x000363B5,
+	0x036, 0x0003E3B5,
+	0x036, 0x000463B5,
+	0x036, 0x0004E3B5,
+	0x036, 0x000563B5,
+	0x036, 0x0005E3B5,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x036, 0x00085733,
+	0x036, 0x0008D733,
+	0x036, 0x00095733,
+	0x036, 0x0009D733,
+	0x036, 0x000A64B4,
+	0x036, 0x000AE4B4,
+	0x036, 0x000B64B4,
+	0x036, 0x000BE4B4,
+	0x036, 0x000C64B4,
+	0x036, 0x000CE4B4,
+	0x036, 0x000D64B4,
+	0x036, 0x000DE4B4,
+	0xA0000000,	0x00000000,
+	0x036, 0x000056B3,
+	0x036, 0x0000D6B3,
+	0x036, 0x000156B3,
+	0x036, 0x0001D6B3,
+	0x036, 0x00026634,
+	0x036, 0x0002E634,
+	0x036, 0x00036634,
+	0x036, 0x0003E634,
+	0x036, 0x000467B4,
+	0x036, 0x0004E7B4,
+	0x036, 0x000567B4,
+	0x036, 0x0005E7B4,
+	0xB0000000,	0x00000000,
+	0x0EF, 0x00000000,
+	0x0EF, 0x00000008,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x000001C8,
+	0x03C, 0x00000492,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x000001C8,
+	0x03C, 0x00000492,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x000001B6,
+	0x03C, 0x00000492,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x0000022A,
+	0x03C, 0x00000594,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x000001B6,
+	0x03C, 0x00000492,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x000001C8,
+	0x03C, 0x00000492,
+	0xA0000000,	0x00000000,
+	0x03C, 0x0000022A,
+	0x03C, 0x00000594,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000800,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000800,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000800,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000820,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000820,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000800,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x03C, 0x00000800,
+	0xA0000000,	0x00000000,
+	0x03C, 0x00000900,
+	0xB0000000,	0x00000000,
+	0x0EF, 0x00000000,
+	0x018, 0x0001712A,
+	0x0EF, 0x00000002,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x0004E400,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x0004E400,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x00002000,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x00002000,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x00002000,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x00002000,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x008, 0x0004E400,
+	0xA0000000,	0x00000000,
+	0x008, 0x00002000,
+	0xB0000000,	0x00000000,
+	0x0EF, 0x00000000,
+	0x0DF, 0x000000C0,
+	0x01F, 0x00000064,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x000A7284,
+	0x059, 0x000600EC,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x000A7284,
+	0x059, 0x000600EC,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x00081184,
+	0x059, 0x0006016C,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x00081184,
+	0x059, 0x0006016C,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x00081184,
+	0x059, 0x0006016C,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x058, 0x000A7284,
+	0x059, 0x000600EC,
+	0xA0000000,	0x00000000,
+	0x058, 0x00081184,
+	0x059, 0x0006016C,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000E8D73,
+	0x062, 0x00093FC5,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000E8D73,
+	0x062, 0x00093FC5,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000EFD83,
+	0x062, 0x00093FCC,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000EAD53,
+	0x062, 0x00093BC4,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000EFD83,
+	0x062, 0x00093FCC,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x061, 0x000E8D73,
+	0x062, 0x00093FC5,
+	0xA0000000,	0x00000000,
+	0x061, 0x000EAD53,
+	0x062, 0x00093BC4,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110E9,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110E9,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110EB,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110E9,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110E9,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110EB,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x063, 0x000110E9,
+	0xA0000000,	0x00000000,
+	0x063, 0x000714E9,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C27C,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C27C,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C27C,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C67C,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C27C,
+	0x90000410,	0x00000000,	0x40000000,	0x00000000,
+	0x064, 0x0001C27C,
+	0xA0000000,	0x00000000,
+	0x064, 0x0001C67C,
+	0xB0000000,	0x00000000,
+	0x80000111,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00091016,
+	0x90000110,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00091016,
+	0x90000210,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00093016,
+	0x9000020c,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00093015,
+	0x9000040c,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00093015,
+	0x90000200,	0x00000000,	0x40000000,	0x00000000,
+	0x065, 0x00093016,
+	0xA0000000,	0x00000000,
+	0x065, 0x00091016,
+	0xB0000000,	0x00000000,
+	0x018, 0x00000006,
+	0x0EF, 0x00002000,
+	0x03B, 0x0003824B,
+	0x03B, 0x0003024B,
+	0x03B, 0x0002844B,
+	0x03B, 0x00020F4B,
+	0x03B, 0x00018F4B,
+	0x03B, 0x000104B2,
+	0x03B, 0x00008049,
+	0x03B, 0x00000148,
+	0x03B, 0x0007824B,
+	0x03B, 0x0007024B,
+	0x03B, 0x0006824B,
+	0x03B, 0x00060F4B,
+	0x03B, 0x00058F4B,
+	0x03B, 0x000504B2,
+	0x03B, 0x00048049,
+	0x03B, 0x00040148,
+	0x0EF, 0x00000000,
+	0x0EF, 0x00000100,
+	0x034, 0x0000ADF3,
+	0x034, 0x00009DF0,
+	0x034, 0x00008D70,
+	0x034, 0x00007D6D,
+	0x034, 0x00006CEE,
+	0x034, 0x00005CCC,
+	0x034, 0x000044EC,
+	0x034, 0x000034AC,
+	0x034, 0x0000246D,
+	0x034, 0x0000106F,
+	0x034, 0x0000006C,
+	0x0EF, 0x00000000,
+	0x0ED, 0x00000010,
+	0x044, 0x0000ADF2,
+	0x044, 0x00009DEF,
+	0x044, 0x00008DEC,
+	0x044, 0x00007DE9,
+	0x044, 0x00006CEC,
+	0x044, 0x00005CE9,
+	0x044, 0x000044EC,
+	0x044, 0x000034E9,
+	0x044, 0x0000246C,
+	0x044, 0x00001469,
+	0x044, 0x0000006C,
+	0x0ED, 0x00000000,
+	0x0ED, 0x00000001,
+	0x040, 0x00038DA7,
+	0x040, 0x000300C2,
+	0x040, 0x000288E2,
+	0x040, 0x000200B8,
+	0x040, 0x000188A5,
+	0x040, 0x00010FBC,
+	0x040, 0x00008F71,
+	0x040, 0x00000240,
+	0x0ED, 0x00000000,
+	0x0EF, 0x000020A2,
+	0x0DF, 0x00000080,
+	0x035, 0x00000120,
+	0x035, 0x00008120,
+	0x035, 0x00010120,
+	0x036, 0x00000085,
+	0x036, 0x00008085,
+	0x036, 0x00010085,
+	0x036, 0x00018085,
+	0x0EF, 0x00000000,
+	0x051, 0x00000C31,
+	0x052, 0x00000622,
+	0x053, 0x000FC70B,
+	0x054, 0x0000017E,
+	0x056, 0x00051DF3,
+	0x051, 0x00000C01,
+	0x052, 0x000006D6,
+	0x053, 0x000FC649,
+	0x070, 0x00049661,
+	0x071, 0x0007843E,
+	0x072, 0x00000382,
+	0x074, 0x00051400,
+	0x035, 0x00000160,
+	0x035, 0x00008160,
+	0x035, 0x00010160,
+	0x036, 0x00000124,
+	0x036, 0x00008124,
+	0x036, 0x00010124,
+	0x036, 0x00018124,
+	0x0ED, 0x0000000C,
+	0x045, 0x00000140,
+	0x045, 0x00008140,
+	0x045, 0x00010140,
+	0x046, 0x00000124,
+	0x046, 0x00008124,
+	0x046, 0x00010124,
+	0x046, 0x00018124,
+	0x0DF, 0x00000088,
+	0x0B3, 0x000F0E18,
+	0x0B4, 0x0001214C,
+	0x0B7, 0x0003000C,
+	0x01C, 0x000539D2,
+	0x0C4, 0x000AFE00,
+	0x018, 0x0001F12A,
+	0xFFE, 0x00000000,
+	0xFFE, 0x00000000,
+	0x018, 0x0001712A,
+
+};
+
+void
+odm_read_and_config_mp_8821a_radioa(struct dm_struct *dm)
+{
+	u32     i         = 0;
+	u8     c_cond;
+	boolean is_matched = true, is_skipped = false;
+	u32     array_len    = sizeof(array_mp_8821a_radioa) / sizeof(u32);
+	u32    *array       = array_mp_8821a_radioa;
+
+	u32	v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	while ((i + 1) < array_len) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & (BIT(31) | BIT30)) {/*positive & negative condition*/
+			if (v1 & BIT(31)) {/* positive condition*/
+				c_cond  = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+				if (c_cond == COND_ENDIF) {/*end*/
+					is_matched = true;
+					is_skipped = false;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ENDIF\n");
+				} else if (c_cond == COND_ELSE) { /*else*/
+					is_matched = is_skipped ? false : true;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "ELSE\n");
+				} else {/*if , else if*/
+					pre_v1 = v1;
+					pre_v2 = v2;
+					PHYDM_DBG(dm, ODM_COMP_INIT, "IF or ELSE IF\n");
+				}
+			} else if (v1 & BIT(30)) { /*negative condition*/
+				if (is_skipped == false) {
+					if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+						is_matched = true;
+						is_skipped = true;
+					} else {
+						is_matched = false;
+						is_skipped = false;
+					}
+				} else
+					is_matched = false;
+			}
+		} else {
+			if (is_matched)
+				odm_config_rf_radio_a_8821a(dm, v1, v2);
+		}
+		i = i + 2;
+	}
+}
+
+u32
+odm_get_version_mp_8821a_radioa(void)
+{
+	return 59;
+}
+
+/******************************************************************************
+*                           TxPowerTrack_AP.TXT
+******************************************************************************/
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+u8 g_delta_swing_table_idx_mp_5gb_n_txpowertrack_ap_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+};
+u8 g_delta_swing_table_idx_mp_5gb_p_txpowertrack_ap_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 20},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 19, 20, 20, 20},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 21, 21},
+};
+u8 g_delta_swing_table_idx_mp_5ga_n_txpowertrack_ap_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 6, 7, 7, 8, 8, 9, 10, 11, 11, 12, 13, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_p_txpowertrack_ap_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 10, 11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 18, 19, 19, 19},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 21, 21},
+	{0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 21, 21},
+};
+u8 g_delta_swing_table_idx_mp_2gb_n_txpowertrack_ap_8821a[]    = {0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11};
+u8 g_delta_swing_table_idx_mp_2gb_p_txpowertrack_ap_8821a[]    = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9};
+u8 g_delta_swing_table_idx_mp_2ga_n_txpowertrack_ap_8821a[]    = {0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11};
+u8 g_delta_swing_table_idx_mp_2ga_p_txpowertrack_ap_8821a[]    = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_ap_8821a[] = {0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_ap_8821a[] = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_ap_8821a[] = {0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_ap_8821a[] = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9};
+#endif
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_ap(struct dm_struct *dm)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+	struct dm_rf_calibration_struct  *cali_info = &(dm->rf_calibrate_info);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_MP_8821A\n");
+
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p, g_delta_swing_table_idx_mp_2ga_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n, g_delta_swing_table_idx_mp_2ga_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p, g_delta_swing_table_idx_mp_2gb_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n, g_delta_swing_table_idx_mp_2gb_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p, g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n, g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p, g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n, g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p, g_delta_swing_table_idx_mp_5ga_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n, g_delta_swing_table_idx_mp_5ga_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p, g_delta_swing_table_idx_mp_5gb_p_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n, g_delta_swing_table_idx_mp_5gb_n_txpowertrack_ap_8821a, DELTA_SWINGIDX_SIZE * 3);
+#endif
+}
+
+/******************************************************************************
+*                           TxPowerTrack_PCIE.TXT
+******************************************************************************/
+
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+u8 g_delta_swing_table_idx_mp_5gb_n_txpowertrack_pcie_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5gb_p_txpowertrack_pcie_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_n_txpowertrack_pcie_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_p_txpowertrack_pcie_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_2gb_n_txpowertrack_pcie_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2gb_p_txpowertrack_pcie_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2ga_n_txpowertrack_pcie_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2ga_p_txpowertrack_pcie_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_pcie_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_pcie_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_pcie_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_pcie_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+#endif
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_pcie(struct dm_struct *dm)
+{
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
+	struct dm_rf_calibration_struct  *cali_info = &(dm->rf_calibrate_info);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_MP_8821A\n");
+
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p, g_delta_swing_table_idx_mp_2ga_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n, g_delta_swing_table_idx_mp_2ga_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p, g_delta_swing_table_idx_mp_2gb_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n, g_delta_swing_table_idx_mp_2gb_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p, g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n, g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p, g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n, g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p, g_delta_swing_table_idx_mp_5ga_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n, g_delta_swing_table_idx_mp_5ga_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p, g_delta_swing_table_idx_mp_5gb_p_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n, g_delta_swing_table_idx_mp_5gb_n_txpowertrack_pcie_8821a, DELTA_SWINGIDX_SIZE * 3);
+#endif
+}
+
+/******************************************************************************
+*                           TxPowerTrack_SDIO.TXT
+******************************************************************************/
+
+#if DEV_BUS_TYPE == RT_SDIO_INTERFACE
+u8 g_delta_swing_table_idx_mp_5gb_n_txpowertrack_sdio_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5gb_p_txpowertrack_sdio_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_n_txpowertrack_sdio_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_p_txpowertrack_sdio_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_2gb_n_txpowertrack_sdio_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2gb_p_txpowertrack_sdio_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2ga_n_txpowertrack_sdio_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2ga_p_txpowertrack_sdio_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_sdio_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_sdio_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_sdio_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_sdio_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+#endif
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_sdio(struct dm_struct *dm)
+{
+#if DEV_BUS_TYPE == RT_SDIO_INTERFACE
+	struct dm_rf_calibration_struct  *cali_info = &(dm->rf_calibrate_info);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_MP_8821A\n");
+
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p, g_delta_swing_table_idx_mp_2ga_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n, g_delta_swing_table_idx_mp_2ga_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p, g_delta_swing_table_idx_mp_2gb_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n, g_delta_swing_table_idx_mp_2gb_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p, g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n, g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p, g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n, g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p, g_delta_swing_table_idx_mp_5ga_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n, g_delta_swing_table_idx_mp_5ga_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p, g_delta_swing_table_idx_mp_5gb_p_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n, g_delta_swing_table_idx_mp_5gb_n_txpowertrack_sdio_8821a, DELTA_SWINGIDX_SIZE * 3);
+#endif
+}
+
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+u8 g_delta_swing_table_idx_mp_5gb_n_txpowertrack_usb_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5gb_p_txpowertrack_usb_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_n_txpowertrack_usb_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_5ga_p_txpowertrack_usb_8821a[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+	{0, 0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+u8 g_delta_swing_table_idx_mp_2gb_n_txpowertrack_usb_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2gb_p_txpowertrack_usb_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2ga_n_txpowertrack_usb_8821a[]    = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2ga_p_txpowertrack_usb_8821a[]    = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_usb_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_usb_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_usb_8821a[] = {0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10};
+u8 g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_usb_8821a[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12};
+#endif
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_usb(struct dm_struct *dm)
+{
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
+	struct dm_rf_calibration_struct  *cali_info = &(dm->rf_calibrate_info);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_MP_8821A\n");
+
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p, g_delta_swing_table_idx_mp_2ga_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n, g_delta_swing_table_idx_mp_2ga_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p, g_delta_swing_table_idx_mp_2gb_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n, g_delta_swing_table_idx_mp_2gb_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p, g_delta_swing_table_idx_mp_2g_cck_a_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n, g_delta_swing_table_idx_mp_2g_cck_a_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p, g_delta_swing_table_idx_mp_2g_cck_b_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n, g_delta_swing_table_idx_mp_2g_cck_b_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p, g_delta_swing_table_idx_mp_5ga_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n, g_delta_swing_table_idx_mp_5ga_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p, g_delta_swing_table_idx_mp_5gb_p_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n, g_delta_swing_table_idx_mp_5gb_n_txpowertrack_usb_8821a, DELTA_SWINGIDX_SIZE * 3);
+#endif
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8811AU_FEM.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8811au_fem[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "32",
+	"MKK", "5G", "20M", "HT", "1T", "36", "32",
+	"FCC", "5G", "20M", "HT", "1T", "40", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "32",
+	"MKK", "5G", "20M", "HT", "1T", "40", "32",
+	"FCC", "5G", "20M", "HT", "1T", "44", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "32",
+	"MKK", "5G", "20M", "HT", "1T", "44", "32",
+	"FCC", "5G", "20M", "HT", "1T", "48", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "32",
+	"MKK", "5G", "20M", "HT", "1T", "48", "32",
+	"FCC", "5G", "20M", "HT", "1T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "32",
+	"MKK", "5G", "20M", "HT", "1T", "52", "32",
+	"FCC", "5G", "20M", "HT", "1T", "56", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "32",
+	"MKK", "5G", "20M", "HT", "1T", "56", "32",
+	"FCC", "5G", "20M", "HT", "1T", "60", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "32",
+	"MKK", "5G", "20M", "HT", "1T", "60", "32",
+	"FCC", "5G", "20M", "HT", "1T", "64", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "32",
+	"MKK", "5G", "20M", "HT", "1T", "64", "32",
+	"FCC", "5G", "20M", "HT", "1T", "100", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "32",
+	"MKK", "5G", "20M", "HT", "1T", "100", "32",
+	"FCC", "5G", "20M", "HT", "1T", "104", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "32",
+	"MKK", "5G", "20M", "HT", "1T", "104", "32",
+	"FCC", "5G", "20M", "HT", "1T", "108", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "32",
+	"MKK", "5G", "20M", "HT", "1T", "108", "32",
+	"FCC", "5G", "20M", "HT", "1T", "112", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "32",
+	"MKK", "5G", "20M", "HT", "1T", "112", "32",
+	"FCC", "5G", "20M", "HT", "1T", "116", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "32",
+	"MKK", "5G", "20M", "HT", "1T", "116", "32",
+	"FCC", "5G", "20M", "HT", "1T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "32",
+	"MKK", "5G", "20M", "HT", "1T", "120", "32",
+	"FCC", "5G", "20M", "HT", "1T", "124", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "32",
+	"MKK", "5G", "20M", "HT", "1T", "124", "32",
+	"FCC", "5G", "20M", "HT", "1T", "128", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "32",
+	"MKK", "5G", "20M", "HT", "1T", "128", "32",
+	"FCC", "5G", "20M", "HT", "1T", "132", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "32",
+	"MKK", "5G", "20M", "HT", "1T", "132", "32",
+	"FCC", "5G", "20M", "HT", "1T", "136", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "32",
+	"MKK", "5G", "20M", "HT", "1T", "136", "32",
+	"FCC", "5G", "20M", "HT", "1T", "140", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "32",
+	"MKK", "5G", "20M", "HT", "1T", "140", "32",
+	"FCC", "5G", "20M", "HT", "1T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "32",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "32",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "32",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "32",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "32",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "32",
+	"MKK", "5G", "40M", "HT", "1T", "38", "32",
+	"FCC", "5G", "40M", "HT", "1T", "46", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "32",
+	"MKK", "5G", "40M", "HT", "1T", "46", "32",
+	"FCC", "5G", "40M", "HT", "1T", "54", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "32",
+	"MKK", "5G", "40M", "HT", "1T", "54", "32",
+	"FCC", "5G", "40M", "HT", "1T", "62", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "32",
+	"MKK", "5G", "40M", "HT", "1T", "62", "32",
+	"FCC", "5G", "40M", "HT", "1T", "102", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "32",
+	"MKK", "5G", "40M", "HT", "1T", "102", "32",
+	"FCC", "5G", "40M", "HT", "1T", "110", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "32",
+	"MKK", "5G", "40M", "HT", "1T", "110", "32",
+	"FCC", "5G", "40M", "HT", "1T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "32",
+	"MKK", "5G", "40M", "HT", "1T", "118", "32",
+	"FCC", "5G", "40M", "HT", "1T", "126", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "32",
+	"MKK", "5G", "40M", "HT", "1T", "126", "32",
+	"FCC", "5G", "40M", "HT", "1T", "134", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "32",
+	"MKK", "5G", "40M", "HT", "1T", "134", "32",
+	"FCC", "5G", "40M", "HT", "1T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "32",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "32",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "32",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8811a_u_fem(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8811au_fem) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8811au_fem;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8811AU_IPA.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8811au_ipa[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "30",
+	"MKK", "5G", "20M", "HT", "1T", "36", "30",
+	"FCC", "5G", "20M", "HT", "1T", "40", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "30",
+	"MKK", "5G", "20M", "HT", "1T", "40", "30",
+	"FCC", "5G", "20M", "HT", "1T", "44", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "30",
+	"MKK", "5G", "20M", "HT", "1T", "44", "30",
+	"FCC", "5G", "20M", "HT", "1T", "48", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "30",
+	"MKK", "5G", "20M", "HT", "1T", "48", "30",
+	"FCC", "5G", "20M", "HT", "1T", "52", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "30",
+	"MKK", "5G", "20M", "HT", "1T", "52", "30",
+	"FCC", "5G", "20M", "HT", "1T", "56", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "30",
+	"MKK", "5G", "20M", "HT", "1T", "56", "30",
+	"FCC", "5G", "20M", "HT", "1T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "30",
+	"MKK", "5G", "20M", "HT", "1T", "60", "30",
+	"FCC", "5G", "20M", "HT", "1T", "64", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "30",
+	"MKK", "5G", "20M", "HT", "1T", "64", "30",
+	"FCC", "5G", "20M", "HT", "1T", "100", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "30",
+	"MKK", "5G", "20M", "HT", "1T", "100", "30",
+	"FCC", "5G", "20M", "HT", "1T", "104", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "30",
+	"MKK", "5G", "20M", "HT", "1T", "104", "30",
+	"FCC", "5G", "20M", "HT", "1T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "30",
+	"MKK", "5G", "20M", "HT", "1T", "108", "30",
+	"FCC", "5G", "20M", "HT", "1T", "112", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "30",
+	"MKK", "5G", "20M", "HT", "1T", "112", "30",
+	"FCC", "5G", "20M", "HT", "1T", "116", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "30",
+	"MKK", "5G", "20M", "HT", "1T", "116", "30",
+	"FCC", "5G", "20M", "HT", "1T", "120", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "30",
+	"MKK", "5G", "20M", "HT", "1T", "120", "30",
+	"FCC", "5G", "20M", "HT", "1T", "124", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "30",
+	"MKK", "5G", "20M", "HT", "1T", "124", "30",
+	"FCC", "5G", "20M", "HT", "1T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "30",
+	"MKK", "5G", "20M", "HT", "1T", "128", "30",
+	"FCC", "5G", "20M", "HT", "1T", "132", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "30",
+	"MKK", "5G", "20M", "HT", "1T", "132", "30",
+	"FCC", "5G", "20M", "HT", "1T", "136", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "30",
+	"MKK", "5G", "20M", "HT", "1T", "136", "30",
+	"FCC", "5G", "20M", "HT", "1T", "140", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "30",
+	"MKK", "5G", "20M", "HT", "1T", "140", "30",
+	"FCC", "5G", "20M", "HT", "1T", "149", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "30",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "30",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "30",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "30",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "30",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "30",
+	"MKK", "5G", "40M", "HT", "1T", "38", "30",
+	"FCC", "5G", "40M", "HT", "1T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "30",
+	"MKK", "5G", "40M", "HT", "1T", "46", "30",
+	"FCC", "5G", "40M", "HT", "1T", "54", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "30",
+	"MKK", "5G", "40M", "HT", "1T", "54", "30",
+	"FCC", "5G", "40M", "HT", "1T", "62", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "30",
+	"MKK", "5G", "40M", "HT", "1T", "62", "30",
+	"FCC", "5G", "40M", "HT", "1T", "102", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "30",
+	"MKK", "5G", "40M", "HT", "1T", "102", "30",
+	"FCC", "5G", "40M", "HT", "1T", "110", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "30",
+	"MKK", "5G", "40M", "HT", "1T", "110", "30",
+	"FCC", "5G", "40M", "HT", "1T", "118", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "30",
+	"MKK", "5G", "40M", "HT", "1T", "118", "30",
+	"FCC", "5G", "40M", "HT", "1T", "126", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "30",
+	"MKK", "5G", "40M", "HT", "1T", "126", "30",
+	"FCC", "5G", "40M", "HT", "1T", "134", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "30",
+	"MKK", "5G", "40M", "HT", "1T", "134", "30",
+	"FCC", "5G", "40M", "HT", "1T", "151", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "30",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "30",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8811a_u_ipa(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8811au_ipa) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8811au_ipa;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8821a[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "30",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "30",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "26",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "26",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "30",
+	"MKK", "5G", "20M", "HT", "1T", "36", "30",
+	"FCC", "5G", "20M", "HT", "1T", "40", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "30",
+	"MKK", "5G", "20M", "HT", "1T", "40", "30",
+	"FCC", "5G", "20M", "HT", "1T", "44", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "30",
+	"MKK", "5G", "20M", "HT", "1T", "44", "30",
+	"FCC", "5G", "20M", "HT", "1T", "48", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "30",
+	"MKK", "5G", "20M", "HT", "1T", "48", "30",
+	"FCC", "5G", "20M", "HT", "1T", "52", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "30",
+	"MKK", "5G", "20M", "HT", "1T", "52", "30",
+	"FCC", "5G", "20M", "HT", "1T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "30",
+	"MKK", "5G", "20M", "HT", "1T", "56", "30",
+	"FCC", "5G", "20M", "HT", "1T", "60", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "30",
+	"MKK", "5G", "20M", "HT", "1T", "60", "30",
+	"FCC", "5G", "20M", "HT", "1T", "64", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "30",
+	"MKK", "5G", "20M", "HT", "1T", "64", "30",
+	"FCC", "5G", "20M", "HT", "1T", "100", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "30",
+	"MKK", "5G", "20M", "HT", "1T", "100", "30",
+	"FCC", "5G", "20M", "HT", "1T", "104", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "30",
+	"MKK", "5G", "20M", "HT", "1T", "104", "30",
+	"FCC", "5G", "20M", "HT", "1T", "108", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "30",
+	"MKK", "5G", "20M", "HT", "1T", "108", "30",
+	"FCC", "5G", "20M", "HT", "1T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "30",
+	"MKK", "5G", "20M", "HT", "1T", "112", "30",
+	"FCC", "5G", "20M", "HT", "1T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "30",
+	"MKK", "5G", "20M", "HT", "1T", "116", "30",
+	"FCC", "5G", "20M", "HT", "1T", "120", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "30",
+	"MKK", "5G", "20M", "HT", "1T", "120", "30",
+	"FCC", "5G", "20M", "HT", "1T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "30",
+	"MKK", "5G", "20M", "HT", "1T", "124", "30",
+	"FCC", "5G", "20M", "HT", "1T", "128", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "30",
+	"MKK", "5G", "20M", "HT", "1T", "128", "30",
+	"FCC", "5G", "20M", "HT", "1T", "132", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "30",
+	"MKK", "5G", "20M", "HT", "1T", "132", "30",
+	"FCC", "5G", "20M", "HT", "1T", "136", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "30",
+	"MKK", "5G", "20M", "HT", "1T", "136", "30",
+	"FCC", "5G", "20M", "HT", "1T", "140", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "30",
+	"MKK", "5G", "20M", "HT", "1T", "140", "30",
+	"FCC", "5G", "20M", "HT", "1T", "149", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "30",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "30",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "30",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "30",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "30",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "30",
+	"MKK", "5G", "40M", "HT", "1T", "38", "30",
+	"FCC", "5G", "40M", "HT", "1T", "46", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "30",
+	"MKK", "5G", "40M", "HT", "1T", "46", "30",
+	"FCC", "5G", "40M", "HT", "1T", "54", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "30",
+	"MKK", "5G", "40M", "HT", "1T", "54", "30",
+	"FCC", "5G", "40M", "HT", "1T", "62", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "30",
+	"MKK", "5G", "40M", "HT", "1T", "62", "30",
+	"FCC", "5G", "40M", "HT", "1T", "102", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "30",
+	"MKK", "5G", "40M", "HT", "1T", "102", "30",
+	"FCC", "5G", "40M", "HT", "1T", "110", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "30",
+	"MKK", "5G", "40M", "HT", "1T", "110", "30",
+	"FCC", "5G", "40M", "HT", "1T", "118", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "30",
+	"MKK", "5G", "40M", "HT", "1T", "118", "30",
+	"FCC", "5G", "40M", "HT", "1T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "30",
+	"MKK", "5G", "40M", "HT", "1T", "126", "30",
+	"FCC", "5G", "40M", "HT", "1T", "134", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "30",
+	"MKK", "5G", "40M", "HT", "1T", "134", "30",
+	"FCC", "5G", "40M", "HT", "1T", "151", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "30",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "30",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "22",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "28",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8821a) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8821a;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_E202SA.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8821a_e202sa[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "27",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "27",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "27",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "27",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "22",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "28",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "20",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "20",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "20",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "28",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "16",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "15",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "15",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "15",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "26",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "26",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "16",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "16",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "16",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "16",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "22",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "22",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "24",
+	"MKK", "5G", "20M", "HT", "1T", "36", "24",
+	"FCC", "5G", "20M", "HT", "1T", "40", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "24",
+	"MKK", "5G", "20M", "HT", "1T", "40", "24",
+	"FCC", "5G", "20M", "HT", "1T", "44", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "24",
+	"MKK", "5G", "20M", "HT", "1T", "44", "24",
+	"FCC", "5G", "20M", "HT", "1T", "48", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "24",
+	"MKK", "5G", "20M", "HT", "1T", "48", "24",
+	"FCC", "5G", "20M", "HT", "1T", "52", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "24",
+	"MKK", "5G", "20M", "HT", "1T", "52", "24",
+	"FCC", "5G", "20M", "HT", "1T", "56", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "24",
+	"MKK", "5G", "20M", "HT", "1T", "56", "24",
+	"FCC", "5G", "20M", "HT", "1T", "60", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "24",
+	"MKK", "5G", "20M", "HT", "1T", "60", "24",
+	"FCC", "5G", "20M", "HT", "1T", "64", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "24",
+	"MKK", "5G", "20M", "HT", "1T", "64", "24",
+	"FCC", "5G", "20M", "HT", "1T", "100", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "24",
+	"MKK", "5G", "20M", "HT", "1T", "100", "24",
+	"FCC", "5G", "20M", "HT", "1T", "104", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "24",
+	"MKK", "5G", "20M", "HT", "1T", "104", "24",
+	"FCC", "5G", "20M", "HT", "1T", "108", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "24",
+	"MKK", "5G", "20M", "HT", "1T", "108", "24",
+	"FCC", "5G", "20M", "HT", "1T", "112", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "24",
+	"MKK", "5G", "20M", "HT", "1T", "112", "24",
+	"FCC", "5G", "20M", "HT", "1T", "116", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "24",
+	"MKK", "5G", "20M", "HT", "1T", "116", "24",
+	"FCC", "5G", "20M", "HT", "1T", "120", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "24",
+	"MKK", "5G", "20M", "HT", "1T", "120", "24",
+	"FCC", "5G", "20M", "HT", "1T", "124", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "24",
+	"MKK", "5G", "20M", "HT", "1T", "124", "24",
+	"FCC", "5G", "20M", "HT", "1T", "128", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "24",
+	"MKK", "5G", "20M", "HT", "1T", "128", "24",
+	"FCC", "5G", "20M", "HT", "1T", "132", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "24",
+	"MKK", "5G", "20M", "HT", "1T", "132", "24",
+	"FCC", "5G", "20M", "HT", "1T", "136", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "24",
+	"MKK", "5G", "20M", "HT", "1T", "136", "24",
+	"FCC", "5G", "20M", "HT", "1T", "140", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "24",
+	"MKK", "5G", "20M", "HT", "1T", "140", "24",
+	"FCC", "5G", "20M", "HT", "1T", "149", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "24",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "24",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "24",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "24",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "24",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "24",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "20",
+	"MKK", "5G", "40M", "HT", "1T", "38", "20",
+	"FCC", "5G", "40M", "HT", "1T", "46", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "20",
+	"MKK", "5G", "40M", "HT", "1T", "46", "20",
+	"FCC", "5G", "40M", "HT", "1T", "54", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "20",
+	"MKK", "5G", "40M", "HT", "1T", "54", "20",
+	"FCC", "5G", "40M", "HT", "1T", "62", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "20",
+	"MKK", "5G", "40M", "HT", "1T", "62", "20",
+	"FCC", "5G", "40M", "HT", "1T", "102", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "20",
+	"MKK", "5G", "40M", "HT", "1T", "102", "20",
+	"FCC", "5G", "40M", "HT", "1T", "110", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "20",
+	"MKK", "5G", "40M", "HT", "1T", "110", "20",
+	"FCC", "5G", "40M", "HT", "1T", "118", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "20",
+	"MKK", "5G", "40M", "HT", "1T", "118", "20",
+	"FCC", "5G", "40M", "HT", "1T", "126", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "20",
+	"MKK", "5G", "40M", "HT", "1T", "126", "20",
+	"FCC", "5G", "40M", "HT", "1T", "134", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "20",
+	"MKK", "5G", "40M", "HT", "1T", "134", "20",
+	"FCC", "5G", "40M", "HT", "1T", "151", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "20",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "20",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "20",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "16",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "16",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "16",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "16",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "16",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "16",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "16",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "16",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "16",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "16",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "16",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "16",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "16",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "16",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_e202sa(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8821a_e202sa) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8821a_e202sa;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_13dBm.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8821a_sar_13dbm[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "26",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "26",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "26",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "26",
+	"MKK", "5G", "20M", "HT", "1T", "36", "26",
+	"FCC", "5G", "20M", "HT", "1T", "40", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "26",
+	"MKK", "5G", "20M", "HT", "1T", "40", "26",
+	"FCC", "5G", "20M", "HT", "1T", "44", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "26",
+	"MKK", "5G", "20M", "HT", "1T", "44", "26",
+	"FCC", "5G", "20M", "HT", "1T", "48", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "26",
+	"MKK", "5G", "20M", "HT", "1T", "48", "26",
+	"FCC", "5G", "20M", "HT", "1T", "52", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "26",
+	"MKK", "5G", "20M", "HT", "1T", "52", "26",
+	"FCC", "5G", "20M", "HT", "1T", "56", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "26",
+	"MKK", "5G", "20M", "HT", "1T", "56", "26",
+	"FCC", "5G", "20M", "HT", "1T", "60", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "26",
+	"MKK", "5G", "20M", "HT", "1T", "60", "26",
+	"FCC", "5G", "20M", "HT", "1T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "26",
+	"MKK", "5G", "20M", "HT", "1T", "64", "26",
+	"FCC", "5G", "20M", "HT", "1T", "100", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "26",
+	"MKK", "5G", "20M", "HT", "1T", "100", "26",
+	"FCC", "5G", "20M", "HT", "1T", "104", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "26",
+	"MKK", "5G", "20M", "HT", "1T", "104", "26",
+	"FCC", "5G", "20M", "HT", "1T", "108", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "26",
+	"MKK", "5G", "20M", "HT", "1T", "108", "26",
+	"FCC", "5G", "20M", "HT", "1T", "112", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "26",
+	"MKK", "5G", "20M", "HT", "1T", "112", "26",
+	"FCC", "5G", "20M", "HT", "1T", "116", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "26",
+	"MKK", "5G", "20M", "HT", "1T", "116", "26",
+	"FCC", "5G", "20M", "HT", "1T", "120", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "26",
+	"MKK", "5G", "20M", "HT", "1T", "120", "26",
+	"FCC", "5G", "20M", "HT", "1T", "124", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "26",
+	"MKK", "5G", "20M", "HT", "1T", "124", "26",
+	"FCC", "5G", "20M", "HT", "1T", "128", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "26",
+	"MKK", "5G", "20M", "HT", "1T", "128", "26",
+	"FCC", "5G", "20M", "HT", "1T", "132", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "26",
+	"MKK", "5G", "20M", "HT", "1T", "132", "26",
+	"FCC", "5G", "20M", "HT", "1T", "136", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "26",
+	"MKK", "5G", "20M", "HT", "1T", "136", "26",
+	"FCC", "5G", "20M", "HT", "1T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "26",
+	"MKK", "5G", "20M", "HT", "1T", "140", "26",
+	"FCC", "5G", "20M", "HT", "1T", "149", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "26",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "26",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "26",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "26",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "26",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "26",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "26",
+	"MKK", "5G", "20M", "HT", "2T", "36", "26",
+	"FCC", "5G", "20M", "HT", "2T", "40", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "26",
+	"MKK", "5G", "20M", "HT", "2T", "40", "26",
+	"FCC", "5G", "20M", "HT", "2T", "44", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "26",
+	"MKK", "5G", "20M", "HT", "2T", "44", "26",
+	"FCC", "5G", "20M", "HT", "2T", "48", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "26",
+	"MKK", "5G", "20M", "HT", "2T", "48", "26",
+	"FCC", "5G", "20M", "HT", "2T", "52", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "26",
+	"MKK", "5G", "20M", "HT", "2T", "52", "26",
+	"FCC", "5G", "20M", "HT", "2T", "56", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "26",
+	"MKK", "5G", "20M", "HT", "2T", "56", "26",
+	"FCC", "5G", "20M", "HT", "2T", "60", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "26",
+	"MKK", "5G", "20M", "HT", "2T", "60", "26",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "26",
+	"MKK", "5G", "20M", "HT", "2T", "64", "26",
+	"FCC", "5G", "20M", "HT", "2T", "100", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "26",
+	"MKK", "5G", "20M", "HT", "2T", "100", "26",
+	"FCC", "5G", "20M", "HT", "2T", "104", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "26",
+	"MKK", "5G", "20M", "HT", "2T", "104", "26",
+	"FCC", "5G", "20M", "HT", "2T", "108", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "26",
+	"MKK", "5G", "20M", "HT", "2T", "108", "26",
+	"FCC", "5G", "20M", "HT", "2T", "112", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "26",
+	"MKK", "5G", "20M", "HT", "2T", "112", "26",
+	"FCC", "5G", "20M", "HT", "2T", "116", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "26",
+	"MKK", "5G", "20M", "HT", "2T", "116", "26",
+	"FCC", "5G", "20M", "HT", "2T", "120", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "26",
+	"MKK", "5G", "20M", "HT", "2T", "120", "26",
+	"FCC", "5G", "20M", "HT", "2T", "124", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "26",
+	"MKK", "5G", "20M", "HT", "2T", "124", "26",
+	"FCC", "5G", "20M", "HT", "2T", "128", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "26",
+	"MKK", "5G", "20M", "HT", "2T", "128", "26",
+	"FCC", "5G", "20M", "HT", "2T", "132", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "26",
+	"MKK", "5G", "20M", "HT", "2T", "132", "26",
+	"FCC", "5G", "20M", "HT", "2T", "136", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "26",
+	"MKK", "5G", "20M", "HT", "2T", "136", "26",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "26",
+	"MKK", "5G", "20M", "HT", "2T", "140", "26",
+	"FCC", "5G", "20M", "HT", "2T", "149", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "26",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "26",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "26",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "26",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "26",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "26",
+	"MKK", "5G", "40M", "HT", "1T", "38", "26",
+	"FCC", "5G", "40M", "HT", "1T", "46", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "26",
+	"MKK", "5G", "40M", "HT", "1T", "46", "26",
+	"FCC", "5G", "40M", "HT", "1T", "54", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "26",
+	"MKK", "5G", "40M", "HT", "1T", "54", "26",
+	"FCC", "5G", "40M", "HT", "1T", "62", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "26",
+	"MKK", "5G", "40M", "HT", "1T", "62", "26",
+	"FCC", "5G", "40M", "HT", "1T", "102", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "26",
+	"MKK", "5G", "40M", "HT", "1T", "102", "26",
+	"FCC", "5G", "40M", "HT", "1T", "110", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "26",
+	"MKK", "5G", "40M", "HT", "1T", "110", "26",
+	"FCC", "5G", "40M", "HT", "1T", "118", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "26",
+	"MKK", "5G", "40M", "HT", "1T", "118", "26",
+	"FCC", "5G", "40M", "HT", "1T", "126", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "26",
+	"MKK", "5G", "40M", "HT", "1T", "126", "26",
+	"FCC", "5G", "40M", "HT", "1T", "134", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "26",
+	"MKK", "5G", "40M", "HT", "1T", "134", "26",
+	"FCC", "5G", "40M", "HT", "1T", "151", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "26",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "26",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "26",
+	"MKK", "5G", "40M", "HT", "2T", "38", "26",
+	"FCC", "5G", "40M", "HT", "2T", "46", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "26",
+	"MKK", "5G", "40M", "HT", "2T", "46", "26",
+	"FCC", "5G", "40M", "HT", "2T", "54", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "26",
+	"MKK", "5G", "40M", "HT", "2T", "54", "26",
+	"FCC", "5G", "40M", "HT", "2T", "62", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "26",
+	"MKK", "5G", "40M", "HT", "2T", "62", "26",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "26",
+	"MKK", "5G", "40M", "HT", "2T", "102", "26",
+	"FCC", "5G", "40M", "HT", "2T", "110", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "26",
+	"MKK", "5G", "40M", "HT", "2T", "110", "26",
+	"FCC", "5G", "40M", "HT", "2T", "118", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "26",
+	"MKK", "5G", "40M", "HT", "2T", "118", "26",
+	"FCC", "5G", "40M", "HT", "2T", "126", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "26",
+	"MKK", "5G", "40M", "HT", "2T", "126", "26",
+	"FCC", "5G", "40M", "HT", "2T", "134", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "26",
+	"MKK", "5G", "40M", "HT", "2T", "134", "26",
+	"FCC", "5G", "40M", "HT", "2T", "151", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "26",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "26",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "22",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "26",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "26",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "26",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "26",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "26",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "26",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "26",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "26",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "26",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "26",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "26",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "26",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "26",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "26",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "26",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "26",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "26",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "26",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "26",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_13_dbm(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8821a_sar_13dbm) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8821a_sar_13dbm;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_5mm.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8821a_sar_5mm[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "30",
+	"MKK", "5G", "20M", "HT", "1T", "36", "30",
+	"FCC", "5G", "20M", "HT", "1T", "40", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "30",
+	"MKK", "5G", "20M", "HT", "1T", "40", "30",
+	"FCC", "5G", "20M", "HT", "1T", "44", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "30",
+	"MKK", "5G", "20M", "HT", "1T", "44", "30",
+	"FCC", "5G", "20M", "HT", "1T", "48", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "30",
+	"MKK", "5G", "20M", "HT", "1T", "48", "30",
+	"FCC", "5G", "20M", "HT", "1T", "52", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "30",
+	"MKK", "5G", "20M", "HT", "1T", "52", "30",
+	"FCC", "5G", "20M", "HT", "1T", "56", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "30",
+	"MKK", "5G", "20M", "HT", "1T", "56", "30",
+	"FCC", "5G", "20M", "HT", "1T", "60", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "30",
+	"MKK", "5G", "20M", "HT", "1T", "60", "30",
+	"FCC", "5G", "20M", "HT", "1T", "64", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "30",
+	"MKK", "5G", "20M", "HT", "1T", "64", "30",
+	"FCC", "5G", "20M", "HT", "1T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "30",
+	"MKK", "5G", "20M", "HT", "1T", "100", "30",
+	"FCC", "5G", "20M", "HT", "1T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "30",
+	"MKK", "5G", "20M", "HT", "1T", "104", "30",
+	"FCC", "5G", "20M", "HT", "1T", "108", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "30",
+	"MKK", "5G", "20M", "HT", "1T", "108", "30",
+	"FCC", "5G", "20M", "HT", "1T", "112", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "30",
+	"MKK", "5G", "20M", "HT", "1T", "112", "30",
+	"FCC", "5G", "20M", "HT", "1T", "116", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "30",
+	"MKK", "5G", "20M", "HT", "1T", "116", "30",
+	"FCC", "5G", "20M", "HT", "1T", "120", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "30",
+	"MKK", "5G", "20M", "HT", "1T", "120", "30",
+	"FCC", "5G", "20M", "HT", "1T", "124", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "30",
+	"MKK", "5G", "20M", "HT", "1T", "124", "30",
+	"FCC", "5G", "20M", "HT", "1T", "128", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "30",
+	"MKK", "5G", "20M", "HT", "1T", "128", "30",
+	"FCC", "5G", "20M", "HT", "1T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "30",
+	"MKK", "5G", "20M", "HT", "1T", "132", "30",
+	"FCC", "5G", "20M", "HT", "1T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "30",
+	"MKK", "5G", "20M", "HT", "1T", "136", "30",
+	"FCC", "5G", "20M", "HT", "1T", "140", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "30",
+	"MKK", "5G", "20M", "HT", "1T", "140", "30",
+	"FCC", "5G", "20M", "HT", "1T", "149", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "30",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "30",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "30",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "30",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "30",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "30",
+	"MKK", "5G", "40M", "HT", "1T", "38", "30",
+	"FCC", "5G", "40M", "HT", "1T", "46", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "30",
+	"MKK", "5G", "40M", "HT", "1T", "46", "30",
+	"FCC", "5G", "40M", "HT", "1T", "54", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "30",
+	"MKK", "5G", "40M", "HT", "1T", "54", "30",
+	"FCC", "5G", "40M", "HT", "1T", "62", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "30",
+	"MKK", "5G", "40M", "HT", "1T", "62", "30",
+	"FCC", "5G", "40M", "HT", "1T", "102", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "30",
+	"MKK", "5G", "40M", "HT", "1T", "102", "30",
+	"FCC", "5G", "40M", "HT", "1T", "110", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "30",
+	"MKK", "5G", "40M", "HT", "1T", "110", "30",
+	"FCC", "5G", "40M", "HT", "1T", "118", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "30",
+	"MKK", "5G", "40M", "HT", "1T", "118", "30",
+	"FCC", "5G", "40M", "HT", "1T", "126", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "30",
+	"MKK", "5G", "40M", "HT", "1T", "126", "30",
+	"FCC", "5G", "40M", "HT", "1T", "134", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "30",
+	"MKK", "5G", "40M", "HT", "1T", "134", "30",
+	"FCC", "5G", "40M", "HT", "1T", "151", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "30",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "30",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "22",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "26",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_5mm(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8821a_sar_5mm) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8821a_sar_5mm;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_8mm.TXT
+******************************************************************************/
+
+const char *array_mp_8821a_txpwr_lmt_8821a_sar_8mm[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "26",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "30",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "26",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "24",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "26",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "24",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "22",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "104", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "104", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "104", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "30",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "30",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "30",
+	"MKK", "5G", "20M", "HT", "1T", "36", "30",
+	"FCC", "5G", "20M", "HT", "1T", "40", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "30",
+	"MKK", "5G", "20M", "HT", "1T", "40", "30",
+	"FCC", "5G", "20M", "HT", "1T", "44", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "30",
+	"MKK", "5G", "20M", "HT", "1T", "44", "30",
+	"FCC", "5G", "20M", "HT", "1T", "48", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "30",
+	"MKK", "5G", "20M", "HT", "1T", "48", "30",
+	"FCC", "5G", "20M", "HT", "1T", "52", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "30",
+	"MKK", "5G", "20M", "HT", "1T", "52", "30",
+	"FCC", "5G", "20M", "HT", "1T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "30",
+	"MKK", "5G", "20M", "HT", "1T", "56", "30",
+	"FCC", "5G", "20M", "HT", "1T", "60", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "30",
+	"MKK", "5G", "20M", "HT", "1T", "60", "30",
+	"FCC", "5G", "20M", "HT", "1T", "64", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "30",
+	"MKK", "5G", "20M", "HT", "1T", "64", "30",
+	"FCC", "5G", "20M", "HT", "1T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "30",
+	"MKK", "5G", "20M", "HT", "1T", "100", "30",
+	"FCC", "5G", "20M", "HT", "1T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "104", "30",
+	"MKK", "5G", "20M", "HT", "1T", "104", "30",
+	"FCC", "5G", "20M", "HT", "1T", "108", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "30",
+	"MKK", "5G", "20M", "HT", "1T", "108", "30",
+	"FCC", "5G", "20M", "HT", "1T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "30",
+	"MKK", "5G", "20M", "HT", "1T", "112", "30",
+	"FCC", "5G", "20M", "HT", "1T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "30",
+	"MKK", "5G", "20M", "HT", "1T", "116", "30",
+	"FCC", "5G", "20M", "HT", "1T", "120", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "30",
+	"MKK", "5G", "20M", "HT", "1T", "120", "30",
+	"FCC", "5G", "20M", "HT", "1T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "30",
+	"MKK", "5G", "20M", "HT", "1T", "124", "30",
+	"FCC", "5G", "20M", "HT", "1T", "128", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "30",
+	"MKK", "5G", "20M", "HT", "1T", "128", "30",
+	"FCC", "5G", "20M", "HT", "1T", "132", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "30",
+	"MKK", "5G", "20M", "HT", "1T", "132", "30",
+	"FCC", "5G", "20M", "HT", "1T", "136", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "30",
+	"MKK", "5G", "20M", "HT", "1T", "136", "30",
+	"FCC", "5G", "20M", "HT", "1T", "140", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "30",
+	"MKK", "5G", "20M", "HT", "1T", "140", "30",
+	"FCC", "5G", "20M", "HT", "1T", "149", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "30",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "30",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "30",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "30",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "30",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "104", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "104", "30",
+	"MKK", "5G", "20M", "HT", "2T", "104", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "26",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "30",
+	"MKK", "5G", "40M", "HT", "1T", "38", "30",
+	"FCC", "5G", "40M", "HT", "1T", "46", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "30",
+	"MKK", "5G", "40M", "HT", "1T", "46", "30",
+	"FCC", "5G", "40M", "HT", "1T", "54", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "30",
+	"MKK", "5G", "40M", "HT", "1T", "54", "30",
+	"FCC", "5G", "40M", "HT", "1T", "62", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "30",
+	"MKK", "5G", "40M", "HT", "1T", "62", "30",
+	"FCC", "5G", "40M", "HT", "1T", "102", "24",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "30",
+	"MKK", "5G", "40M", "HT", "1T", "102", "30",
+	"FCC", "5G", "40M", "HT", "1T", "110", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "30",
+	"MKK", "5G", "40M", "HT", "1T", "110", "30",
+	"FCC", "5G", "40M", "HT", "1T", "118", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "30",
+	"MKK", "5G", "40M", "HT", "1T", "118", "30",
+	"FCC", "5G", "40M", "HT", "1T", "126", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "30",
+	"MKK", "5G", "40M", "HT", "1T", "126", "30",
+	"FCC", "5G", "40M", "HT", "1T", "134", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "30",
+	"MKK", "5G", "40M", "HT", "1T", "134", "30",
+	"FCC", "5G", "40M", "HT", "1T", "151", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "30",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "30",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "22",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "20",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "28",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_8mm(struct dm_struct *dm)
+{
+	u32     i           = 0;
+	u32     array_len    = sizeof(array_mp_8821a_txpwr_lmt_8821a_sar_8mm) / sizeof(u8 *);
+	u8 **array      = (u8 **)array_mp_8821a_txpwr_lmt_8821a_sar_8mm;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	void		*adapter = dm->adapter;
+	HAL_DATA_TYPE	*hal_data = GET_HAL_DATA(((PADAPTER)adapter));
+
+	PlatformZeroMemory(hal_data->BufOfLinesPwrLmt, MAX_LINES_HWCONFIG_TXT * MAX_BYTES_LINE_HWCONFIG_TXT);
+	hal_data->nLinesReadPwrLmt = array_len / 7;
+#endif
+
+	PHYDM_DBG(dm, ODM_COMP_INIT, "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8821a(dm, regulation, band, bandwidth, rate, rf_path, chnl, val);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		rsprintf((char *)hal_data->BufOfLinesPwrLmt[i / 7], 100, "\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\",",
+			 regulation, band, bandwidth, rate, rf_path, chnl, val);
+#endif
+	}
+}
+
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/halhwimg8821a_rf.h /hal/phydm/rtl8821a/halhwimg8821a_rf.h
--- /hal/phydm/rtl8821a/halhwimg8821a_rf.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/halhwimg8821a_rf.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,137 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 2.18*/
+#if (RTL8821A_SUPPORT == 1)
+#ifndef __INC_MP_RF_HW_IMG_8821A_H
+#define __INC_MP_RF_HW_IMG_8821A_H
+
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_radioa( /* TC: Test Chip, MP: MP Chip*/
+				    struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_radioa(void);
+
+/******************************************************************************
+*                           TxPowerTrack_AP.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_ap( /* TC: Test Chip, MP: MP Chip*/
+					     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpowertrack_ap(void);
+
+/******************************************************************************
+*                           TxPowerTrack_PCIE.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_pcie( /* TC: Test Chip, MP: MP Chip*/
+					       struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpowertrack_pcie(void);
+
+/******************************************************************************
+*                           TxPowerTrack_SDIO.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_sdio( /* TC: Test Chip, MP: MP Chip*/
+					       struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpowertrack_sdio(void);
+
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpowertrack_usb( /* TC: Test Chip, MP: MP Chip*/
+					      struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpowertrack_usb(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8811AU_FEM.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8811a_u_fem(
+						   /* TC: Test Chip, MP: MP Chip*/
+						   struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8811a_u_fem(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8811AU_IPA.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8811a_u_ipa(
+						   /* TC: Test Chip, MP: MP Chip*/
+						   struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8811a_u_ipa(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a( /* TC: Test Chip, MP: MP Chip*/
+					     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8821a(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_E202SA.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_e202sa(
+						    /* TC: Test Chip, MP: MP Chip*/
+						    struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8821a_e202sa(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_13dBm.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_13_dbm(
+							/* TC: Test Chip, MP: MP Chip*/
+							struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8821a_sar_13_dbm(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_5mm.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_5mm(
+						     /* TC: Test Chip, MP: MP Chip*/
+						     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8821a_sar_5mm(void);
+
+/******************************************************************************
+*                           TXPWR_LMT_8821A_SAR_8mm.TXT
+******************************************************************************/
+
+void
+odm_read_and_config_mp_8821a_txpwr_lmt_8821a_sar_8mm(
+						     /* TC: Test Chip, MP: MP Chip*/
+						     struct dm_struct *dm);
+u32 odm_get_version_mp_8821a_txpwr_lmt_8821a_sar_8mm(void);
+
+#endif
+#endif /* end of HWIMG_SUPPORT*/
diff -Naur /hal/phydm/rtl8821a/phydm_regconfig8821a.c /hal/phydm/rtl8821a/phydm_regconfig8821a.c
--- /hal/phydm/rtl8821a/phydm_regconfig8821a.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/phydm_regconfig8821a.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1)
+
+void odm_config_rf_reg_8821a(struct dm_struct *dm, u32 addr, u32 data,
+			     enum rf_path RF_PATH, u32 reg_addr)
+{
+	if (addr == 0xfe || addr == 0xffe) {
+#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+#else
+		ODM_delay_ms(50);
+#endif
+	} else if (addr == 0xfd)
+		ODM_delay_ms(5);
+	else if (addr == 0xfc)
+		ODM_delay_ms(1);
+	else if (addr == 0xfb)
+		ODM_delay_us(50);
+	else if (addr == 0xfa)
+		ODM_delay_us(5);
+	else if (addr == 0xf9)
+		ODM_delay_us(1);
+	else {
+		odm_set_rf_reg(dm, RF_PATH, reg_addr, RFREGOFFSETMASK, data);
+		/* Add 1us delay between BB/RF register setting. */
+		ODM_delay_us(1);
+	}
+}
+
+void odm_config_rf_radio_a_8821a(struct dm_struct *dm, u32 addr, u32 data)
+{
+	u32 content = 0x1000; /* RF_Content: radioa_txt */
+	u32 maskfor_phy_set = (u32)(content & 0xE000);
+
+	odm_config_rf_reg_8821a(dm, addr, data, RF_PATH_A, addr | maskfor_phy_set);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_rf_with_header_file: [RadioA] %08X %08X\n",
+		  addr, data);
+}
+
+/* 8821 no RF B */
+#if 0
+void
+odm_config_rf_radio_b_8821a(
+	struct dm_struct				*dm,
+	u32					addr,
+	u32					data
+)
+{
+	u32  content = 0x1001; /*  RF_Content: radiob_txt */
+	u32	maskfor_phy_set = (u32)(content & 0xE000);
+
+	odm_config_rf_reg_8812a(dm, addr, data, RF_PATH_B, addr | maskfor_phy_set);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_rf_with_header_file: [RadioB] %08X %08X\n",
+		  addr, data);
+}
+#endif
+
+void odm_config_mac_8821a(struct dm_struct *dm, u32 addr, u8 data)
+{
+	odm_write_1byte(dm, addr, data);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_mac_with_header_file: [MAC_REG] %08X %08X\n",
+		  addr, data);
+}
+
+void odm_config_bb_agc_8821a(struct dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data)
+{
+	odm_set_bb_reg(dm, addr, bitmask, data);
+	/* Add 1us delay between BB/RF register setting. */
+	ODM_delay_us(1);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_bb_with_header_file: [AGC_TAB] %08X %08X\n",
+		  addr, data);
+}
+
+void odm_config_bb_phy_reg_pg_8821a(struct dm_struct *dm, u32 band, u32 rf_path,
+				    u32 tx_num, u32 addr, u32 bitmask, u32 data)
+{
+	if (addr == 0xfe)
+#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+#else
+		ODM_delay_ms(50);
+#endif
+	else if (addr == 0xfd)
+		ODM_delay_ms(5);
+	else if (addr == 0xfc)
+		ODM_delay_ms(1);
+	else if (addr == 0xfb)
+		ODM_delay_us(50);
+	else if (addr == 0xfa)
+		ODM_delay_us(5);
+	else if (addr == 0xf9)
+		ODM_delay_us(1);
+
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_bb_with_header_file: [PHY_REG] %08X %08X %08X\n",
+		  addr, bitmask, data);
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	phy_store_tx_power_by_rate(dm->adapter, band, rf_path, tx_num, addr, bitmask, data);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PHY_StoreTxPowerByRate(dm->adapter, band, rf_path, tx_num, addr, bitmask, data);
+#endif
+}
+
+void odm_config_bb_phy_8821a(struct dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data)
+{
+	if (addr == 0xfe)
+#ifdef CONFIG_LONG_DELAY_ISSUE
+		ODM_sleep_ms(50);
+#else
+		ODM_delay_ms(50);
+#endif
+	else if (addr == 0xfd)
+		ODM_delay_ms(5);
+	else if (addr == 0xfc)
+		ODM_delay_ms(1);
+	else if (addr == 0xfb)
+		ODM_delay_us(50);
+	else if (addr == 0xfa)
+		ODM_delay_us(5);
+	else if (addr == 0xf9)
+		ODM_delay_us(1);
+	else if (addr == 0xa24)
+		dm->rf_calibrate_info.rega24 = data;
+	odm_set_bb_reg(dm, addr, bitmask, data);
+
+	/* Add 1us delay between BB/RF register setting. */
+	ODM_delay_us(1);
+	PHYDM_DBG(dm, ODM_COMP_INIT,
+		  "===> odm_config_bb_with_header_file: [PHY_REG] %08X %08X\n",
+		  addr, data);
+}
+
+void odm_config_bb_txpwr_lmt_8821a(struct dm_struct *dm, u8 *regulation,
+				   u8 *band, u8 *bandwidth, u8 *rate_section,
+				   u8 *rf_path, u8 *channel, u8 *power_limit)
+{
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	phy_set_tx_power_limit(dm, regulation, band,
+			       bandwidth, rate_section, rf_path, channel, power_limit);
+#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PHY_SetTxPowerLimit(dm, regulation, band,
+			    bandwidth, rate_section, rf_path, channel, power_limit);
+#endif
+}
+
+#endif /* #if (RTL8821A_SUPPORT == 1)*/
diff -Naur /hal/phydm/rtl8821a/phydm_regconfig8821a.h /hal/phydm/rtl8821a/phydm_regconfig8821a.h
--- /hal/phydm/rtl8821a/phydm_regconfig8821a.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/phydm_regconfig8821a.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef __INC_ODM_REGCONFIG_H_8821A
+#define __INC_ODM_REGCONFIG_H_8821A
+
+#if (RTL8821A_SUPPORT == 1)
+
+void odm_config_rf_reg_8821a(struct dm_struct *dm, u32 addr, u32 data,
+			     enum rf_path RF_PATH, u32 reg_addr);
+
+void odm_config_rf_radio_a_8821a(struct dm_struct *dm, u32 addr, u32 data);
+
+void odm_config_rf_radio_b_8821a(
+	struct dm_struct *dm,
+	u32 addr,
+	u32 data);
+
+void odm_config_mac_8821a(struct dm_struct *dm, u32 addr, u8 data);
+
+void odm_config_bb_agc_8821a(struct dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data);
+
+void odm_config_bb_phy_reg_pg_8821a(struct dm_struct *dm, u32 band, u32 rf_path,
+				    u32 tx_num, u32 addr, u32 bitmask,
+				    u32 data);
+
+void odm_config_bb_phy_8821a(struct dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data);
+
+void odm_config_bb_txpwr_lmt_8821a(struct dm_struct *dm, u8 *regulation,
+				   u8 *band, u8 *bandwidth, u8 *rate_section,
+				   u8 *rf_path, u8 *channel, u8 *power_limit);
+
+#endif
+#endif /* end of SUPPORT */
diff -Naur /hal/phydm/rtl8821a/phydm_rtl8821a.c /hal/phydm/rtl8821a/phydm_rtl8821a.c
--- /hal/phydm/rtl8821a/phydm_rtl8821a.c	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/phydm_rtl8821a.c	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,146 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+
+#include "mp_precomp.h"
+
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1) || (RTL8881A_SUPPORT == 1)
+
+s8 phydm_cck_rssi_8821a(struct dm_struct *dm, u16 lna_idx, u8 vga_idx)
+{
+	s8 rx_pwr_all = 0;
+
+	switch (lna_idx) {
+	case 5:
+		rx_pwr_all = -38 - (2 * vga_idx);
+		break;
+	case 4:
+		rx_pwr_all = -30 - (2 * vga_idx);
+		break;
+	case 2:
+		rx_pwr_all = -17 - (2 * vga_idx);
+		break;
+	case 1:
+		rx_pwr_all = -1 - (2 * vga_idx);
+		break;
+	case 0:
+		rx_pwr_all = 15 - (2 * vga_idx);
+		break;
+	default:
+		break;
+	}
+
+	return rx_pwr_all;
+}
+
+void phydm_set_ext_band_switch_8821A(void *dm_void, u32 band)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+
+	/*Output Pin Settings*/
+	odm_set_mac_reg(dm, R_0x4c, BIT(23), 0); /*select DPDT_P and DPDT_N as output pin*/
+	odm_set_mac_reg(dm, R_0x4c, BIT(24), 1); /*by WLAN control*/
+
+	odm_set_bb_reg(dm, R_0xcb4, 0xF, 7); /*DPDT_P = 1b'0*/
+	odm_set_bb_reg(dm, R_0xcb4, 0xF0, 7); /*DPDT_N = 1b'0*/
+
+	if (band == ODM_BAND_2_4G) {
+		odm_set_bb_reg(dm, R_0xcb4, (BIT(29) | BIT(28)), 1);
+		PHYDM_DBG(dm, DBG_ANT_DIV,
+			  "***8821A set band switch = 2b'01\n");
+	} else {
+		odm_set_bb_reg(dm, R_0xcb4, BIT(29) | BIT(28), 2);
+		PHYDM_DBG(dm, DBG_ANT_DIV,
+			  "***8821A set band switch = 2b'10\n");
+	}
+}
+
+void odm_dynamic_try_state_agg_8821a(struct dm_struct *dm)
+{
+	if ((dm->support_ic_type & ODM_RTL8821) && dm->support_interface == ODM_ITRF_USB) {
+		if (dm->rssi_min > 25)
+			odm_write_1byte(dm, 0x4CF, 0x02);
+		else if (dm->rssi_min < 20)
+			odm_write_1byte(dm, 0x4CF, 0x00);
+	}
+}
+
+void odm_dynamic_packet_detection_th_8821a(struct dm_struct *dm)
+{
+	if (dm->support_ic_type & ODM_RTL8821) {
+		if (dm->rssi_min <= 25) {
+			/*odm_set_bb_reg(dm, REG_PWED_TH_JAGUAR, MASKDWORD, 0x2aaaf1a8);*/
+			odm_set_bb_reg(dm, REG_PWED_TH_JAGUAR, 0x1ff0, 0x11a);
+			odm_set_bb_reg(dm, REG_BW_INDICATION_JAGUAR, BIT(26), 1);
+		} else if (dm->rssi_min >= 30) {
+			/*odm_set_bb_reg(dm, REG_PWED_TH_JAGUAR, MASKDWORD, 0x2aaaeec8);*/
+			odm_set_bb_reg(dm, REG_PWED_TH_JAGUAR, 0x1ff0, 0xec);
+			odm_set_bb_reg(dm, REG_BW_INDICATION_JAGUAR, BIT(26), 0);
+		}
+	}
+}
+
+void odm_hw_setting_8821a(struct dm_struct *dm)
+{
+	odm_dynamic_try_state_agg_8821a(dm);
+	odm_dynamic_packet_detection_th_8821a(dm);
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+void odm_dynamic_tx_power_8821(void *dm_void, u8 *desc, u8 macid)
+{
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
+	struct cmn_sta_info *entry = NULL;
+	u8 reg_c56 = 0;
+	u8 txpwr_offset = 0;
+	u8 rssi_tmp = 0;
+
+	if (!is_sta_active(entry))
+		return;
+
+	PHYDM_DBG(dm, DBG_DYN_TXPWR, "[%s]======>\n", __func__);
+
+	entry = dm->phydm_sta_info[macid];
+	rssi_tmp = entry[macid].rssi_stat.rssi;
+
+	if (rssi_tmp > 85) {
+		reg_c56 = odm_read_1byte(dm, 0xc56);
+		PHYDM_DBG(dm, DBG_DYN_TXPWR, "0xc56=0x%x\n", reg_c56);
+		/* @Avoid TXAGC error after TX power offset is applied.
+		For example: Reg0xc56=0x6, if txpwr_offset=3( reduce 11dB )
+		Total power = 6-11= -5( overflow!! ), PA may be burned !
+		so txpwr_offset should be adjusted by Reg0xc56*/
+
+		if (reg_c56 < 14)
+			txpwr_offset = 1;
+		else if (reg_c56 < 22)
+			txpwr_offset = 2;
+		else
+			txpwr_offset = 3;
+	}
+
+	SET_TX_DESC_TX_POWER_OFFSET_8812(desc, txpwr_offset);
+
+	PHYDM_DBG(dm, DBG_DYN_TXPWR, "RSSI=%d, txpwr_ofst=%d\n",
+		  rssi_tmp, txpwr_offset);
+}
+#endif /*@#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
+
+#endif /* #if (RTL8821A_SUPPORT == 1) */
diff -Naur /hal/phydm/rtl8821a/phydm_rtl8821a.h /hal/phydm/rtl8821a/phydm_rtl8821a.h
--- /hal/phydm/rtl8821a/phydm_rtl8821a.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/phydm_rtl8821a.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef __ODM_RTL8821A_H__
+#define __ODM_RTL8821A_H__
+
+s8 phydm_cck_rssi_8821a(struct dm_struct *dm, u16 lna_idx, u8 vga_idx);
+
+void phydm_set_ext_band_switch_8821A(void *dm_void, u32 band);
+
+void odm_hw_setting_8821a(struct dm_struct *dm);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+void odm_dynamic_tx_power_8821(void *dm_void, u8 *desc, u8 mac_id);
+#endif
+
+#endif
diff -Naur /hal/phydm/rtl8821a/version_rtl8821a.h /hal/phydm/rtl8821a/version_rtl8821a.h
--- /hal/phydm/rtl8821a/version_rtl8821a.h	1969-12-31 19:00:00.000000000 -0500
+++ /hal/phydm/rtl8821a/version_rtl8821a.h	2021-07-08 15:24:26.000000000 -0400
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+/*RTL8821A PHY Parameters*/
+/*
+[Caution]
+  Since 01/Aug/2015, the commit rules will be simplified.
+  You do not need to fill up the version.h anymore,
+  only the maintenance supervisor fills it before formal release.
+*/
+#define	RELEASE_DATE_8821A		20150920
+#define	COMMIT_BY_8821A			"BB_LUKE"
+#define	RELEASE_VERSION_8821A	59
diff -Naur /hal/rtl8812a/usb/rtl8812au_led.c /hal/rtl8812a/usb/rtl8812au_led.c
--- /hal/rtl8812a/usb/rtl8812au_led.c	2022-01-21 10:50:56.166185000 -0500
+++ /hal/rtl8812a/usb/rtl8812au_led.c	2022-01-21 11:12:01.734205421 -0500
@@ -368,8 +368,17 @@
 			pledpriv->SwLedOff = SwLedOff_8812AU;
 		}
 	} else {
-		pledpriv->SwLedOn = SwLedOn_8821AU;
-		pledpriv->SwLedOff = SwLedOff_8821AU;
+//		pledpriv->SwLedOn = SwLedOn_8821AU;
+//		pledpriv->SwLedOff = SwLedOff_8821AU;
+		/* Turn on/off LED according to led_ctrl specified. */
+		if (padapter->registrypriv.led_ctrl == 0) {
+			pledpriv->SwLedOff = SwLedOff_8821AU;
+		} else if (padapter->registrypriv.led_ctrl >= 2) {
+			pledpriv->SwLedOn = SwLedOn_8821AU;
+		} else {
+			pledpriv->SwLedOn = SwLedOn_8821AU;
+			pledpriv->SwLedOff = SwLedOff_8821AU;
+		}
 	}
 
 	InitLed(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
diff -Naur /Makefile /Makefile
--- /Makefile	2022-01-21 10:50:56.170185000 -0500
+++ /Makefile	2022-01-21 10:55:05.982189680 -0500
@@ -32,8 +32,8 @@
 ########################## WIFI IC ############################
 CONFIG_MULTIDRV = n
 CONFIG_RTL8188E = n
-CONFIG_RTL8812A = y
-CONFIG_RTL8821A = n
+CONFIG_RTL8812A = n
+CONFIG_RTL8821A = y
 CONFIG_RTL8192E = n
 CONFIG_RTL8723B = n
 CONFIG_RTL8814A = n
@@ -62,7 +62,7 @@
 CONFIG_LPS_MODE = default
 CONFIG_USB_AUTOSUSPEND = n
 CONFIG_HW_PWRP_DETECTION = n
-CONFIG_BT_COEXIST = n
+CONFIG_BT_COEXIST = y
 CONFIG_WAPI_SUPPORT = n
 CONFIG_EFUSE_CONFIG_FILE = y
 CONFIG_EXT_CLK = n
diff -Naur /os_dep/linux/usb_intf.c /os_dep/linux/usb_intf.c
--- /os_dep/linux/usb_intf.c	2022-01-21 10:50:56.182185000 -0500
+++ /os_dep/linux/usb_intf.c	2022-01-21 11:10:11.910203719 -0500
@@ -211,6 +211,27 @@
 	{USB_DEVICE(0x056E, 0x400E) , .driver_info = RTL8821}, /* ELECOM -  ELECOM */
 	{USB_DEVICE(0x056E, 0x400F) , .driver_info = RTL8821}, /* ELECOM -  ELECOM */
 	{USB_DEVICE(0x20f4, 0x804b), .driver_info = RTL8821}, /* TRENDnet  */
+	{USB_DEVICE(0x2357, 0x011F), .driver_info = RTL8821}, /* TP-Link_T2Uv3  */
+	{USB_DEVICE(0x2357, 0x011E), .driver_info = RTL8821}, /* TP-Link_T2Unanov1  */
+	{USB_DEVICE(0x2357, 0x0120), .driver_info = RTL8821}, /* TP-Link_T2Uplusv1  */
+	{USB_DEVICE(0x7392, 0xA813), .driver_info = RTL8821}, /* Default ID */
+	{USB_DEVICE(0x0BDA, 0x0170), .driver_info = RTL8821}, /* Default ID */
+	{USB_DEVICE(0x0BDA, 0x2003), .driver_info = RTL8821}, /* I-O DATA - I-O DATA */
+	{USB_DEVICE(0x2019, 0xAB32), .driver_info = RTL8821}, /* Planex - GW-450S */
+	{USB_DEVICE(0x0DF6, 0x007A), .driver_info = RTL8821}, /* Sitecom - Sitecom */
+	{USB_DEVICE(0x056E, 0x4007), .driver_info = RTL8821}, /* ELECOM - WDC433DU2 */
+	{USB_DEVICE(0x07B8, 0x0811), .driver_info = RTL8821}, /* Abocom - Abocom */
+	{USB_DEVICE(0x04BB, 0x0959), .driver_info = RTL8821}, /* I-O DATA - WN-AC433UM  */
+	{USB_DEVICE(0x04BB, 0x095A), .driver_info = RTL8821}, /* I-O DATA - WHG-AC433UM  */
+	{USB_DEVICE(0x2357, 0x0121), .driver_info = RTL8821}, /* TP-Link - TP-Link */
+	{USB_DEVICE(0x1EDA, 0x2520), .driver_info = RTL8821}, /* AirTies - Air2520 */
+	{USB_DEVICE(0x1EDA, 0x2525), .driver_info = RTL8821}, /* AirTies - Air2525 */
+	{USB_DEVICE(0x0411, 0x0242), .driver_info = RTL8821}, /* BUFFALO - WI-U2-433DM */
+	{USB_DEVICE(0x0411, 0x029B), .driver_info = RTL8821}, /* BUFFALO - WI-U2-433DHP */
+	{USB_DEVICE(0x0411, 0x029D), .driver_info = RTL8821}, /* BUFFALO - WLP-U2-433DHP */
+	{USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0xB611, 0xff, 0xff, 0xff), .driver_info = RTL8821}, /* Edimax - Edimax */
+	{USB_DEVICE(0x0846, 0x9052), .driver_info = RTL8821}, /* Netgear - A6100 */
+	{USB_DEVICE(0x3823, 0x6249), .driver_info = RTL8821}, /* Obihai - OBiWiFi */
 #endif
 
 #ifdef CONFIG_RTL8192E
